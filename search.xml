<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>JavaScript中的基本类型和引用类型</title>
    <url>/2020/01/14/JavaScript%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p><code>ECMAScript</code>变量包含两种不同数据类型的值，一种是<strong>基本类型</strong>，另一种是<strong>引用类型</strong>。<strong>基本类型</strong>是简单是数据段，不能再有其他属性值；<strong>引用类型</strong>是指可以有多个值的对象。</p>
<p><code>ECMAScript</code>里面有六种基本数据类型：<strong>Undefined、Null、Boolean、Number 、String、Symbol</strong>。这几种类型是按值访问的，因为可以操作保存在<strong>栈</strong>中变量的实际的值。</p>
<p>引用类型的值是保存在<strong>堆</strong>中的对象，和其他语言不一样的是，<code>ECMAScript</code>不允许直接访问内存中的位置，即不能直接操作对象内存空间，所以在操作对象时，其实是在操作对象的引用，而不是实际的对象，所以引用类型的值是按引用访问的。</p>
<h1 id="二、复制变量值"><a href="#二、复制变量值" class="headerlink" title="二、复制变量值"></a>二、复制变量值</h1><p>基本类型会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p>
<p>引用类型同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中，但是这个值的副本实际上是一个指针，指向原来的对象。</p>
<a id="more"></a>

<h1 id="三、传递参数"><a href="#三、传递参数" class="headerlink" title="三、传递参数"></a>三、传递参数</h1><p><code>ECMAScript</code> 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。基本类型值的传递如同基本类型变量的复制一样，而引用类型值的传递，则如同引用类型变量的复制一样。<br>看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Hal"</span>;</span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    obj.name = <span class="string">"Greg"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">setName(person);</span><br><span class="line">alert(person.name); <span class="comment">//"Hal"</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中在把<code>person</code> 传递给<code>setName()</code>后，其<code>name</code> 属性被设置为<code>&quot;Hal&quot;</code>。然后，又将一个新对象赋给变量<code>obj</code>，同时将其<code>name</code>属性设置为<code>&quot;Greg&quot;</code>。如果是按引用传递的，那么<code>person</code> 就会自动被修改为指向其<code>name</code> 属性值为 <code>&quot;Greg&quot;</code>的新对象。但是并没有，这说明即使在函数内部改变了参数的值，但其原始引用依然保持不变。<br>实际上，当在函数内部重写<code>obj</code> 时，这个变量引用的就是一个局部对象了，而这个局部对象会在函数执行完毕后立即被销毁。</p>
<h1 id="四、检测类型"><a href="#四、检测类型" class="headerlink" title="四、检测类型"></a>四、检测类型</h1><p>基本类型的检测可以使用<code>typeof</code>·操作符，引用类型的检测可以使用<code>instanceof</code>操作符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">"H"</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> i = <span class="number">24</span>;</span><br><span class="line"><span class="keyword">var</span> u;</span><br><span class="line"><span class="keyword">var</span> n = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">alert(<span class="keyword">typeof</span> s); <span class="comment">//string</span></span><br><span class="line">alert(<span class="keyword">typeof</span> i); <span class="comment">//number</span></span><br><span class="line">alert(<span class="keyword">typeof</span> b); <span class="comment">//boolean</span></span><br><span class="line">alert(<span class="keyword">typeof</span> u); <span class="comment">//undefined</span></span><br><span class="line">alert(<span class="keyword">typeof</span> n); <span class="comment">//object</span></span><br><span class="line">alert(<span class="keyword">typeof</span> o); <span class="comment">//object</span></span><br><span class="line">DeterminingTypeExample01</span><br></pre></td></tr></table></figure>

<p><code>typeof null</code>返回的是<code>object</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> colors = [];</span><br><span class="line"><span class="keyword">var</span> pattern = <span class="keyword">new</span> <span class="built_in">RegExp</span>();</span><br><span class="line"></span><br><span class="line">alert(person <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br><span class="line">alert(colors <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line">alert(pattern <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>所有引用类型的值都是Object 的实例</strong>，也就是说所有引用类型加<code>instanceof Object</code>都会返回<code>true</code>，所有基本类型使用<code>instanceof</code>都会返回<code>false</code>，因为基本类型不是对象。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 基本类型 引用类型</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript创建对象的几种方式</title>
    <url>/2020/01/13/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>虽然<code>Object</code> 构造函数或对象字面量都可以用来创建单个对象，但这些方式有个明显的缺点：使用同一个接口创建很多对象，会产生大量的重复代码。所以为解决这个问题，开始使用工厂模式的一种变体来创建对象。</p>
<h1 id="二、工厂模式"><a href="#二、工厂模式" class="headerlink" title="二、工厂模式"></a>二、工厂模式</h1><p>用函数来封装以特定接口创建对象的细节，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p>工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<a id="more"></a>


<h1 id="三、构造函数模式"><a href="#三、构造函数模式" class="headerlink" title="三、构造函数模式"></a>三、构造函数模式</h1><p><code>ECMAScript</code> 中的构造函数可用来创建特定类型的对象，像<code>Object</code> 和<code>Array</code> 这样的原生构造函数，在运行时会自动出现在执行环境中。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。上面的例子改写成构造函数模式为：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>

<p><code>Person()</code>函数中的代码除了与<code>createPerson()</code>中相同的部分外，还存在以下不同之处：</p>
<ul>
<li>没有显式地创建对象</li>
<li>直接将属性和方法赋给了<code>this</code> 对象</li>
<li>没有<code>return</code> 语句</li>
</ul>
<p><code>Person</code>函数的首字母是大写，按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。要创建<code>Person</code> 的新实例，必须使用<code>new</code> 操作符，其过程如下：</p>
<ul>
<li>(1) 创建一个新对象</li>
<li>(2) 将构造函数的作用域赋给新对象（因此this 就指向了这个新对象）</li>
<li>(3) 执行构造函数中的代码（为这个新对象添加属性）</li>
<li>(4) 返回新对象</li>
</ul>
<p>上面的<code>person1</code> 和<code>person2</code> 分别保存着<code>Person</code> 的一个不同的实例。这两个对象都有一个<code>constructor</code>（构造函数）属性，该属性指向<code>Person</code>：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><span class="line">alert(person1.<span class="keyword">constructor</span> == Person); <span class="comment">//true</span></span><br><span class="line">alert(person2.<span class="keyword">constructor</span> == Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>对象的<code>constructor</code> 属性最初是用来标识对象类型的。但是，提到检测对象类型，还是<code>instanceof</code>操作符要更可靠一些。这个例子中创建的所有对象既是<code>Object</code> 的实例，同时也是<code>Person</code>的实例，这一点通过<code>instanceof</code> 操作符可以得到验证。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h3 id="将构造函数当作函数"><a href="#将构造函数当作函数" class="headerlink" title="将构造函数当作函数"></a>将构造函数当作函数</h3><p>构造函数与其他函数的唯一区别，就在于调用它们的方式不同。任何函数，只要通过<code>new</code> 操作符来调用，那它就可以作为构造函数；而任何函数，如果不通过<code>new</code> 操作符来调用，那它跟普通函数也不会有什么两样。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当作构造函数使用</span></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">person.sayName(); <span class="comment">//"Hal"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为普通函数调用</span></span><br><span class="line">Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>); <span class="comment">// 添加到window</span></span><br><span class="line"><span class="built_in">window</span>.sayName(); <span class="comment">//"Greg"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在另一个对象的作用域中调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">Person.call(o, <span class="string">"Kristen"</span>, <span class="number">25</span>, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName(); <span class="comment">//"Kristen"</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数的问题"><a href="#构造函数的问题" class="headerlink" title="构造函数的问题"></a>构造函数的问题</h3><p>使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。即上面的构造函数等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>); <span class="comment">// 与声明函数在逻辑上是等价的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">alert<span class="comment">(person1.sayName == person2.sayName)</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>上面代码可以说明两个实例上的同名函数是不相等的。</p>
<p>但是，创建两个一模一样的函数实例是没有必要的，况且还有<code>this</code>对象，根本不用 在执行代码前就把函数绑定到特定对象上，所以，可以像下面一样，通过把函数转移到构造函数外部来解决这个问题。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.sayName = sayName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面虽然解决了两个函数做同一件事的问题，但是新问题有出现了，在全局定义域中定义的函数实际上只能被某个对象调用，这让全局作用域有点名不副实，而且更糟的是，如果对象需要定义很多方法，就需要定义很多个全局函数，然后上面的自定义构造函数就没有任何封装性可言了。好在这些问题可以通过原型模式来解决。</p>
<h1 id="四、原型模式"><a href="#四、原型模式" class="headerlink" title="四、原型模式"></a>四、原型模式</h1><p>我们创建的每一个函数都有一个<code>prototype</code>原型属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。<code>prototype</code> 就是通过调用构造函数而创建的那个对象实例的原型对象，使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法，也就是说，可以不用在构造函数中定义对象实例的信息，而是将这些信息直接添加到原型对象上面，如下所示：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.name = <span class="string">"Hal"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">24</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName(); <span class="comment">//"Hal"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person2.sayName(); <span class="comment">//"Hal"</span></span><br><span class="line">alert(person1.sayName == person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>新对象的这些属性和方法是由所有实例共享的，也就是说<code>person1</code> 和<code>person2</code> 访问的都是同一组属性和同一个<code>sayName()</code>函数。</p>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><p>它省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都将取得相同的属性值，但还不是原型的最大问题，其最大的问题还是由其共享的本性所导致的。对于那些包含基本值的属性倒也说得过去，通过在实例上添加一个同名属性可以隐藏原型中的对应属性。但是对于包含了引用类型值的属性来说，问题就比较明显了，看下面的例子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor: Person,</span><br><span class="line">    name : <span class="string">"Hal"</span>,</span><br><span class="line">    age : <span class="number">24</span>,</span><br><span class="line">    job : <span class="string">"Software Engineer"</span>,</span><br><span class="line">    friends : [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>],</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Court,Van"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，我们本意是给<code>person1</code>的<code>friends</code>属性添加一个<code>Van</code>，而并不想给<code>person2</code>也添加，但是由于共享属性的缘故，<code>person2</code>的属性也跟着变了。这也就是很少有人单独使用原型模式的原因所在。</p>
<h1 id="五、组合使用构造函数模式和原型模式"><a href="#五、组合使用构造函数模式和原型模式" class="headerlink" title="五、组合使用构造函数模式和原型模式"></a>五、组合使用构造函数模式和原型模式</h1><p>创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    constructor : Person,</span><br><span class="line">    sayName : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br><span class="line"></span><br><span class="line">person1.friends.push(<span class="string">"Van"</span>);</span><br><span class="line">alert(person1.friends); <span class="comment">//"Shelby,Count,Van"</span></span><br><span class="line">alert(person2.friends); <span class="comment">//"Shelby,Count"</span></span><br><span class="line">alert(person1.friends === person2.friends); <span class="comment">//false</span></span><br><span class="line">alert(person1.sayName === person2.sayName); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，实例属性都是在构造函数中定义的，而由所有实例共享的属性<code>constructor</code> 和方法<code>sayName()</code>则是在原型中定义的。而修改了<code>person1.friends</code>，并不会影响到<code>person2.friends</code>，因为它们分别引用了不同的数组。</p>
<p><strong>！这种构造函数与原型混成的模式，是目前在ECMAScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。</strong></p>
<h1 id="六、动态原型模式"><a href="#六、动态原型模式" class="headerlink" title="六、动态原型模式"></a>六、动态原型模式</h1><p>看到前面独立的构造函数和原型时，有其他OO语言开发经验的人很可能会感到非常困惑。<strong>动态原型模式</strong>正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，<strong>可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span><span class="params">(name, age, job)</span></span>&#123;</span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">        Person.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            alert(<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里只在<code>sayName()</code>方法不存在的情况下，才会将它添加到原型中。这段代码只会在初次调用构造函数时才会执行。此后，原型已经完成初始化，不需要再做什么修改了。对于采用这种模式创建的对象，还可以使用<code>instanceof</code> 操作符确定它的类型。</p>
<p><strong>！使用动态原型模式时，不能使用对象字面量重写原型。前面已经解释过了，如果在已经创建了实例的情况下重写原型，那么就会切断现有实例与新原型之间的联系。</strong></p>
<h1 id="七、寄生构造函数模式"><a href="#七、寄生构造函数模式" class="headerlink" title="七、寄生构造函数模式"></a>七、寄生构造函数模式</h1><p>在前述的几种模式都不适用的情况下，可以使用寄生（parasitic）构造函数模式。这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象。但从表面上看，这个函数又很像是典型的构造函数。下面是一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.job = job;</span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Hal"</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>Person</code> 函数创建了一个新对象，并以相应的属性和方法初始化该对象，然后又返回了这个对象。除了使用<code>new</code> 操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。而通过在构造函数的末尾添加一个<code>return</code> 语句，可以重写调用构造函数时返回的值。</p>
<p>这个模式可以在特殊的情况下用来为对象创建构造函数。假设我们想创建一个具有额外方法的特殊数组。由于不能直接修改<code>Array</code> 构造函数，因此可以使用这个模式。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SpecialArray</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="keyword">var</span> values = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="comment">//添加值</span></span><br><span class="line">    values.push.apply(values, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    values.toPipedString = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.join(<span class="string">"|"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回数组</span></span><br><span class="line">    <span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> SpecialArray(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br><span class="line">alert(colors.toPipedString()); <span class="comment">//"red|blue|green"</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个名叫<code>SpecialArray</code> 的构造函数。在这个函数内部，首先创建了一个数组，然后使用<code>push()</code>方法（用构造函数接收到的所有参数）初始化了数组的值。随后，又给数组实例添加了一个<code>toPipedString()</code>方法，该方法返回以竖线分割的数组值。最后，将数组以函数值的形式返回。接着，我们调用了<code>SpecialArray</code> 构造函数，向其中传入了用于初始化数组的值，此后又调用了<code>toPipedString()</code>方法。</p>
<p><strong>！关于寄生构造函数模式，首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖<code>instanceof</code> 操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</strong></p>
<h1 id="八、稳妥构造函数模式"><a href="#八、稳妥构造函数模式" class="headerlink" title="八、稳妥构造函数模式"></a>八、稳妥构造函数模式</h1><p>所谓<strong>稳妥对象（durable objects）</strong>，指的是没有公共属性，而且其方法也不引用<code>this</code> 的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用<code>this</code> 和<code>new</code>），或者在防止数据被其他应用程序（如<code>Mashup</code>程序）改动时使用。<br>稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用<code>this</code>；二是不使用<code>new</code> 操作符调用构造函数。<br>按照稳妥构造函数的要求，可以将前面的  Person   构造函数重写如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//创建要返回的对象</span></span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//可以在这里定义私有变量和函数</span></span><br><span class="line">    <span class="comment">//添加方法</span></span><br><span class="line">    o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(name);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回对象</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> friend = Person(<span class="string">"Hal"</span>, <span class="number">24</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line">friend.sayName(); <span class="comment">//"Hal"</span></span><br></pre></td></tr></table></figure>

<p>在以这种模式创建的对象中，除了使用<code>sayName()</code>方法之外，没有其他办法访问<code>name</code> 的值。变量<code>friend</code> 中保存的是一个稳妥对象，而除了调用<code>sayName()</code>方法外，没有别的方式可以访问其数据成员。即使有其他代码会给这个对象添加方法或数据成员，但也不可能有别的办法访问传入到构造函数中的原始数据。</p>
<p><strong>！与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof 操作符对这种对象也没有意义。</strong></p>
<h1 id="九、总结"><a href="#九、总结" class="headerlink" title="九、总结"></a>九、总结</h1><p><code>ECMAScript</code>支持面向对象（OO）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象：</p>
<ul>
<li><p>工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。</p>
</li>
<li><p>构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new 操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散耦合的特点），因此没有理由不在多个对象间共享函数。</p>
</li>
<li><p>原型模式，使用构造函数的prototype 属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 创建对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript继承的几种方式</title>
    <url>/2020/01/12/JavaScript%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>许多OO（面向对象） 语言都支持两种继承方式：<strong>接口继承</strong>和<strong>实现继承</strong>。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMAScript 中无法实现接口继承。所以ECMAScript 只支持实现继承，而且其主要是依靠原型链来实现继承。下面是几种JavaScript的继承方式。</p>
<h1 id="二、原型链实现继承"><a href="#二、原型链实现继承" class="headerlink" title="二、原型链实现继承"></a>二、原型链实现继承</h1><p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。<strong>具体操作就是让子类型的原型等于父类型的实例</strong>，然后此时的原型对象将包含一个指向另一个原型的指针，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是原型链的基本概念。具体实现如下：</p>
<a id="more"></a>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子类的原型等于父类的实例，继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，搜索过程就是沿着原型链向上查找，调用<code>instance.getSuperValue()</code>会经历三个搜索步骤：</p>
<ul>
<li>1.搜索实例</li>
<li>2.搜索<code>SubType.prototype</code></li>
<li>3.搜索<code>SuperType.prototype</code>，最后一步才会找到该方法。在找不到属性或方法的情况下，搜索到原型链末端才会停下来。</li>
</ul>
<h3 id="确定原型和实例的关系"><a href="#确定原型和实例的关系" class="headerlink" title="确定原型和实例的关系"></a>确定原型和实例的关系</h3><p>可以通过两种方式来确定原型和实例之间的关系：</p>
<ul>
<li><code>instanceof</code>操作符</li>
<li><code>isPrototypeOf()</code></li>
</ul>
<p>第一种方式是使用<code>instanceof</code> 操作符，只要用这个操作符来测试实例与原型链中出现过的构造函数，结果就会返回<code>true</code>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType); <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>第二种方式是使用<code>isPrototypeOf()</code>方法。只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此<code>isPrototypeOf()</code>方法也会返回true：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">alert(<span class="name">Object</span>.prototype.isPrototypeOf(<span class="name">instance</span>))<span class="comment">; //true</span></span><br><span class="line">alert(<span class="name">SuperType</span>.prototype.isPrototypeOf(<span class="name">instance</span>))<span class="comment">; //true</span></span><br><span class="line">alert(<span class="name">SubType</span>.prototype.isPrototypeOf(<span class="name">instance</span>))<span class="comment">; //true</span></span><br></pre></td></tr></table></figure>

<p><strong>！所有引用类型默认都继承了<code>Object</code>对象，而这个继承也是通过原型链实现的。所有函数的默认原型都是<code>Object</code> 的实例，因此默认原型都会包含一个内部指针，指向<code>Object.prototype</code>。这也正是所有自定义类型都会继承<code>toString()</code>、<code>valueOf()</code>等默认方法的根本原因。</strong></p>
<p><strong>！子类型有时候需要重写超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但是原型添加方法的代码一定要放在替换原型的语句之后，不然会被覆盖。</strong></p>
<p><strong>！在通过原型链实现继承时，不能使用对象字面量创建原型方法，因为这样做就会重写原型链。</strong></p>
<p>如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承了SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用字面量添加新方法，会导致上一行代码无效</span></span><br><span class="line">SubType.prototype = &#123;</span><br><span class="line">    getSubValue : <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;,</span><br><span class="line">someOtherMethod : <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue()); <span class="comment">//error!</span></span><br></pre></td></tr></table></figure>

<h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li><strong>包含引用类型值的原型</strong>，包含引用类型值的原型属性会被所有实例共享，所以要在构造函数中定义属性，而不是在原型对象中</li>
<li>在创建子类型的实例时，<strong>不能向超类型的构造函数中传递参数</strong>，应该说是没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数</li>
</ul>
<p><strong>！由于上面两个原因的问题，实践中很少会单独使用原型链。</strong></p>
<h1 id="三、通过构造函数实现继承"><a href="#三、通过构造函数实现继承" class="headerlink" title="三、通过构造函数实现继承"></a>三、通过构造函数实现继承</h1><p>在解决原型中包含引用类型值所带来问题的过程中，使用一种叫做借用构造函数<strong>（constructor stealing）</strong>的技术（有时候也叫做<strong>伪造对象</strong>或<strong>经典继承</strong>）。这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，可以使用<code>apply()</code>和<code>call()</code>方法也可以在（将来）新创建的对象上执行构造函数。<br>示例如下：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br></pre></td></tr></table></figure>

<p>通过使用<code>call()</code>（或<code>apply()</code>），在新创建的<code>SubType</code> 实例的环境下调用了<code>SuperType</code> 构造函数。这样一来，就会在新<code>SubType</code> 对象上执行<code>SuperType()</code>函数中定义的所有对象初始化代码。结果，<code>SubType</code> 的每个实例就都会具有自己的<code>colors</code> 属性的副本了。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><p>相对于原型链而言，借用构造函数有一个很大的优势，即可以在子类型构造函数中向超类型构造函数传递参数。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承了SuperType，同时还传递了参数</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">    <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name); <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age); <span class="comment">//29</span></span><br></pre></td></tr></table></figure>

<p>为了确保<code>SuperType</code> 构造函数不会重写子类型的属性，应该在调用超类型构造函数后，再添加应该在子类型中定义的属性。</p>
<h3 id="存在的问题-1"><a href="#存在的问题-1" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul>
<li>无法避免构造函数模式存在的问题——方法都在构造函数中定义，因此函数复用就毫无意义了，在超类型的原型中定义的方法，对子类型而言也是不可见的，结果所有类型都只能使用构造函数模式，所以借用构造函数的技术也是很少单独使用的。</li>
</ul>
<h1 id="四、组合继承"><a href="#四、组合继承" class="headerlink" title="四、组合继承"></a>四、组合继承</h1><p><strong>组合继承（combination inheritance）</strong>，有时候也叫做<strong>伪经典继承</strong>，指的是将原型链和借用构造函数的技术组合到一块，从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又能够保证每个实例都有它自己的属性。<br>例子：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span></span>&#123;</span><br><span class="line">    <span class="comment">//继承属性</span></span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，使用了构造函数继承了父类型的属性，原型链继承了父类型的方法，然后两个不同<code>SubType</code>实例既分别拥有自己属性——包括<code>colors</code> 属性，又可以使用相同的方法。<br>组合继承避免了原型链和借用构造函数的缺陷，融合了它们的优点，<strong>成为JavaScript 中最常用的继承模式</strong>。而且，<code>instanceof</code> 和<code>isPrototypeOf()</code>也能够用于识别基于组合继承创建的对象。</p>
<h1 id="五、原型式继承"><a href="#五、原型式继承" class="headerlink" title="五、原型式继承"></a>五、原型式继承</h1><p>道格拉斯·克罗克福德在2006 年写了一篇文章，题为Prototypal Inheritance in JavaScript （JavaScript中的原型式继承）。在这篇文章中，他介绍了一种实现继承的方法，这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象，同时还不必因此创建自定义类型。为了达到这个目的，他给出了如下函数：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    F.prototype = o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>object()</code>函数内部，先创建了一个临时性的构造函数，然后将传入的对象作为这个构造函数的原型，最后返回了这个临时类型的一个新实例。从本质上讲，<code>object()</code>对传入其中的对象执行了一次浅复制。来看下面的例子：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="symbol">    friends:</span> [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var anotherPerson = object(person)<span class="comment">;</span></span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span><span class="comment">;</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = object(person)<span class="comment">;</span></span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span><span class="comment">;</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>)<span class="comment">;</span></span><br><span class="line">alert(person.friends)<span class="comment">; //"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>

<p>克罗克福德主张的这种原型式继承，要求你必须有一个对象可以作为另一个对象的基础。如果有这么一个对象的话，可以把它传递给object()函数，然后再根据具体需求对得到的对象加以修改即可。</p>
<p>ECMAScript 5 通过新增<code>Object.create()</code>方法规范化了原型式继承。这个方法接收两个参数：一个用作新对象原型的对象和（可选的）一个为新对象定义额外属性的对象。在传入一个参数的情况下，<code>Object.create()</code>与<code>object()</code>方法的行为相同。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="symbol">    friends:</span> [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var anotherPerson = Object.create(person)<span class="comment">;</span></span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span><span class="comment">;</span></span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">var yetAnotherPerson = Object.create(person)<span class="comment">;</span></span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span><span class="comment">;</span></span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>)<span class="comment">;</span></span><br><span class="line">alert(person.friends)<span class="comment">; //"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code>方法的第二个参数与<code>Object.defineProperties()</code>方法的第二个参数格式相同：每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。例如：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line"><span class="symbol">    name:</span> <span class="string">"Nicholas"</span>,</span><br><span class="line"><span class="symbol">    friends:</span> [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line">var anotherPerson = Object.create(person, &#123;</span><br><span class="line"><span class="symbol">        name:</span> &#123;</span><br><span class="line"><span class="symbol">        value:</span> <span class="string">"Greg"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure>

<h1 id="六、寄生式继承"><a href="#六、寄生式继承" class="headerlink" title="六、寄生式继承"></a>六、寄生式继承</h1><p>寄生式（parasitic）继承是与原型式继承紧密相关的一种思路，寄生式继承的思路与寄生构造函数和工厂模式类似，即创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。例如：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">clone</span> = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">    <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123; <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">        alert(<span class="string">"hi"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">clone</span>; <span class="comment">//返回这个对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Nicholas"</span>,</span><br><span class="line">    friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> anotherPerson = createAnother(person);</span><br><span class="line">anotherPerson.sayHi(); <span class="comment">//"hi"</span></span><br></pre></td></tr></table></figure>

<p><code>createAnother()</code>函数接收了一个参数，也就是将要作为新对象基础的对象。然后，把这个对象<code>original</code>传递给<code>object()</code>函数，将返回的结果赋值给<code>clone</code>。再为<code>clone</code> 对象添加一个新方法<code>sayHi()</code>，最后返回<code>clone</code> 对象。在主要考虑对象而不是自定义类型和构造函数的情况下，寄生式继承也是一种有用的模式。前面示范继承模式时使用的<code>object()</code>函数不是必需的；任何能够返回新对象的函数都适用于此模式。</p>
<h1 id="七、寄生组合式继承"><a href="#七、寄生组合式继承" class="headerlink" title="七、寄生组合式继承"></a>七、寄生组合式继承</h1><p>前面说组合继承是JavaScript 最常用的继承模式，但是其也有不足之处，组合继承最大的问题就是其在任何情况下都会调用两次次超类型构造函数，一次是在创建子类型原型的时候，另一次是在子类型构造函数内部。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span></span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);<span class="comment">//第二次调用SuperType()</span></span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();<span class="comment">//第一次调用SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>会出现两组<code>name</code> 和<code>colors</code> 属性：一组在实例上，一组在<code>SubType</code> 原型中。这就是调用两次<code>SuperType</code> 构造函数的结果，解决这个问题方法就是使用寄生组合式继承。</p>
<p>所谓<strong>寄生组合式继承</strong>，即通过借用构造函数来继承属性，通过原型链的混成形式来继承方法。其背后的基本思路是：不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型原型的一个副本而已。本质上，就是使用寄生式继承来继承超类型的原型，然后再将结果指定给子类型的原型。寄生组合式继承的基本模式如下所示：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span><span class="params">(subType, superType)</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">    prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">    subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例中的<code>inheritPrototype()</code>函数实现了寄生组合式继承的最简单形式。这个函数接收两个参数：子类型构造函数和超类型构造函数。在函数内部，第一步是创建超类型原型的一个副本。第二步是为创建的副本添加<code>constructor</code> 属性，从而弥补因重写原型而失去的默认的<code>constructor</code> 属性。最后一步，将新创建的对象（即副本）赋值给子类型的原型。这样，我们就可以用调用<code>inheritPrototype()</code>函数的语句，去替换前面例子中为子类型原型赋值的语句了，例如：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span></span>&#123;</span><br><span class="line">    SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子的高效率体现在它只调用了一次<code>SuperType</code> 构造函数，并且因此避免了在<code>SubType.prototype</code>上面创建不必要的、多余的属性。与此同时，原型链还能保持不变；因此，还能够正常使用<code>instanceof</code> 和<code>isPrototypeOf()</code>。开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式。</p>
<h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p><code>JavaScript</code> 主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是<strong>对象实例共享所有继承的属性和方法，因此不适宜单独使用</strong>。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。</p>
<p>此外，还存在下列可供选择的继承模式：</p>
<ul>
<li>原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</li>
<li>寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。</li>
<li>寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 继承</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04安装Chrome</title>
    <url>/2020/01/11/Ubuntu18.04%E5%AE%89%E8%A3%85Chrome/</url>
    <content><![CDATA[<h1 id="一、将下载源加入到系统的源列表"><a href="#一、将下载源加入到系统的源列表" class="headerlink" title="一、将下载源加入到系统的源列表"></a>一、将下载源加入到系统的源列表</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">sudo wget https:<span class="regexp">//</span>repo.fdzh.org<span class="regexp">/chrome/g</span>oogle-chrome.list -P <span class="regexp">/etc/</span>apt<span class="regexp">/sources.list.d/</span></span><br></pre></td></tr></table></figure>

<h1 id="二、导入谷歌软件的公钥，用于对下载软件进行验证。"><a href="#二、导入谷歌软件的公钥，用于对下载软件进行验证。" class="headerlink" title="二、导入谷歌软件的公钥，用于对下载软件进行验证。"></a>二、导入谷歌软件的公钥，用于对下载软件进行验证。</h1><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">wget -q -O - http<span class="variable">s:</span>//<span class="keyword">dl</span>.google.<span class="keyword">com</span>/linux/linux_signing_key.pub  | sudo apt-key <span class="built_in">add</span> -</span><br></pre></td></tr></table></figure>

<h1 id="三、用于对当前系统的可用更新列表进行更新"><a href="#三、用于对当前系统的可用更新列表进行更新" class="headerlink" title="三、用于对当前系统的可用更新列表进行更新"></a>三、用于对当前系统的可用更新列表进行更新</h1><figure class="highlight q"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br></pre></td></tr></table></figure>

<h1 id="四、安装Chrome（稳定版）"><a href="#四、安装Chrome（稳定版）" class="headerlink" title="四、安装Chrome（稳定版）"></a>四、安装Chrome（稳定版）</h1><figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">sudo apt-<span class="builtin-name">get</span> install google-chrome-stable</span><br></pre></td></tr></table></figure>

<h1 id="五、启动Chrome"><a href="#五、启动Chrome" class="headerlink" title="五、启动Chrome"></a>五、启动Chrome</h1><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/google-chrome-stable</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu18.04 Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的会Git吗？记一些实用命令</title>
    <url>/2020/01/04/%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BC%9AGit%E5%90%97%EF%BC%9F%E8%AE%B0%E4%B8%80%E4%BA%9B%E5%AE%9E%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前几天看到阮一峰老师博客上面分享了一篇<a href="http://www.ruanyifeng.com/blog/2019/12/git-undo.html" target="_blank" rel="noopener">如何撤销 Git 操作？</a>的文章，读完之后不禁感叹自己真是个弱鸡，扪心自问，自己真的会<code>Git</code>吗？日常工作中的常用的基本命令倒是会几个，但是真的遇到点问题又要搞好久，现场搜索解决方案，着实会耽误些时间，导致自己的开发效率被拉低。自我反思之后，发现还是自己学艺不精，还需多下功夫，<code>工欲善其事，必先利其器</code>。在开发工具的使用方面还得下些功夫，所以，在此记录一些非常有用的提高效率的<code>Git</code>命令。</p>
<h1 id="二、几个概念"><a href="#二、几个概念" class="headerlink" title="二、几个概念"></a>二、几个概念</h1><ul>
<li><code>HEAD</code>: 就是指向当前版本的指针。</li>
<li><code>Index</code>: <code>Index</code>为暂存区，当你修改某一个文件时，这个文件一开始是<code>unstaged</code>状态，使用<code>git add</code>命令把它加入到<code>Index</code>暂存区后，该文件变成了<code>staged</code>状态。然后执行<code>git commit</code>后，<code>Index</code>里面的修改被提交到本地版本库。</li>
<li><code>working tree</code>: 当前的工作目录。</li>
</ul>
<a id="more"></a>

<h1 id="三、具体命令"><a href="#三、具体命令" class="headerlink" title="三、具体命令"></a>三、具体命令</h1><h3 id="撤销git-add"><a href="#撤销git-add" class="headerlink" title="撤销git add ."></a>撤销<code>git add .</code></h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">reset</span> <span class="keyword">HEAD</span></span><br></pre></td></tr></table></figure>

<p>上面命令用来撤销错误<code>add</code>的代码，比如我不小心执行了个<code>git add .</code>，把当前所有的代码都添加到了缓冲区，到了<code>stage</code>阶段，但是还没<code>commit</code>，就可以用上面的命令来撤销<code>add</code>。</p>
<h3 id="撤销git-commit-m"><a href="#撤销git-commit-m" class="headerlink" title="撤销git commit -m"></a>撤销<code>git commit -m</code></h3><p>如果执行过了<code>commit</code>，突然发现有不想要提交的代码，那现在怎么办呢？这个时候可以执行下面命令来撤销<code>commit</code>：</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">git</span> <span class="keyword">revert </span>HEAD</span><br></pre></td></tr></table></figure>

<p>上面命令以一次新的提交覆盖上一次的提交内容，不会改变错误提交之前的内容，但是亲测之后发现错误提交的内容会丢失掉。但是有很多时候我们只是想修改其中的部分错误，而不是丢弃整个修改。</p>
<p>所以可以使用如下方法恢复之前的修改内容并再次修改，首先使用<code>git reflog</code>查看提交的历史，提取所需版本的版本号，然后执行<code>git reset 428713b</code>，后面是具体需要恢复的版本号即可，然后再在其上修改并且重新提交。</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e894f7e (HEAD -&gt; master) HEAD@&#123;0&#125;: revert: Revert <span class="string">"test git"</span></span><br><span class="line"><span class="number">428713</span>b HEAD@&#123;1&#125;: <span class="keyword">reset</span>: moving to HEAD</span><br><span class="line"><span class="number">428713</span>b HEAD@&#123;2&#125;: commit: test git</span><br><span class="line"><span class="number">7395</span>b28 (origin/master) HEAD@&#123;3&#125;: commit: Add some conponents.</span><br><span class="line"><span class="number">6</span>b1503b HEAD@&#123;4&#125;: commit (merge): First commit</span><br><span class="line">f00f39f HEAD@&#123;5&#125;: commit (initial): First commit</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="number">428713</span>b</span><br><span class="line">Unstaged changes <span class="keyword">after</span> <span class="keyword">reset</span>:</span><br><span class="line">M       src/pages/Cart.vue</span><br></pre></td></tr></table></figure>

<p><code>git revert</code>还有两个参数：</p>
<ul>
<li>–no-edit：执行时不打开默认编辑器，使用默认生成的信息，这个参数可以节省每次关闭<code>vi</code>编辑器的时间，因为从我的个人经验来说，基本上每次打开编辑器都只是执行一个关闭命令，而没有再次更改其中的信息。</li>
<li>–no-commit：只抵消暂存区和工作区的文件变化，不产生新的提交。</li>
</ul>
<p><code>git reset</code>的用法：</p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><span class="line">git reset <span class="meta">[&lt;mode&gt;]</span> <span class="meta">[&lt;commit&gt;]</span></span><br></pre></td></tr></table></figure>

<p><code>git reset</code> 将当前分支的<code>HEAD</code>指向给定的版本，并根据模式决定是否修改<code>Index</code>和<code>working tree</code>。<br>常用的<code>&lt;mode&gt;</code>有三种，<code>--soft</code>，<code>--mixed</code>， <code>--hard</code>，默认是<code>--mixed</code>。</p>
<ul>
<li><code>--soft</code> 只会重置HEAD到对应的版本，不会修改<code>Index</code>和<code>working tree</code>。</li>
<li><code>--mixed</code> 会修改<code>Index</code>暂存区，上面的<code>$ git reset 428713b</code>命令就相当于<code>$ git reset --mixed 428713b</code></li>
<li><code>--hard</code> 会让暂存区及工作区里面的文件都回到以前的状态，一般不太推荐使用，可能会导致某一次提交彻底消失，且用且珍惜。</li>
</ul>
<p>执行<code>git reset</code>命令之后，如果想找回那些丢弃掉的提交，可以使用<code>git reflog</code>命令，这种做法有时效性，时间长了可能找不回来。</p>
<h3 id="替换上次提交git-commit-amend-m"><a href="#替换上次提交git-commit-amend-m" class="headerlink" title="替换上次提交git commit --amend -m"></a>替换上次提交<code>git commit --amend -m</code></h3><p>如果某次<code>git commit</code>的信息填写错误，可以使用<code>git commit --amend -m</code>来替换上次的提交信息，不单单是替换提交信息，这个命令的原理是用一次新的提交来替换上一次提交，如果此时内容有修改的话，也会被提交上去。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">commit</span> <span class="comment">--amend -m 'test amend'</span></span><br><span class="line">[<span class="keyword">master</span> <span class="number">1e5</span>ed2d] <span class="keyword">test</span> amend</span><br><span class="line"> <span class="built_in">Date</span>: Sun Jan <span class="number">5</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">11</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> <span class="keyword">changed</span>, <span class="number">1</span> insertion(+), <span class="number">1</span> deletion(-)</span><br></pre></td></tr></table></figure>

<p>执行上面命令之后，使用<code>git log</code>查看提交历史，发现最新的一次提交信息已经改变了：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line"><span class="keyword">commit</span> <span class="number">1e5</span>ed2d5bf99f7223efd13b726354e35c695fae6 (<span class="keyword">HEAD</span> -&gt; <span class="keyword">master</span>)</span><br><span class="line">Author: xiaohao &lt;xiaohaogreat@qq.com&gt;</span><br><span class="line"><span class="built_in">Date</span>:   Sun Jan <span class="number">5</span> <span class="number">10</span>:<span class="number">29</span>:<span class="number">11</span> <span class="number">2020</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">test</span> amend</span><br></pre></td></tr></table></figure>

<h3 id="从暂存区撤销文件"><a href="#从暂存区撤销文件" class="headerlink" title="从暂存区撤销文件"></a>从暂存区撤销文件</h3><p>如果不小心<code>git add .</code>把所有文件都加入到了暂存区，可以使用下面的命令来从暂存区删除不想要的文件。</p>
<figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">git rm --cached <span class="string">[filename]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git rm --cached src/pages/Cart.vue</span><br><span class="line">rm <span class="string">'src/pages/Cart.vue'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="symbol">'origin</span>/master' by <span class="number">3</span> commits.</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git push"</span> <span class="keyword">to</span> publish your local commits)</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git restore --staged &lt;file&gt;..."</span> <span class="keyword">to</span> unstage)</span><br><span class="line">        deleted:    src/pages/Cart.vue</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        src/pages/Cart.vue</span><br></pre></td></tr></table></figure>

<h3 id="暂存管理-git-stash"><a href="#暂存管理-git-stash" class="headerlink" title="暂存管理 git stash"></a>暂存管理 <code>git stash</code></h3><p>假如你正在某个分支上开发，但此时有比较紧急的任务需要在同一分支上进行修改，然而你又不想两边内容混在一起，此时这个命令就很有用了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of 'origin/master' by 4 commits.</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git push"</span> <span class="keyword">to</span> publish your <span class="keyword">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git restore &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line">        modified:   src/pages/Cart.vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br><span class="line"></span><br><span class="line">$ git  stash</span><br><span class="line">Saved working <span class="keyword">directory</span> <span class="keyword">and</span> <span class="keyword">index</span> state WIP <span class="keyword">on</span> <span class="keyword">master</span>: <span class="number">5</span>f34131 <span class="keyword">test</span> checkout</span><br><span class="line"></span><br><span class="line">$ git <span class="keyword">status</span></span><br><span class="line"><span class="keyword">On</span> branch <span class="keyword">master</span></span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="string">'origin/master'</span> <span class="keyword">by</span> <span class="number">4</span> commits.</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git push"</span> <span class="keyword">to</span> publish your <span class="keyword">local</span> commits)</span><br><span class="line"></span><br><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure>

<p><code>git stash</code>可以把你当前的工作区里的内容放在缓存区里面进行保管，执行了<code>git stash</code>之后，工作区就是干净的了，可以进行新的修改，而两次的修改就不至于混在一起了。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git stash <span class="built_in">list</span></span><br><span class="line">stash@&#123;<span class="number">0</span>&#125;: WIP <span class="keyword">on</span> master: <span class="number">5</span>f34131 test checkout</span><br></pre></td></tr></table></figure>

<p><code>git stash list</code>可以查看当前缓存起来的列表。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$ git stash apply</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of 'origin/master' by 4 commits.</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git push"</span> <span class="keyword">to</span> publish your <span class="keyword">local</span> commits)</span><br><span class="line"></span><br><span class="line">Changes <span class="keyword">not</span> staged <span class="keyword">for</span> <span class="keyword">commit</span>:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git add &lt;file&gt;..."</span> <span class="keyword">to</span> <span class="keyword">update</span> what will be committed)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">"git restore &lt;file&gt;..."</span> <span class="keyword">to</span> discard changes <span class="keyword">in</span> working <span class="keyword">directory</span>)</span><br><span class="line">        modified:   src/pages/Cart.vue</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added <span class="keyword">to</span> <span class="keyword">commit</span> (<span class="keyword">use</span> <span class="string">"git add"</span> <span class="keyword">and</span>/<span class="keyword">or</span> <span class="string">"git commit -a"</span>)</span><br></pre></td></tr></table></figure>

<p><code>git stash apply</code>可以恢复当前缓存起来的修改。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git stash drop</span><br><span class="line">Dropped refs/stash@&#123;<span class="number">0</span>&#125; (aba8ef350840e0bf63528eebc6e375b9f326afa1)</span><br><span class="line"></span><br><span class="line"><span class="symbol">$</span> git stash list</span><br><span class="line"><span class="comment">// 没有内容</span></span><br></pre></td></tr></table></figure>

<p><code>git stash drop</code>可以删除当前缓存区内的暂存修改。</p>
<h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><p><a href="http://www.ruanyifeng.com/blog/2019/12/git-undo.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2019/12/git-undo.html</a><br><a href="https://www.jianshu.com/p/c6927e80a01d" target="_blank" rel="noopener">https://www.jianshu.com/p/c6927e80a01d</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git 命令</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP缓存机制之强缓存和协商缓存区别与联系</title>
    <url>/2019/12/22/HTTP%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%BC%BA%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98%E5%8C%BA%E5%88%AB%E4%B8%8E%E8%81%94%E7%B3%BB/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>HTTP缓存在前端开发过程中有着举足轻重的地位，因为其在性能优化的过程中必不可少，许多不太常变的资源可以缓存在浏览器端，无需每次都发起请求重新获取，好的缓存策略可以大大提高网站加载及渲染效率。</p>
<h1 id="二、强缓存"><a href="#二、强缓存" class="headerlink" title="二、强缓存"></a>二、强缓存</h1><p>强缓存有<code>Expires</code>和<code>Cache-Control</code>两种响应头方式实现。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p><code>Expires</code>是<code>HTTP1.0</code>提出的一个表示资源过期时间的请求头，它描述的是一个绝对时间，由服务器返回。<br>Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，而且由于本地时间与服务器时间可能存在误差，可能会存在问题，其值如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">Expires</span>: <span class="selector-tag">Thu</span>, 14 <span class="selector-tag">Mar</span> 2019 17<span class="selector-pseudo">:29</span><span class="selector-pseudo">:17</span> <span class="selector-tag">GMT</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><ul>
<li>public：指示响应可被任何缓存区缓存，如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。</li>
<li>private：指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>
<li>no-cache：表示必须先与服务器确认返回的响应是否被更改，然后才能使用该响应来满足后续对同一个网址的请求。因此，如果存在合适的验证令牌 (ETag)，no-cache 会发起往返通信来验证缓存的响应，如果资源未被更改，可以避免下载。</li>
<li>no-store：用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。禁止缓存任何响应，也就是说每次用户请求资源时，都会向服务器发送一个请求，每次都会下载完整的响应。</li>
<li>max-age：用来设置资源被缓存的最长时间(单位是秒)。指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>
<li>min-fresh：指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>
<li>max-stale：指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>
</ul>
<h4 id="no-cache-和-no-store的区别："><a href="#no-cache-和-no-store的区别：" class="headerlink" title="no-cache 和 no-store的区别："></a><code>no-cache</code> 和 <code>no-store</code>的区别：</h4><p><code>no-cache</code>标记的资源是可以存储在本地缓存中的，但是在与原始服务器进行新鲜度验证之前，缓存不能将其提供给客户端使用。<code>no-store</code>是不允许缓存任何响应。</p>
<h3 id="Cache-Control优先级高于Expires。"><a href="#Cache-Control优先级高于Expires。" class="headerlink" title="Cache-Control优先级高于Expires。"></a><code>Cache-Control</code>优先级高于<code>Expires</code>。</h3><h1 id="三、协商缓存"><a href="#三、协商缓存" class="headerlink" title="三、协商缓存"></a>三、协商缓存</h1><p>当某个请求没有命中强缓存时，就会发起一个请求到服务器端验证协商缓存是否命中，如果命中，由服务器端来决定是否使用该缓存，若该缓存未过期且未被修改，请求响应就会返回一个304状态码为然后显示<code>Not Modified</code>。</p>
<p>协商缓存使用的是<code>Last-Modified &amp; If-Modified-Since</code>和<code>ETag &amp; If-None-Match</code>这两对Header。</p>
<h3 id="Last-Modified和If-Modified-Since"><a href="#Last-Modified和If-Modified-Since" class="headerlink" title="Last-Modified和If-Modified-Since"></a>Last-Modified和If-Modified-Since</h3><p><code>Last-Modified</code>是指服务器端文件的最后修改时间，需要和 <code>cache-control</code> 配合使用，是检查服务器端资源是否更新的一种方式。当浏览器再次进行请求时，会向服务器传送<code>If-Modified-Since</code>请求头，询问 <code>Last-Modified</code> 时间点之后资源是否被修改过。如果没有修改，则返回码为 304，使用浏览器端缓存；如果修改过，则再次去服务器请求资源，状态码和首次请求相同为 200，使用服务器最新资源。</p>
<h3 id="ETag和If-None-Match"><a href="#ETag和If-None-Match" class="headerlink" title="ETag和If-None-Match"></a>ETag和If-None-Match</h3><p><code>Etag &amp; If-None-Match</code> 与 <code>Last-Modified &amp; If-Modified-Since</code> 的机制类似，不同的是，<code>Etag</code>是通过一个校验码来对比资源是否更改过的，而不是通过资源的修改时间。当一个资源修改时，其校验码也会更改。<code>Etag</code>就像一个唯一指纹，资源变化都会导致·ETag·变化，跟最后修改时间没有关系，<code>ETag</code>可以保证每一个资源是唯一的。当浏览器请求资源时，服务器会返回一个<code>Etag</code>字段，然后浏览器下一次请求时，会带上 <code>If-None-Match</code> ，值为上次服务器返回的<code>Etag</code>的值，服务器经过校验码的对比后决定返回200或304。</p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>Etag</code>可以解决 <code>Last-Modified</code> 不太好处理的问题，<code>Etag</code>能更准确地控制缓存，因此，<code>Etag</code>的优先级是高于 <code>Last-Modified</code> 。<br><code>Last-Modified</code> 可能会有以下一些问题，但是<code>Etag</code>可以很好地解决的：</p>
<ul>
<li>一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，所以这个时候会被识别为修改过了而重新发起请求。</li>
<li>某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，<code>If-Modified-Since</code>能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)。</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
</ul>
<h1 id="四、完整的缓存策略过程"><a href="#四、完整的缓存策略过程" class="headerlink" title="四、完整的缓存策略过程"></a>四、完整的缓存策略过程</h1><p><img src="https://upload-images.jianshu.io/upload_images/1741029-4fc0e06fc0f1f4e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="缓存过程"></p>
<h1 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h1><p><a href="https://github.com/amandakelake/blog/issues/41" target="_blank" rel="noopener">https://github.com/amandakelake/blog/issues/41</a><br><a href="http://www.alloyteam.com/2016/03/discussion-on-web-caching/#prettyPhoto" target="_blank" rel="noopener">http://www.alloyteam.com/2016/03/discussion-on-web-caching/#prettyPhoto</a><br><a href="https://www.jianshu.com/p/c78b5de7a889" target="_blank" rel="noopener">https://www.jianshu.com/p/c78b5de7a889</a></p>
]]></content>
      <categories>
        <category>HTTP缓存机制</category>
      </categories>
      <tags>
        <tag>HTTP 强缓存 协商缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>原生Javascript实现Base64编解码和兼容性问题处理</title>
    <url>/2019/12/21/%E5%8E%9F%E7%94%9FJavascript%E5%AE%9E%E7%8E%B0Base64%E7%BC%96%E8%A7%A3%E7%A0%81%E5%92%8C%E5%85%BC%E5%AE%B9%E6%80%A7%E9%97%AE%E9%A2%98%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>前几天因工作需要，需要在<code>URL</code>上面传递一段参数，参数内容有点多，所以需要在前端实现<code>Base64</code>编码参数，然后进行传递，在下一页面再进行解码获取参数。之前也没有相关经验，之前参数多的时候都是放在<code>Parameters</code>里面的，所以一开始也不知道如何下手，网上一番捣鼓之后，找到了如下两个函数可以实现相关功能：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa() <span class="comment">// 实现base64编码</span></span><br><span class="line"><span class="built_in">window</span>.atob() <span class="comment">// 实现base64解码</span></span><br></pre></td></tr></table></figure>

<p>下面来记录下这两个函数相关的用法及其中的坑。</p>
<h1 id="二、具体用法与坑"><a href="#二、具体用法与坑" class="headerlink" title="二、具体用法与坑"></a>二、具体用法与坑</h1><h3 id="window-btoa"><a href="#window-btoa" class="headerlink" title="window.btoa()"></a>window.btoa()</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">window.btoa(<span class="string">"test encode"</span>)</span><br><span class="line"><span class="regexp">//</span> <span class="string">"dGVzdCBlbmNvZGU="</span></span><br></pre></td></tr></table></figure>

<h3 id="window-atob"><a href="#window-atob" class="headerlink" title="window.atob()"></a>window.atob()</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">window.atob(<span class="string">"dGVzdCBlbmNvZGU="</span>)</span><br><span class="line"><span class="regexp">//</span> <span class="string">"test encode"</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>以上结果简单明了，就是使用<code>window.btoa()</code>函数先进行编码，然后使用<code>window.atob()</code>进行解码，貌似一切正常，万事大吉，完事了。<br>但是，真要这么想就完蛋了，<code>too young too naive</code>，坑还在后面呢，来看下面的例子：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">window.btoa(<span class="string">"测试编码"</span>)</span><br><span class="line">/* VM898:1 Uncaught DOMException: Failed to<span class="built_in"> execute </span>'btoa' on 'Window': </span><br><span class="line">The string to be encoded contains characters outside of the Latin1 range. */</span><br></pre></td></tr></table></figure>

<figure class="highlight smali"><table><tr><td class="code"><pre><span class="line">window.atob(<span class="string">"测试编码"</span>)</span><br><span class="line">/* Uncaught DOMException: Failed to<span class="built_in"> execute </span>'atob' on 'Window': </span><br><span class="line">The string to be decoded contains characters outside of the Latin1 range.*/</span><br></pre></td></tr></table></figure>

<p>二者当中只要出现了中文，就会抛错，因为其不支持中文进行<code>base64</code>编码，小白的我一脸懵逼，但是，这怎么能难倒我呢，接着又是一顿猛搜，最终找到了解决方案，方法也很简单，就是在编码处理中文之前使用<code>encodeURIComponent</code>函数先套一层，然后在解码的时候外面套一层<code>decodeURIComponent</code>即可：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.btoa(<span class="built_in">encodeURIComponent</span>(<span class="string">"测试编码"</span>))</span><br><span class="line"><span class="comment">// "JUU2JUI1JThCJUU4JUFGJTk1JUU3JUJDJTk2JUU3JUEwJTgx"</span></span><br></pre></td></tr></table></figure>

<p>window.btoa(“测试编码”)</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">decodeURIComponent(<span class="name">window</span>.atob(<span class="string">"JUU2JUI1JThCJUU4JUFGJTk1JUU3JUJDJTk2JUU3JUEwJTgx"</span>))</span><br><span class="line">// <span class="string">"测试编码"</span></span><br></pre></td></tr></table></figure>

<h1 id="三、延伸，任意文件转Base64"><a href="#三、延伸，任意文件转Base64" class="headerlink" title="三、延伸，任意文件转Base64"></a>三、延伸，任意文件转Base64</h1><p>使用<code>FileReader</code>对象和<code>readAsDataURL</code>方法，可以把任意的文件（SVG、小尺寸图片、Woff字体等等）转换为<code>Base64 Data-URI</code>，转换的代码如下：</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">var reader = new FileReader();</span><br><span class="line">reader.onload = <span class="function"><span class="keyword">function</span><span class="params">(e)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(e.<span class="keyword">target</span>.result); // e.<span class="keyword">target</span>.result就是该文件的完整Base64 <span class="keyword">Data</span>-URI</span><br><span class="line">&#125;;</span><br><span class="line">reader.readAsDataURL(<span class="keyword">file</span>);</span><br></pre></td></tr></table></figure>

<h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><p><a href="https://www.zhangxinxu.com/wordpress/2018/08/js-base64-atob-btoa-encode-decode/?from=groupmessage" target="_blank" rel="noopener">https://www.zhangxinxu.com/wordpress/2018/08/js-base64-atob-btoa-encode-decode/?from=groupmessage</a></p>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Javascript Base64 window.btoa window.atob</tag>
      </tags>
  </entry>
  <entry>
    <title>Bcrypt、PBKDF2、Scrypt三种密码哈希函数的区别及优缺点</title>
    <url>/2019/12/04/Bcrypt%E3%80%81PBKDF2%E3%80%81Scrypt%E4%B8%89%E7%A7%8D%E5%AF%86%E7%A0%81%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>常用加密密码的三个主要哈希函数有bcrypt、PBKDF2和scrypt，但是他们之间有什么优缺点和区别呢？以及如何结合盐值使用，下面就来探讨一下。</p>
<h1 id="二、Bcrypt"><a href="#二、Bcrypt" class="headerlink" title="二、Bcrypt"></a>二、Bcrypt</h1><p>Bcrypt由Niels Provos 和 David Mazieres制定，是Belgain Fundamnetal Research in Cryptology and Informa-tion Security的简称。是基于Blowfish密码法的密钥导出函数。在保护密钥的过程中会加盐，而且具有适应能力。随着时间的推移，可以增加迭代次数，不断放慢速度，抵抗暴力攻击。</p>
<p>Bcrypt是首选的哈希函数，是专门为密码设计的密钥导出函数。</p>
<p>其优势有：</p>
<ul>
<li>基于Blowfish密码学，使用RAM中的查询表，在算法执行的过程中持续替换。这种表易于CPU处理，由于需要顺讯访问内存，而且是并行处理的，所以不适用与GPU，所以攻击者无法使用GUP硬件提升破解速度。</li>
<li>是专为密码设计的哈希算法，故意放慢速度（这对密码哈希是好事）。</li>
</ul>
<a id="more"></a>

<p>在网站或应用中动手实现这个算法：</p>
<ul>
<li>先从<code>npm</code>中安装<code>bcrypt</code> 包：</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span><span class="keyword">bcrypt </span>--save</span><br></pre></td></tr></table></figure>

<ul>
<li>然后把<code>bcrypt</code>引入<code>node</code>应用：</li>
</ul>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var bcrypt</span> = require(<span class="string">'bcrypt'</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bcrypt</code>包含了生成盐值的方法，因此不再需要使用<code>crypto</code>库，也就不需要再同时引入<code>bcrypt</code>和<code>crypto</code>了。下面是一个<code>bcrypt</code>算法的简单实现:</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bcrypt_encrypt</span><span class="params">(username,password)</span></span>&#123;</span><br><span class="line">  bcrypt.gensalt(<span class="number">10</span>, <span class="function"><span class="keyword">function</span><span class="params">(err, salt)</span> </span>&#123;</span><br><span class="line">    bcrypt.hash(password. salt, <span class="function"><span class="keyword">function</span><span class="params">(err,key)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把用户名、密码哈希值和盐值存入数据库</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数接受函数名和密码作为参数，可以假设它们在用户创建或更新账号时输入。上面代码采用异步方式生成盐值，这也是推荐使用的方法，还可以同步分别生成：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">var salt</span> = bcrypt.gemSaltSync(10);</span><br><span class="line"><span class="attribute">var hash</span> = bcrypt.hashSync(password, salt);</span><br></pre></td></tr></table></figure>

<p>盐值由<code>bcrypt.gensalt()</code>这个方法生成，其参数是循环次数（或称因子，默认为10）和一个回调，后者返回可能出现的错误和得到的盐值。<br>哈希值由<code>bcrypt.hash()</code>方法生成，这个方法的参数为要计算哈希值的密码和刚生成 的盐值，回调返回生成的哈希值。</p>
<h1 id="三、PBKDF2"><a href="#三、PBKDF2" class="headerlink" title="三、PBKDF2"></a>三、PBKDF2</h1><p>PBKDF2全称为Password-Based Key Derivation Function 2，由RSA Laboratoies制定。它在输入（密码）上应用一个伪随机函数（例如哈希、暗码或HMAC），此外还会加盐，这个过程会重复多次，最后得到一个密钥。</p>
<p>主要优势：</p>
<ul>
<li>经受住了时间的考验，而且过去这些年是大量研究的课题</li>
<li>1Password、LastPass等密码管理系统采用的算法</li>
<li>Node crypto 库原生支持的标准方法</li>
</ul>
<p><code>PBKDF2</code> 是Node crypto自带的哈希算法，使用起来十分简单，首先，在Node应用中引入crypto库：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pbkdf2_encrypt</span>(<span class="params">username, password</span>)</span>&#123;</span><br><span class="line">  crypto.randomBytes(<span class="number">32</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ex, salt</span>)</span>&#123;</span><br><span class="line">    crypto.pbkdf2(password, salt, <span class="number">4096</span>, <span class="number">512</span>, <span class="string">'SHA-256'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="comment">// 把用户名、密码哈希值和盐值存入数据库</span></span><br><span class="line">  &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用<code>crypto.randomBytes()</code>方法生成随机盐值，这个方法的参数是生成的数据的字节数（这里设为32字节），返回值是盐值。<br>然后调用<code>crypto.pbkdf2()</code>方法，传入下面的参数：</p>
<ul>
<li>用户密码</li>
<li>盐值</li>
<li>迭代次数，即应用哈希函数的次数（这里设为4096）</li>
<li>密钥长度（这里设为512）</li>
<li>摘要函数（这里设为SHA-256）。支持的各个摘要函数可以通过<code>crypto.getHashes()</code>查看</li>
</ul>
<p>这个函数返回的哈希值是十六进制格式的字符串，可以使用如下代买查看原始字符串：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="string">"key: "</span> + <span class="built_in">key</span>.toString(<span class="string">'hex'</span>));</span><br></pre></td></tr></table></figure>

<p>采用同步方式的代码如下：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const salt</span> = crypto.randomBytes(32);</span><br><span class="line"><span class="attribute">var result</span> = crypto.pbkdf2Sync(password, salt, 4096, 512, <span class="string">'SHA-256'</span>);</span><br></pre></td></tr></table></figure>

<h1 id="四、Scrypt"><a href="#四、Scrypt" class="headerlink" title="四、Scrypt"></a>四、Scrypt</h1><p>对于<code>PBKDF2</code>和<code>bcrypt</code>哪一个更好的争论从未停歇，但是<code>scrypt</code>采用的哈希算法与它们有很大 的差异。</p>
<p><code>scrypt</code>的优势：</p>
<ul>
<li>做了特殊设计，是硬件和内存密集型算法，攻击者需要实施大型攻击</li>
<li>是加密数字货币莱特币和狗狗货币背后采用的算法</li>
</ul>
<p>与<code>PBKDF2</code>和<code>bcrypt</code>相比，<code>scrypt</code>的主要优势是，若想要破解耗费异常多的硬件和内存，而破解<code>PBKDF2</code>和<code>bcrypt</code>哈希的数据可以在少量硬件资源上并行实施几千次攻击，因为它们在设计时就没有要求大量资源。</p>
<ul>
<li>首先安装<code>scrypt</code>模块</li>
</ul>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install </span><span class="keyword">scrypt </span>--save</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> scrypt = <span class="built_in">require</span>(<span class="string">'scrypt'</span>);</span><br><span class="line">    crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scrypt_encrypt</span>(<span class="params">username, password</span>)</span>&#123;</span><br><span class="line">  crypto.randomBytes(<span class="number">32</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ex, salt</span>)</span>&#123;</span><br><span class="line">    scrypt.hash(password, &#123;<span class="string">"N"</span>:<span class="number">16384</span>, <span class="string">"r"</span>:<span class="number">8</span>, <span class="string">"p"</span>:<span class="number">1</span>&#125;, <span class="number">64</span>, salt,</span><br><span class="line">      <span class="function"><span class="keyword">function</span>(<span class="params">err, key</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// 把用户名、密码哈希值和盐值存入数据库</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面函数使用<code>crypto</code>库中的<code>crypto.randomBytes()</code>方法生成盐值，传入输出的字节数，然后输出盐值。<br>然后，根据盐值生成哈希值，调用<code>scrypt.hash()</code>方法，其接受下面几个参数：</p>
<ul>
<li>需要计算哈希值的用户密码</li>
<li>一个对象，包含控制scrypt哈希行为的采纳数：<ul>
<li>N：scrypt 最多使用多久时间（秒数）计算密钥（偶数）</li>
<li>r：计算密钥是最多使用多少字节RAM（整数）。默认是0</li>
<li>p：计算密钥是所用RAM占可用值的比例（0-1，换算成百分比）。默认值为0.5</li>
</ul>
</li>
<li>得到的哈希值的长度</li>
<li>刚生成的盐值</li>
</ul>
<p>同步代码：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">const salt</span> = crypto.randomBytes(256);</span><br><span class="line"><span class="attribute">var result</span> = scrypt.hashSync(key, &#123;<span class="string">"N"</span>:16384, <span class="string">"r"</span>:8, <span class="string">"p"</span>:1&#125;, 64, salt);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>哈希函数</category>
      </categories>
      <tags>
        <tag>Bcrypt PBKDF2 Scrypt</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3之Transform，Transition，Animation的用法</title>
    <url>/2019/12/01/CSS3%E4%B9%8BTransform%EF%BC%8CTransition%EF%BC%8CAnimation%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>之前由于写CSS动画比较少，也很少遇到上面这几个属性的具体用法，但是在后来的开发过程中，经常碰到这几个属性但却不明白起用法和意义，这就是该下功夫补课的地方了，下面整理并记录一下这几个属性的具体用法和区别。</p>
<h1 id="二、具体用法"><a href="#二、具体用法" class="headerlink" title="二、具体用法"></a>二、具体用法</h1><h2 id="Transform，转换"><a href="#Transform，转换" class="headerlink" title="Transform，转换"></a>Transform，转换</h2><h4 id="rotate，旋转"><a href="#rotate，旋转" class="headerlink" title="rotate，旋转"></a>rotate，旋转</h4><ul>
<li>rotate(angle) 定义 2D 旋转</li>
<li>rotate3d(x,y,z,angle) 定义 3D 旋转</li>
<li>rotateX(angle) 定义沿着 X 轴的 3D 旋转</li>
<li>rotateY(angle) 定义沿着 Y 轴的 3D 旋转</li>
<li>rotateZ(angle) 定义沿着 Z 轴的 3D 旋转</li>
</ul>
<a id="more"></a>

<p>该属性用来旋转元素，下面是一个例子。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transform</span>:rotate(<span class="number">9deg</span>);</span><br><span class="line">-ms-<span class="attribute">transform</span>:rotate(<span class="number">9deg</span>); <span class="comment">/* Internet Explorer */</span></span><br><span class="line">-moz-<span class="attribute">transform</span>:rotate(<span class="number">9deg</span>); <span class="comment">/* Firefox */</span></span><br><span class="line">-webkit-<span class="attribute">transform</span>:rotate(<span class="number">9deg</span>); <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line">-o-<span class="attribute">transform</span>:rotate(<span class="number">9deg</span>); <span class="comment">/* Opera */</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_transform" target="_blank" rel="noopener">在线实例</a></p>
<h4 id="translate，移动"><a href="#translate，移动" class="headerlink" title="translate，移动"></a>translate，移动</h4><ul>
<li>translate(x,y) 定义2D移动</li>
<li>translate3d(x,y,z) 定义3D移动</li>
<li>translateX(x) 只用 X 轴的值来移动</li>
<li>translateY(y) 只用 Y 轴的值来移动</li>
<li>translateZ(z) 只用 Z 轴的值来移动</li>
</ul>
<p><code>Transform</code>属性的一个方法，使用<code>translate()</code>方法，可以设置该元素当前的 left（x 坐标） 和 top（y 坐标） 位置，来进行移动到坐标点对应的位置。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>: <span class="built_in">translate</span>(50px, 100px);</span><br><span class="line">-ms-<span class="built_in">transform</span>: <span class="built_in">translate</span>(50px,100px); <span class="comment">/* Internet Explorer */</span></span><br><span class="line">-webkit-<span class="built_in">transform</span>: <span class="built_in">translate</span>(50px,100px); <span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"> -o-<span class="built_in">transform</span>: <span class="built_in">translate</span>(50px,100px); <span class="comment">/* Opera */</span></span><br><span class="line">-moz-<span class="built_in">transform</span>: <span class="built_in">translate</span>(50px,100px); <span class="comment">/* Firefox */</span></span><br></pre></td></tr></table></figure>

<h4 id="scale，缩放"><a href="#scale，缩放" class="headerlink" title="scale，缩放"></a>scale，缩放</h4><ul>
<li>scale(x,y) 定义 2D 缩放</li>
<li>scale3d(x,y,z) 定义 3D 缩放</li>
<li>scaleX(x) 只用 X 轴的值来缩放</li>
<li>scaleY(y) 只用 Y 轴的值来缩放</li>
<li>scaleZ(z) 只用 Z 轴的值来缩放</li>
</ul>
<p>下面代码表示X轴和Y轴都放大为原来的二倍:</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">transform</span>: <span class="built_in">scale</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h4 id="skew，倾斜"><a href="#skew，倾斜" class="headerlink" title="skew，倾斜"></a>skew，倾斜</h4><ul>
<li>skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜</li>
<li>skewX(angle) 定义沿着 X 轴的 2D 倾斜</li>
<li>skewY(angle) 定义沿着 Y 轴的 2D 倾斜</li>
</ul>
<p>下面代码表示X 轴和Y 轴方向各倾斜20度：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">transform: skew(<span class="number">20</span><span class="built_in">deg</span>, <span class="number">20</span><span class="built_in">deg</span>);</span><br></pre></td></tr></table></figure>

<h2 id="Transition，过渡"><a href="#Transition，过渡" class="headerlink" title="Transition，过渡"></a>Transition，过渡</h2><ul>
<li>transition 简写属性，用于在一个属性中设置四个过渡属性</li>
<li>transition-property 设置应用过渡的 CSS 属性的名称</li>
<li>transition-duration 设置过渡效果花费的时间。默认是 0</li>
<li>transition-timing-function 设置过渡效果的时间曲线。默认是 “ease”</li>
<li>transition-delay 设置过渡效果何时开始。默认是 0</li>
</ul>
<h4 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">transition: <span class="keyword">property</span><span class="title"> </span>duration timing-function delay;</span><br></pre></td></tr></table></figure>

<h4 id="transition-property"><a href="#transition-property" class="headerlink" title="transition-property"></a>transition-property</h4><figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">transition-<span class="keyword">property</span><span class="title"></span>: none|all|<span class="keyword">property</span><span class="title"></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>none 没有属性会获得过渡效果</li>
<li>all 所有属性都将获得过渡效果</li>
<li>property 定义应用过渡效果的 CSS 属性名称列表，列表以逗号分隔</li>
</ul>
<h4 id="transition-duration"><a href="#transition-duration" class="headerlink" title="transition-duration"></a>transition-duration</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">transition-duration</span>: time;</span><br></pre></td></tr></table></figure>

<h4 id="transition-timing-function"><a href="#transition-timing-function" class="headerlink" title="transition-timing-function"></a>transition-timing-function</h4><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">transition-timing-function: linear|<span class="type">ease</span>|<span class="type">ease</span>-<span class="built_in">in</span>|<span class="type">ease</span>-out|<span class="type">ease</span>-<span class="built_in">in</span>-out|<span class="type">cubic</span>-</span><br><span class="line">bezier(n,n,n,n);</span><br></pre></td></tr></table></figure>

<ul>
<li>linear    设置以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）</li>
<li>ease    设置慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）</li>
<li>ease-in    设置以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）</li>
<li>ease-out    设置以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）</li>
<li>ease-in-out    设置以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）</li>
<li>cubic-bezier(n,n,n,n)    在 cubic-bezier 函数中定义自己的值，可能的值是 0 至 1 之间的数值</li>
</ul>
<h4 id="transition-delay"><a href="#transition-delay" class="headerlink" title="transition-delay"></a>transition-delay</h4><figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">transition-<span class="built_in">delay</span>: <span class="built_in">time</span>;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">transition-property</span>: width;</span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* Firefox 4 */</span></span><br><span class="line"><span class="attribute">-moz-transition-property</span>:width;</span><br><span class="line"><span class="attribute">-moz-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line"><span class="attribute">-moz-transition-timing-function</span>:linear;</span><br><span class="line"><span class="attribute">-moz-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"><span class="attribute">-webkit-transition-property</span>:width;</span><br><span class="line"><span class="attribute">-webkit-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line"><span class="attribute">-webkit-transition-timing-function</span>:linear;</span><br><span class="line"><span class="attribute">-webkit-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* Opera */</span></span><br><span class="line"><span class="attribute">-o-transition-property</span>:width;</span><br><span class="line"><span class="attribute">-o-transition-duration</span>:<span class="number">1s</span>;</span><br><span class="line"><span class="attribute">-o-transition-timing-function</span>:linear;</span><br><span class="line"><span class="attribute">-o-transition-delay</span>:<span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_transition3" target="_blank" rel="noopener">在线实例</a></p>
<p>上面实例的简写版：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">transition</span>: width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* Firefox 4 */</span></span><br><span class="line"><span class="attribute">-moz-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* Safari and Chrome */</span></span><br><span class="line"><span class="attribute">-webkit-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* Opera */</span></span><br><span class="line"><span class="attribute">-o-transition</span>:width <span class="number">1s</span> linear <span class="number">2s</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_transition4" target="_blank" rel="noopener">在线实例</a></p>
<h2 id="Animation，动画"><a href="#Animation，动画" class="headerlink" title="Animation，动画"></a>Animation，动画</h2><ul>
<li>@keyframes 设置动画</li>
<li>animation 所有动画属性的简写属性，除了 animation-play-state 属性</li>
<li>animation-name 设置@keyframes 动画的名称</li>
<li>animation-duration 设置动画完成一个周期所花费的秒或毫秒。默认是 0</li>
<li>animation-timing-function 设置动画的速度曲线。默认是 “ease”</li>
<li>animation-delay 设置动画何时开始。默认是 0</li>
<li>animation-iteration-count 设置动画被播放的次数。默认是 1</li>
<li>animation-direction 设置动画是否在下一周期逆向地播放。默认是 “normal”</li>
<li>animation-play-state 设置动画是否正在运行或暂停。默认是 “running”</li>
<li>animation-fill-mode 设置对象动画时间之外的状态</li>
</ul>
<h4 id="keyframes"><a href="#keyframes" class="headerlink" title="@keyframes"></a>@keyframes</h4><figure class="highlight dts"><table><tr><td class="code"><pre><span class="line">@keyframes <span class="class">animationname </span>&#123;keyframes-<span class="class">selector </span>&#123;css-styles;&#125;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>animationname 必需，定义动画的名称</li>
<li>keyframes-selector 必需，动画时长的百分比<br>合法的值：0-100%<br>from（与 0% 相同）<br>to（与 100% 相同）</li>
<li>css-styles 必需，一个或多个合法的 CSS 样式属性</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> mymove</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> mymove /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> mymove /* Safari 和 Chrome */</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> mymove /* Opera */</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目前浏览器都不支持 <code>@keyframes</code>规则。<br>Firefox 支持替代的 <code>@-moz-keyframes</code>规则。<br>Opera 支持替代的 <code>@-o-keyframes</code>规则。<br>Safari 和 Chrome 支持替代的 <code>@-webkit-keyframes</code>规则。</p>
<h4 id="animation"><a href="#animation" class="headerlink" title="animation"></a>animation</h4><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">animation: <span class="keyword">name</span> duration timing-<span class="function"><span class="keyword">function</span></span> delay iteration-<span class="built_in">count</span> direction;</span><br></pre></td></tr></table></figure>

<ul>
<li>animation-name 设置需要绑定到选择器的 keyframe 名称</li>
<li>animation-duration 设置完成动画所花费的时间，以秒或毫秒计</li>
<li>animation-timing-function 设置动画的速度曲线</li>
<li>animation-delay 设置在动画开始之前的延迟</li>
<li>animation-iteration-count 设置动画应该播放的次数</li>
<li>animation-direction 设置是否应该轮流反向播放动画</li>
</ul>
<h4 id="animation-name"><a href="#animation-name" class="headerlink" title="animation-name"></a>animation-name</h4><figure class="highlight fortran"><table><tr><td class="code"><pre><span class="line">animation-<span class="keyword">name</span>: keyframename|<span class="keyword">none</span>;</span><br></pre></td></tr></table></figure>

<h4 id="animation-duration"><a href="#animation-duration" class="headerlink" title="animation-duration"></a>animation-duration</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">animation</span>-duration: <span class="built_in">time</span>;</span><br></pre></td></tr></table></figure>

<h4 id="animation-timing-function"><a href="#animation-timing-function" class="headerlink" title="animation-timing-function"></a>animation-timing-function</h4><figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">animation-timing-<span class="function"><span class="keyword">function</span>: value</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>linear 动画从头到尾的速度是相同的</li>
<li>ease 默认，动画以低速开始，然后加快，在结束前变慢</li>
<li>ease-in    动画以低速开始</li>
<li>ease-out 动画以低速结束</li>
<li>ease-in-out 动画以低速开始和结束</li>
<li>cubic-bezier(n,n,n,n) 在 cubic-bezier 函数中自己的值，可能的值是从 0 到 1 的数值</li>
</ul>
<p>一些具体用法：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* W3C 和 Opera: */</span></span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">animation-timing-function</span>: linear;&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">animation-timing-function</span>: ease;&#125;</span><br><span class="line"><span class="selector-id">#div3</span> &#123;<span class="attribute">animation-timing-function</span>: ease-in;&#125;</span><br><span class="line"><span class="selector-id">#div4</span> &#123;<span class="attribute">animation-timing-function</span>: ease-out;&#125;</span><br><span class="line"><span class="selector-id">#div5</span> &#123;<span class="attribute">animation-timing-function</span>: ease-in-out;&#125;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: linear;&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: ease;&#125;</span><br><span class="line"><span class="selector-id">#div3</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: ease-in;&#125;</span><br><span class="line"><span class="selector-id">#div4</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: ease-out;&#125;</span><br><span class="line"><span class="selector-id">#div5</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: ease-in-out;&#125;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: linear;&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: ease;&#125;</span><br><span class="line"><span class="selector-id">#div3</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: ease-in;&#125;</span><br><span class="line"><span class="selector-id">#div4</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: ease-out;&#125;</span><br><span class="line"><span class="selector-id">#div5</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: ease-in-out;&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_animation-timing-function2" target="_blank" rel="noopener">实例</a></p>
<p>通过 cubic-bezier 函数来定义速度曲线：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* W3C 和 Opera: */</span></span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0,0,1,1);&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.25,0.1,0.25,1);&#125;</span><br><span class="line"><span class="selector-id">#div3</span> &#123;<span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.42,0,1,1);&#125;</span><br><span class="line"><span class="selector-id">#div4</span> &#123;<span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0,0,0.58,1);&#125;</span><br><span class="line"><span class="selector-id">#div5</span> &#123;<span class="attribute">animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.42,0,0.58,1);&#125;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0,0,1,1);&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.25,0.1,0.25,1);&#125;</span><br><span class="line"><span class="selector-id">#div3</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.42,0,1,1);&#125;</span><br><span class="line"><span class="selector-id">#div4</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0,0,0.58,1);&#125;</span><br><span class="line"><span class="selector-id">#div5</span> &#123;<span class="attribute">-moz-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.42,0,0.58,1);&#125;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="selector-id">#div1</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0,0,1,1);&#125;</span><br><span class="line"><span class="selector-id">#div2</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.25,0.1,0.25,1);&#125;</span><br><span class="line"><span class="selector-id">#div3</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.42,0,1,1);&#125;</span><br><span class="line"><span class="selector-id">#div4</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0,0,0.58,1);&#125;</span><br><span class="line"><span class="selector-id">#div5</span> &#123;<span class="attribute">-webkit-animation-timing-function</span>: <span class="built_in">cubic-bezier</span>(0.42,0,0.58,1);&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_animation-timing-function3" target="_blank" rel="noopener">实例</a></p>
<h4 id="animation-delay"><a href="#animation-delay" class="headerlink" title="animation-delay"></a>animation-delay</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line"><span class="built_in">animation</span>-<span class="built_in">delay</span>: <span class="built_in">time</span>;</span><br></pre></td></tr></table></figure>

<h4 id="animation-iteration-count"><a href="#animation-iteration-count" class="headerlink" title="animation-iteration-count"></a>animation-iteration-count</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-iteration-count</span>: n|infinite;</span><br></pre></td></tr></table></figure>

<ul>
<li>n 设置动画播放次数的数值</li>
<li>infinite 设置动画应该无限次播放</li>
</ul>
<h4 id="animation-direction"><a href="#animation-direction" class="headerlink" title="animation-direction"></a>animation-direction</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-direction</span>: normal|alternate;</span><br></pre></td></tr></table></figure>

<ul>
<li>normal 默认值，动画应该正常播放</li>
<li>alternate 动画应该轮流反向播放</li>
</ul>
<h4 id="animation-play-state"><a href="#animation-play-state" class="headerlink" title="animation-play-state"></a>animation-play-state</h4><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="attribute">animation-play-state</span>: paused|running;</span><br></pre></td></tr></table></figure>

<ul>
<li>paused    设置动画已暂停 </li>
<li>running    设置动画正在播放</li>
</ul>
<h4 id="animation-fill-mode"><a href="#animation-fill-mode" class="headerlink" title="animation-fill-mode"></a>animation-fill-mode</h4><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">animation-fill-mode : none | <span class="type">forwards</span> | <span class="type">backwards</span> | <span class="type">both</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>none 不改变默认行为</li>
<li>forwards 当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）</li>
<li>backwards 在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）</li>
<li>both 向前和向后填充模式都被应用</li>
</ul>
<h2 id="一些实例"><a href="#一些实例" class="headerlink" title="一些实例"></a>一些实例</h2><h4 id="一个改变背景色动画"><a href="#一个改变背景色动画" class="headerlink" title="一个改变背景色动画"></a>一个改变背景色动画</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> myfirst /* Safari 和 Chrome */</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line"><span class="selector-tag">from</span> &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line"><span class="selector-tag">to</span> &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把 <code>myfirst</code> 动画捆绑到 <code>div</code> 元素，时长：5 秒：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span>;	<span class="comment">/* Firefox */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span>;	<span class="comment">/* Safari 和 Chrome */</span></span><br><span class="line"><span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span>;	<span class="comment">/* Opera */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_animation1" target="_blank" rel="noopener">在线查看</a></p>
<p>当动画为 25% 及 50% 时改变背景色，然后当动画 100% 完成时再次改变：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> myfirst /* Safari 和 Chrome */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: green;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_animation2" target="_blank" rel="noopener">实例在线地址</a></p>
<h4 id="改变背景色和位置："><a href="#改变背景色和位置：" class="headerlink" title="改变背景色和位置："></a>改变背景色和位置：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">keyframes</span> myfirst</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">moz</span>-<span class="keyword">keyframes</span> myfirst /* Firefox */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">webkit</span>-<span class="keyword">keyframes</span> myfirst /* Safari 和 Chrome */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@-<span class="keyword">o</span>-<span class="keyword">keyframes</span> myfirst /* Opera */</span><br><span class="line">&#123;</span><br><span class="line">0%   &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">25%  &#123;<span class="attribute">background</span>: yellow; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">50%  &#123;<span class="attribute">background</span>: blue; <span class="attribute">left</span>:<span class="number">200px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">75%  &#123;<span class="attribute">background</span>: green; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">200px</span>;&#125;</span><br><span class="line">100% &#123;<span class="attribute">background</span>: red; <span class="attribute">left</span>:<span class="number">0px</span>; <span class="attribute">top</span>:<span class="number">0px</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://www.w3school.com.cn/tiy/t.asp?f=css3_animation3" target="_blank" rel="noopener">实例在线地址</a></p>
<h4 id="运行名为-myfirst-的动画，其中设置了所有动画属性："><a href="#运行名为-myfirst-的动画，其中设置了所有动画属性：" class="headerlink" title="运行名为 myfirst 的动画，其中设置了所有动画属性："></a>运行名为 myfirst 的动画，其中设置了所有动画属性：</h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">animation-name</span>: myfirst;</span><br><span class="line"><span class="attribute">animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">animation-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">animation-iteration-count</span>: infinite;</span><br><span class="line"><span class="attribute">animation-direction</span>: alternate;</span><br><span class="line"><span class="attribute">animation-play-state</span>: running;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="attribute">-moz-animation-name</span>: myfirst;</span><br><span class="line"><span class="attribute">-moz-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-moz-animation-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">-moz-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">-moz-animation-iteration-count</span>: infinite;</span><br><span class="line"><span class="attribute">-moz-animation-direction</span>: alternate;</span><br><span class="line"><span class="attribute">-moz-animation-play-state</span>: running;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="attribute">-webkit-animation-name</span>: myfirst;</span><br><span class="line"><span class="attribute">-webkit-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-webkit-animation-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">-webkit-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">-webkit-animation-iteration-count</span>: infinite;</span><br><span class="line"><span class="attribute">-webkit-animation-direction</span>: alternate;</span><br><span class="line"><span class="attribute">-webkit-animation-play-state</span>: running;</span><br><span class="line"><span class="comment">/* Opera: */</span></span><br><span class="line"><span class="attribute">-o-animation-name</span>: myfirst;</span><br><span class="line"><span class="attribute">-o-animation-duration</span>: <span class="number">5s</span>;</span><br><span class="line"><span class="attribute">-o-animation-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">-o-animation-delay</span>: <span class="number">2s</span>;</span><br><span class="line"><span class="attribute">-o-animation-iteration-count</span>: infinite;</span><br><span class="line"><span class="attribute">-o-animation-direction</span>: alternate;</span><br><span class="line"><span class="attribute">-o-animation-play-state</span>: running;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的简写版：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="attribute">animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Firefox: */</span></span><br><span class="line"><span class="attribute">-moz-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Safari 和 Chrome: */</span></span><br><span class="line"><span class="attribute">-webkit-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line"><span class="comment">/* Opera: */</span></span><br><span class="line"><span class="attribute">-o-animation</span>: myfirst <span class="number">5s</span> linear <span class="number">2s</span> infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h1><p><a href="https://www.w3school.com.cn/css3/css3_animation.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/css3/css3_animation.asp</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS3 Transform Transition Animation</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解CSS布局之Flexbox</title>
    <url>/2019/11/26/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CSS%E5%B8%83%E5%B1%80%E4%B9%8BFlexbox/</url>
    <content><![CDATA[<h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p><code>Flexbox</code>布局提供了一种高效的在容器中布局、对齐、分配空间的方式，即使其<code>item</code>的大小是未知的或者动态的。</p>
<h1 id="二、属性"><a href="#二、属性" class="headerlink" title="二、属性"></a>二、属性</h1><h3 id="flex-container相关"><a href="#flex-container相关" class="headerlink" title="flex container相关"></a>flex container相关</h3><ul>
<li>display</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>flex-flow</li>
<li>justify-content</li>
<li>align-items</li>
<li>align-content</li>
</ul>
<h3 id="flex-items相关"><a href="#flex-items相关" class="headerlink" title="flex items相关"></a>flex items相关</h3><ul>
<li>order</li>
<li>flex-grow</li>
<li>flex-shrink</li>
<li>flex-basis</li>
<li>flex</li>
<li>align-self</li>
</ul>
<a id="more"></a>

<h1 id="三、具体语法"><a href="#三、具体语法" class="headerlink" title="三、具体语法"></a>三、具体语法</h1><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 或者inline-flex */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义一个<code>flex container</code>，行内或者块级取决于所给的值，<code>flex</code>表示容器内元素以块级元素展示，<code>inline-flex</code>表示容器内元素行内元素展示。</p>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个属性定义了一个主轴，决定了<code>flex items</code>在<code>flex container</code>中如何排列，从左到右还是从上到下。</p>
<ul>
<li><code>row</code> 默认，在<code>ltr</code>中从左到右，<code>rtl</code>中从右到左</li>
<li><code>row-reverse</code> 与上面正好相反，在<code>ltr</code>中从右到左，<code>rtl</code>中从左到右</li>
<li><code>column</code> 与<code>row</code> 类似，从上到下</li>
<li><code>column-reverse</code> 与<code>row-reverse</code> 类似，从下到上</li>
</ul>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>flex items</code>会尽可能占满一行，可以用这个属性来控制换行。</p>
<ul>
<li><code>nowrap</code> 默认值，所有<code>items</code>都会在同一行</li>
<li><code>wrap</code> 从上到下换到多行显示</li>
<li><code>wrap-reverse</code> 从下到上换到多行显示<br><a href="https://css-tricks.com/almanac/properties/f/flex-wrap/" target="_blank" rel="noopener">一个<code>flex-wrap</code>的例子</a></li>
</ul>
<h3 id="flex-flow（用于flex-container元素）"><a href="#flex-flow（用于flex-container元素）" class="headerlink" title="flex-flow（用于flex container元素）"></a>flex-flow（用于<code>flex container</code>元素）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">flex-flow: <span class="tag">&lt;<span class="name">‘flex-direction’</span>&gt;</span> || <span class="tag">&lt;<span class="name">‘flex-wrap’</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>flex-direction</code> 和 <code>flex-wrap</code> 属性的缩写，共同定义了<code>flex container</code>横轴和纵轴，默认值是<code>row nowrap</code>。</p>
<h3 id="justify-content，内容水平对齐"><a href="#justify-content，内容水平对齐" class="headerlink" title="justify-content，内容水平对齐"></a>justify-content，内容水平对齐</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">space</span>-evenly | <span class="type">start</span> | <span class="type">end</span> | <span class="type">left</span> | <span class="type">right</span> ... + safe | <span class="type">unsafe</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flex-start</code> 朝着<code>flex-direction</code>开始的方向对齐</li>
<li><code>flex-end</code> 朝着<code>flex-direction</code>结束的方向对齐</li>
<li><code>center</code> 居中对齐</li>
<li><code>space-between</code> 最外侧两个<code>item</code>与外边距没有空间，其余任意两个之间等距</li>
<li><code>space-around</code> 每一个<code>item</code>都有左右间距，<code>item</code>与<code>item</code>之间是两倍于<code>item</code>与外边距之间的距离</li>
<li><code>space-evenly</code> 每一个<code>item</code>之间都左右等距，包括与外边距</li>
<li><code>start</code> 朝着<code>writing-mode</code>开始的方向对齐</li>
<li><code>end</code> 朝着<code>writing-mode</code>结束的方向对齐</li>
<li><code>left</code> 除非与<code>flex-direction</code>有冲突，不然的话与<code>start</code>一样</li>
<li><code>right</code> 除非与<code>flex-direction</code>有冲突，不然的话与<code>end</code>一样</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1741029-0b1eaa9a32436a3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="水平对齐"></p>
<h3 id="align-items，item垂直对齐"><a href="#align-items，item垂直对齐" class="headerlink" title="align-items，item垂直对齐"></a>align-items，item垂直对齐</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-items: stretch | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">first</span> baseline | <span class="type">last</span> baseline | <span class="type">start</span> | <span class="type">end</span> | <span class="type">self</span>-start | <span class="type">self</span>-<span class="keyword">end</span> + ... safe | <span class="type">unsafe</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>stretch</code> 默认值，占满整个容器</li>
<li><code>flex-start / start  /  self-start</code> 顶部对齐，差别很小，与<code>flex-direction</code>  和 <code>writing-mode</code>有一定联系</li>
<li><code>flex-end / end /  self-end</code> 底部对齐，差别很小，与<code>flex-direction</code>  和 <code>writing-mode</code>有一定联系</li>
<li><code>center</code> 垂直居中</li>
<li><code>baseline</code> 基准线对齐</li>
<li><code>first baseline</code> 第一条基准线对齐</li>
<li><code>last baseline</code> 最后一条基准线对齐</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1741029-200c1344348b699a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="垂直对齐"></p>
<h3 id="align-content，整体内容对齐"><a href="#align-content，整体内容对齐" class="headerlink" title="align-content，整体内容对齐"></a>align-content，整体内容对齐</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-content: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">space</span>-evenly | <span class="type">stretch</span> | <span class="type">start</span> | <span class="type">end</span> | <span class="type">baseline</span> | <span class="type">first</span> baseline | <span class="type">last</span> baseline + ... safe | <span class="type">unsafe</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>flex-start / start</code>  <code>items</code>从<code>container</code>的左上方开始陈列，<code>flex-start</code>对应<code>flex-direction</code>，<code>start</code>对应<code>writing-mode</code> </li>
<li><code>flex-end / end</code> <code>items</code>从<code>container</code>的左下方开始陈列，<code>flex-end</code>对应<code>flex-direction</code>，<code>end</code>对应<code>writing-mode</code> </li>
<li><code>center</code> 垂直居中</li>
<li><code>space-between</code> 头部和底部没有空间，其余等距均分</li>
<li><code>space-around</code> 头部和底部有一倍间距，其余<code>items</code>  之间为二倍间距</li>
<li><code>space-evenly</code> 所有<code>items</code>  等距均分</li>
<li><code>stretch</code> 占满垂直空间距离</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/1741029-9d564590c1de115e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体内容对齐"></p>
<h2 id="flex-items相关-1"><a href="#flex-items相关-1" class="headerlink" title="flex items相关"></a>flex items相关</h2><h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* 默认是 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flex items</code>默认是按照原始顺序排列，<code>order</code>属性可以控制<code>flex items</code>在<code>flex container</code>的排列顺序。</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* 默认是 0，负数无效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>flex-grow: 1;</code> 其所有<code>flex items</code>等分剩余空间，如果其中有一个的值为2，其占两倍于值为1的空间，以此类推。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1741029-b614cd266f0481d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="flex-grow值为1和2对比"></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* 默认是 1，负数无效 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使<code>flex item</code>缩放。</p>
<h3 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* 默认是 auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个属性在剩余空间被分配之前定义一个元素的默认尺寸，其值可以是长度（<code>20%</code>或<code>5rem</code>）或者关键词，<code>auto</code>意味着查看<code>width</code>或<code>height</code>属性，可以暂时使用<code>main-size</code>关键字来实现在其被弃用之前。<code>content</code>关键字意味着根据其内容的尺寸来给定默认值，但是这个属性没有被很好支持，所以很难测试并且更难弄清楚他的类似属性<code>max-content</code>、<code>min-content</code>和<code>fit-content</code>是如何作用的。<br>如果设置为<code>0</code>，内容周围的额外空间将不会被计入。如果设置为<code>auto</code>，额外空间将基于<code>flex-grow</code>属性来分发。</p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>flex-grow</code>、<code>flex-shrink</code>和 <code>flex-basis</code>的缩写，第二三个值<code>flex-shrink</code>和 <code>flex-basis</code>是可选的，默认值是<code>0 1 auto</code>，因为其会自动设置其他属性值，所以推荐使用此属性而不是分别设置上面的属性值。</p>
<h3 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h3><figure class="highlight coq"><table><tr><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: <span class="built_in">auto</span> | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个属性可以覆盖父级元素设置的属性，比如<code>align-items</code>设置过的属性。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1741029-2b57ec9c25ed3ddb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="align-self覆盖flex-start属性"></p>
<h4 id="！注意：float-、clear-和-vertical-align属性对flex-item没有影响。"><a href="#！注意：float-、clear-和-vertical-align属性对flex-item没有影响。" class="headerlink" title="！注意：float 、clear 和 vertical-align属性对flex item没有影响。"></a>！注意：<code>float</code> 、<code>clear</code> 和 <code>vertical-align</code>属性对<code>flex item</code>没有影响。</h4><p>#四、一些例子</p>
<h3 id="简单居中"><a href="#简单居中" class="headerlink" title="简单居中"></a>简单居中</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;  </span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>; </span><br><span class="line">  <span class="attribute">margin</span>: auto;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自适应，不使用-media"><a href="#自适应，不使用-media" class="headerlink" title="自适应，不使用@media"></a>自适应，不使用<code>@media</code></h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="comment">/* 上面缩写相当于</span></span><br><span class="line"><span class="comment">   * flex-direction: row;</span></span><br><span class="line"><span class="comment">   * flex-wrap: wrap;</span></span><br><span class="line"><span class="comment">   * 定义了主轴是从左到右的，而且允许换行</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* 定义如何分配剩余空间，即每个item周围都有空间*/</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/team/css-tricks/pen/EKEYob?__cf_chl_captcha_tk__=5c642ec60a6cc239608b6bfe3da1a4d0e9745280-1575119677-0-AQQfEvvWj6h7QzJQah8yDu2l8Urr_CS3lTPa4wKUH7prJ8B1m2Z5d-rJqo3D4oXAGVUr2wUQ_MXemw1FMtDy-SwVMDo3mjFc18JXFWwl2-3QiL7o5w8Zcfcj0PAOzUQ7hoBcM2Y79aJPjYzX7OtREk74DxU2Alyop0EB8uxwYVXZUGrNBsru7E8h68RTGDoBjj26ejwbuSTBezEKPWKtA5M490MrYjD5kvh8juq0f-9Tt1GnhHGAqKhRqvpbx0EFFSfB0mHN8xiJL3k36p8VY24XVnpGk4FeJ2YTgfOfyu3ItgE2Us-suN8i0N1rOScAIypzJk5-JnAYMIiQpODFwxc" target="_blank" rel="noopener">在线实例</a></p>
<h3 id="一个导航栏，在小屏幕上自动换行显示"><a href="#一个导航栏，在小屏幕上自动换行显示" class="headerlink" title="一个导航栏，在小屏幕上自动换行显示"></a>一个导航栏，在小屏幕上自动换行显示</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 大屏幕正常显示 */</span></span><br><span class="line"><span class="selector-class">.navigation</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="comment">/* 在主轴上从后往前对齐，即从右到左 */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中等屏幕 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="comment">/* 相当于居中对齐，左右两边两个与外侧间距少一半 */</span></span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 小屏幕 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">500px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="comment">/* 纵向对齐，即换行显示 */</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/team/css-tricks/pen/YqaKYR" target="_blank" rel="noopener">在线实例</a></p>
<h3 id="一个有头部底部的三列布局"><a href="#一个有头部底部的三列布局" class="headerlink" title="一个有头部底部的三列布局"></a>一个有头部底部的三列布局</h3><figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap; <span class="comment">// 横向排列，允许换行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过 flex-basis，设置所有item的宽度为百分之百 */</span></span><br><span class="line"><span class="selector-class">.wrapper</span> &gt; * &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 在这个例子中采用移动端优先的源顺序的方式</span></span><br><span class="line"><span class="comment"> * 1. header</span></span><br><span class="line"><span class="comment"> * 2. article</span></span><br><span class="line"><span class="comment"> * 3. aside 1</span></span><br><span class="line"><span class="comment"> * 4. aside 2</span></span><br><span class="line"><span class="comment"> * 5. footer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 中等屏幕 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (min-width: 600px) &#123;</span><br><span class="line">  <span class="comment">/* 设置 sidebars 在同一行显示 */</span></span><br><span class="line">  <span class="selector-class">.aside</span> &#123; <span class="attribute">flex</span>: <span class="number">1</span> auto; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 大屏幕 */</span></span><br><span class="line">@<span class="keyword">media</span> all and (min-width: 800px) &#123;</span><br><span class="line">  <span class="comment">/* 调换第一个sidebar 和 main 的顺序</span></span><br><span class="line"><span class="comment">   * 设置main 的宽度为其余两个sidebar 总宽度的两倍</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="selector-class">.main</span> &#123; <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">0px</span>; &#125;</span><br><span class="line">  <span class="selector-class">.aside-1</span> &#123; <span class="attribute">order</span>: <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="selector-class">.main</span>    &#123; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="selector-class">.aside-2</span> &#123; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</span><br><span class="line">  <span class="selector-class">.footer</span>  &#123; <span class="attribute">order</span>: <span class="number">4</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://codepen.io/halshaw/pen/qBEWpBw" target="_blank" rel="noopener">在线实例</a></p>
<h1 id="五、前缀"><a href="#五、前缀" class="headerlink" title="五、前缀"></a>五、前缀</h1><p>Flexbox 可能会需要一些前缀以用来支持不同的浏览器，下面是一些参考。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> flexbox() &#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">display</span>: -moz-box;</span><br><span class="line">  <span class="attribute">display</span>: -ms-flexbox;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-flex;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> flex(<span class="variable">$values</span>) &#123;</span><br><span class="line">  -webkit-box-<span class="attribute">flex</span>: <span class="variable">$values</span>;</span><br><span class="line">  -moz-box-<span class="attribute">flex</span>:  <span class="variable">$values</span>;</span><br><span class="line">  -webkit-<span class="attribute">flex</span>:  <span class="variable">$values</span>;</span><br><span class="line">  -ms-<span class="attribute">flex</span>:  <span class="variable">$values</span>;</span><br><span class="line">  <span class="attribute">flex</span>:  <span class="variable">$values</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">mixin</span> order(<span class="variable">$val</span>) &#123;</span><br><span class="line">  -webkit-box-ordinal-group: <span class="variable">$val</span>;  </span><br><span class="line">  -moz-box-ordinal-group: <span class="variable">$val</span>;     </span><br><span class="line">  -ms-<span class="attribute">flex</span>-<span class="attribute">order</span>: <span class="variable">$val</span>;     </span><br><span class="line">  -webkit-<span class="attribute">order</span>: <span class="variable">$val</span>;  </span><br><span class="line">  <span class="attribute">order</span>: <span class="variable">$val</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flexbox();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  @<span class="keyword">include</span> flex(<span class="number">1</span> 200px);</span><br><span class="line">  @<span class="keyword">include</span> order(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="六、浏览器支持"><a href="#六、浏览器支持" class="headerlink" title="六、浏览器支持"></a>六、浏览器支持</h1><p><img src="https://upload-images.jianshu.io/upload_images/1741029-fb80488607713961.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flex目前支持的浏览器"></p>
<h1 id="七、参考（翻译）"><a href="#七、参考（翻译）" class="headerlink" title="七、参考（翻译）"></a>七、参考（翻译）</h1><p><a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/a-guide-to-flexbox</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS Flexbox</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解CSS布局之Grid</title>
    <url>/2019/11/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/</url>
    <content><![CDATA[<h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p>一直听说<code>CSS</code>的<code>Grid</code>布局是一项非常强大的布局技术，不像<code>Flex</code>布局只是一维的系统，<code>Grid</code>布局是个二维的系统，也就是说其可以同时处理行和列。<code>Grid</code>布局分为两个部分，<code>Grid</code>容器（Container）和<code>Grid</code>项目（Items）。</p>
<h1 id="二、-一些重要概念及术语"><a href="#二、-一些重要概念及术语" class="headerlink" title="二、 一些重要概念及术语"></a>二、 一些重要概念及术语</h1><h3 id="Grid-Container"><a href="#Grid-Container" class="headerlink" title="Grid Container"></a>Grid Container</h3><p>应用了<code>display: grid</code>的元素，它是所有<code>grid items</code>的直接父元素，例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item item-1"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item item-2"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item item-3"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Grid-Item"><a href="#Grid-Item" class="headerlink" title="Grid Item"></a>Grid Item</h3><p><code>Grid Container</code>的直接后代元素，所有<code>div.item</code>都是，但是<code>p.sun-item</code>不是。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;&lt;/<span class="keyword">div</span>&gt; </span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">  	&lt;p <span class="built_in">class</span>=<span class="string">"sub-item"</span>&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Grid-Line"><a href="#Grid-Line" class="headerlink" title="Grid Line"></a>Grid Line</h3><p>组成<code>Grid</code>结构的分割线，可垂直（<code>column grid lines</code>）可水平（<code>row grid lines</code>）。</p>
<h3 id="Grid-Track"><a href="#Grid-Track" class="headerlink" title="Grid Track"></a>Grid Track</h3><p>两个相邻<code>Grid</code>行之间的距离，其实就是一整行或整列的距离，如第二行与第三行之间的<code>Grid Track</code>就只第二行一整行。</p>
<h3 id="Grid-Cell"><a href="#Grid-Cell" class="headerlink" title="Grid Cell"></a>Grid Cell</h3><p>两个相邻行与相邻列之间的距离，就相当于田字格或九宫格当中的一小格。</p>
<h3 id="Grid-Area"><a href="#Grid-Area" class="headerlink" title="Grid Area"></a>Grid Area</h3><p>四<code>Grid</code>行包围的空间，一个<code>Grid Area</code>可能包含许多<code>grid cells</code>。</p>
<h1 id="三、Grid-属性"><a href="#三、Grid-属性" class="headerlink" title="三、Grid 属性"></a>三、Grid 属性</h1><h3 id="Grid-Container相关"><a href="#Grid-Container相关" class="headerlink" title="Grid Container相关"></a>Grid Container相关</h3><ul>
<li>display</li>
<li>grid-template-columns</li>
<li>grid-template-rows</li>
<li>grid-template-areas</li>
<li>grid-template</li>
<li>grid-column-gap</li>
<li>grid-row-gap</li>
<li>grid-gap</li>
<li>justify-items</li>
<li>align-items</li>
<li>place-items</li>
<li>justify-content</li>
<li>align-content</li>
<li>place-content</li>
<li>grid-auto-columns</li>
<li>grid-auto-rows</li>
<li>grid-auto-flow</li>
<li>grid</li>
</ul>
<h3 id="Grid-Items相关"><a href="#Grid-Items相关" class="headerlink" title="Grid Items相关"></a>Grid Items相关</h3><ul>
<li>grid-column-start</li>
<li>grid-column-end</li>
<li>grid-row-start</li>
<li>grid-row-end</li>
<li>grid-column</li>
<li>grid-row</li>
<li>grid-area</li>
<li>justify-self</li>
<li>align-self</li>
<li>place-self</li>
</ul>
<h1 id="四、具体布局"><a href="#四、具体布局" class="headerlink" title="四、具体布局"></a>四、具体布局</h1><h2 id="Grid-Container-1"><a href="#Grid-Container-1" class="headerlink" title="Grid Container"></a>Grid Container</h2><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid | inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>grid</code>表示生成一个块级<code>grid</code></li>
<li><code>inline-grid</code>表示生成一个行内<code>grid</code></li>
</ul>
<h3 id="grid-template-columns-amp-grid-template-rows"><a href="#grid-template-columns-amp-grid-template-rows" class="headerlink" title="grid-template-columns &amp; grid-template-rows"></a>grid-template-columns &amp; grid-template-rows</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">  <span class="keyword">grid</span>-template-columns: &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ... | &lt;line-name&gt; &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ...;</span><br><span class="line">  <span class="keyword">grid</span>-template-rows: &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ... | &lt;line-name&gt; &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><track-size></track-size></strong> - 可以是长度值、百分比或者<code>grid</code>中的可用空间的一部分单位<code>fr</code></li>
<li><strong><line-name></line-name></strong> - 一个任意的名字</li>
</ul>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">50px</span> auto <span class="number">50px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">25px</span> <span class="number">25px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其布局效果如图一所示，<br><img src="https://upload-images.jianshu.io/upload_images/1741029-1348aa9354dbe2ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一"></p>
<p>还可以为每一行或列的距离起个名字，比如：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">  grid-template-columns: <span class="comment">[first]</span> 40px <span class="comment">[line2]</span> 50px <span class="comment">[line3]</span> auto <span class="comment">[col4-start]</span> 50px <span class="comment">[five]</span> 40px <span class="comment">[end]</span>;</span><br><span class="line">  grid-template-rows: <span class="comment">[row1-start]</span> 25% <span class="comment">[row1-end]</span> 100px <span class="comment">[third-line]</span> auto <span class="comment">[last-line]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1741029-94476deb2dcede4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二"></p>
<p>还可以有多个名字，主要是为了在<code>Items</code>相关的地方方便使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25%</span> [row1-end row2-start] <span class="number">25%</span> [row2-end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>多个值一致的话可以使用<code>repeat()</code>函数来代替多次重复赋值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 20px [col-start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就相当于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多行拥有相同的名字，可以使用名字和数字的语法简化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: col-start <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fr-单位"><a href="#fr-单位" class="headerlink" title="fr 单位"></a>fr 单位</h3><p><code>fr</code>单位允许将<code>track</code>的尺寸作为一个<code>fraction</code>设置容器剩余可用空间，例如，如下代码会设置每一个项目的宽为容器三分之一的宽度：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fr</code>所占宽度不包括已分配固定值的宽度，如下，分配给三个<code>fr</code>单位的宽度不包括<code>50px</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p>使用<code>grid-area</code>属性首先定义一个<code>grid</code>模板，重复这些<code>grid</code>区域使其变成一个个<code>cells</code>，<code>.</code>代表一个空的<code>cell</code>，语法自身提供了<code>grid</code>结构的可视化。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"&lt;grid-area-name&gt; | . | none | ..."</span></span><br><span class="line">    <span class="string">"..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;grid-area-name&gt;</code> 使用<code>grid-area</code>指定区域的名字</li>
<li><code>.</code> 一个空的<code>grid cell</code></li>
<li><code>none</code> 没有<code>grid areas</code>被定义</li>
</ul>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-c</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-d</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: auto;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header header"</span></span><br><span class="line">    <span class="string">"main main . sidebar"</span></span><br><span class="line">    <span class="string">"footer footer footer footer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码生成了一个三行四列的<code>grid</code>容器，第一行为头部区域组成，中间由三部分组成，一部分是<code>main</code>区域，一部分是空<code>cell</code>，另一部分是<code>sidebar</code>，最后一行全是<code>footer</code>，如图：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-54a2979e02ee63b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三"><br>每一行都需要有相同数量的<code>cell</code>，只要空<code>cell</code>之间没有空间，就可以设置任意个<code>.</code> 空<code>cell</code>。<br>注意，如果你的<code>grid</code>区域的名字是<code>foo</code>，其起始行和最终行会被自动命名为<code>foo-start</code>和 <code>foo-end</code>，也就是说一些行可以有多个名字。</p>
<h3 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h3><p> <code>grid-template-rows</code>、 <code>grid-template-columns</code>和 <code>grid-template-areas</code>在同一个声明里的缩写。</p>
<ul>
<li><code>none</code> 设置三个属性为其原始值</li>
<li><code>&lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;</code> 设置<code>grid-template-rows</code>和<code>grid-template-columns</code>为指定值，并设置<code>grid-template-areas</code>为<code>none</code>。<br>例如：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  grid-<span class="keyword">template</span>:</span><br><span class="line">    [row1-start] <span class="string">"header header header"</span> <span class="number">25</span>px [row1-<span class="built_in">end</span>]</span><br><span class="line">    [row2-start] <span class="string">"footer footer footer"</span> <span class="number">25</span>px [row2-<span class="built_in">end</span>]</span><br><span class="line">    / <span class="keyword">auto</span> <span class="number">50</span>px <span class="keyword">auto</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上等价于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25px</span> [row1-end row2-start] <span class="number">25px</span> [row2-end];</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header"</span> </span><br><span class="line">    <span class="string">"footer footer footer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>！因为<code>grid-template</code>不会重置隐式<code>grid</code>属性（<code>grid-auto-columns</code>，<code>grid-auto-rows</code>， <code>grid-auto-flow</code>），也许正是大部分情况下我们所不想要的，所以建议使用<code>grid</code>属性而不是<code>grid-template</code>属性。</li>
</ul>
<h3 id="grid-column-gap和grid-row-gap"><a href="#grid-column-gap和grid-row-gap" class="headerlink" title="grid-column-gap和grid-row-gap"></a>grid-column-gap和grid-row-gap</h3><p>可以认为就是设置行和列之间的间距：</p>
<pre><code>.container {
  grid-column-gap: &lt;line-size&gt;;
  grid-row-gap: &lt;line-size&gt;;
}</code></pre><p>例如：</p>
<pre><code>.container {
  grid-template-columns: 100px 50px 100px;
  grid-template-rows: 80px auto 80px; 
  grid-column-gap: 10px;
  grid-row-gap: 15px;
}</code></pre><p>！只能设置<code>item</code>之间的间距。不能设置外部边距。<br><img src="https://upload-images.jianshu.io/upload_images/1741029-b46294b5451c2c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图四"><br>！注意：<code>grid-</code>将会被移除，即<code>grid-column-gap</code>和<code>grid-row-gap</code>将会被重命名为<code>column-gap</code>和<code>row-gap</code>，目前已经支持的浏览器有<code>Chrome 68+</code>，<code>Safari 11.2 Release 50+</code> 和<code>Opera 54+</code>。</p>
<h3 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h3><p><code>grid-column-gap</code>和<code>grid-row-gap</code>的简写版。</p>
<pre><code>.container {
  grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;
}</code></pre><p>例如：</p>
<pre><code>.container {
  grid-template-columns: 100px 50px 100px;
  grid-template-rows: 80px auto 80px; 
  grid-gap: 15px 10px;
}</code></pre><p>如果<code>grid-row-gap</code>或者<code>grid-column-gap</code>值没有被指定，即只给了一个值，二者皆使用该值。同样，<code>grid-</code>前缀也会被移除并重命名为<code>gap</code>。</p>
<h3 id="justify-items-水平对齐"><a href="#justify-items-水平对齐" class="headerlink" title="justify-items 水平对齐"></a>justify-items 水平对齐</h3><pre><code>.container {
  justify-items: start | end | center | stretch;
}</code></pre><ul>
<li><code>start</code> 相当于左对齐</li>
<li><code>end</code> 相当于右对齐</li>
<li><code>center</code> 相当于居中对齐</li>
<li><code>stretch</code> 相当于占满整个<code>cell</code><br>例子：<pre><code>.container {
justify-items: start;
}</code></pre><img src="https://upload-images.jianshu.io/upload_images/1741029-33118e7b74756863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左对齐"></li>
</ul>
<pre><code>.container {
  justify-items: end;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-11eeaaa01e4c9f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右对其"></p>
<pre><code>.container {
  justify-items: center ;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-c8c54173e304129e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="居中对其"></p>
<pre><code>.container {
  justify-items: stretch;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-0cc3dceb3fdf1039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="占满空间"></p>
<h3 id="align-items-垂直对齐，与justify-items对应"><a href="#align-items-垂直对齐，与justify-items对应" class="headerlink" title="align-items 垂直对齐，与justify-items对应"></a>align-items 垂直对齐，与justify-items对应</h3><pre><code>.container {
  align-items: start | end | center | stretch;
}</code></pre><h3 id="place-items"><a href="#place-items" class="headerlink" title="place-items"></a>place-items</h3><p><code>place-items</code>同时设置<code>align-items</code>和<code>justify-items</code>的值，类似地，如果只给了一个值，二者皆使用该值。</p>
<ul>
<li><code>&lt;align-items&gt; / &lt;justify-items&gt;</code> 第一个值为<code>align-items</code>，第二个为<code>justify-items</code>，<code>/</code>隔开。</li>
</ul>
<h3 id="justify-content，整体内容水平分布"><a href="#justify-content，整体内容水平分布" class="headerlink" title="justify-content，整体内容水平分布"></a>justify-content，整体内容水平分布</h3><pre><code>.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}</code></pre><ul>
<li><code>start</code> 容器整体内容左对齐</li>
<li><code>end</code> 容器整体内容右对齐</li>
<li><code>center</code> 容器整体内容居中对齐</li>
<li><code>stretch</code> 容器整体内容占满</li>
<li><code>space-around</code> 内容左右均分空间对齐</li>
<li><code>space-between</code> 除了最左和最右两个最外侧没有空间，其余均分剩余空间对齐</li>
<li><code>space-evenly</code> 所有项目均分对齐</li>
</ul>
<pre><code>.container {
  justify-content: start;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-9d0d51d66134570c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体左对齐"></p>
<pre><code>.container {
  justify-content: end; 
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-8b1e2723140638cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体右对齐"></p>
<pre><code>.container {
  justify-content: center;  
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-42217e1fee81d0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体居中对齐"></p>
<pre><code>.container {
  justify-content: stretch; 
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-ad675954b395bee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体占满容器空间"></p>
<pre><code>.container {
  justify-content: space-around;  
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-b8563bfa9bf07c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左右皆有间距"></p>
<pre><code>.container {
  justify-content: space-between; 
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-118d5c8cffd9ebab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最外侧没有间距"></p>
<pre><code>.container {
  justify-content: space-evenly;  
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-e58d57a51c421b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体等分间距"></p>
<h3 id="align-content，整体内容垂直分布"><a href="#align-content，整体内容垂直分布" class="headerlink" title="align-content，整体内容垂直分布"></a>align-content，整体内容垂直分布</h3><p>与<code>justify-content</code>类似</p>
<pre><code>.container {
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}</code></pre><h3 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h3><p><code>place-content</code>同时设置<code>align-content</code>和<code>justify-content</code>的值，类似地，如果只给了一个值，二者皆使用该值。</p>
<ul>
<li><code>&lt;align-content&gt; / &lt;justify-content&gt;</code> 第一个值为<code>align-content</code>，第二个为<code>justify-content</code>，<code>/</code>隔开。</li>
</ul>
<p>除了<code>Edge</code>浏览器，其他主流浏览器都支持<code>place-content</code>缩写属性。</p>
<h3 id="grid-auto-columns和grid-auto-rows"><a href="#grid-auto-columns和grid-auto-rows" class="headerlink" title="grid-auto-columns和grid-auto-rows"></a>grid-auto-columns和grid-auto-rows</h3><p>设置任意自动生成的<code>grid tracks</code>（又被叫做<code>implicit grid tracks</code>）的尺寸，<code>Implicit tracks</code>在<code>grid items</code>的数量多于<code>cells</code>数量的时候被创建出来，或者当一个<code>grid item</code>被放在一个<code>explicit grid</code>外部的时候。</p>
<pre><code>.container {
  grid-auto-columns: &lt;track-size&gt; ...;
  grid-auto-rows: &lt;track-size&gt; ...;
}</code></pre><ul>
<li><strong><track-size></track-size></strong> 长度、百分比或者<code>fr</code></li>
</ul>
<p>为了描述<code>implicit grid tracks</code>怎样被创建，考虑以下代码：</p>
<pre><code>.container {
  grid-template-columns: 60px 60px;
  grid-template-rows: 90px 90px;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-67c6d9e668314e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>如图所示，一个<code>2x2</code>的<code>grid</code>布局被创建出来，但是想象一下使用<code>grid-column</code>和<code>grid-row</code> 来进行如下布局：</p>
<pre><code>.item-a {
  grid-column: 1 / 2;
  grid-row: 2 / 3;
}
.item-b {
  grid-column: 5 / 6;
  grid-row: 2 / 3;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-470d5386ca060153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>我们设置了<code>.item-b</code>从第五列开始到第六列结束，但是我们并没有定义第五列和第六列，只有两列，这个时候，宽度为零的<code>implicit tracks</code>就会被创建出来填满这些<code>gap</code>，此时就可以使用<code>grid-auto-columns</code>和<code>grid-auto-rows</code>来设置这些<code>implicit tracks</code>的宽度，如：</p>
<pre><code>.container {
  grid-auto-columns: 60px;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-5caea9963bf657ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p>如果你有没有显示地布局在<code>grid</code>上的<code>grid items</code>，自动布局算法就会自动地将这<code>grid items</code>放进去，这个属性控制着自动布局算法怎样工作。</p>
<pre><code>.container {
  grid-auto-flow: row | column | row dense | column dense;
}</code></pre><ul>
<li><code>row</code> 告诉自动布局算法依次填满每一行，有必要的话可以添加新的行</li>
<li><code>column</code> 告诉自动布局算法依次填满每一列，有必要的话可以添加新的列</li>
<li><code>dense</code> 告诉自动布局算法如果出现比较小的<code>item</code>的话尝试填满之前剩余空间</li>
</ul>
<p>例子：</p>
<pre><code>&lt;section class=&quot;container&quot;&gt;
  &lt;div class=&quot;item-a&quot;&gt;item-a&lt;/div&gt;
  &lt;div class=&quot;item-b&quot;&gt;item-b&lt;/div&gt;
  &lt;div class=&quot;item-c&quot;&gt;item-c&lt;/div&gt;
  &lt;div class=&quot;item-d&quot;&gt;item-d&lt;/div&gt;
  &lt;div class=&quot;item-e&quot;&gt;item-e&lt;/div&gt;
&lt;/section&gt;

.container {
  display: grid;
  grid-template-columns: 60px 60px 60px 60px 60px;
  grid-template-rows: 30px 30px;
  grid-auto-flow: row; // 优先排满行
}

//指定item-a和item-e占两行
.item-a {
  grid-column: 1;
  grid-row: 1 / 3;
}
.item-e {
  grid-column: 5;
  grid-row: 1 / 3;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-8a5e076c0310b0f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优先排满行"></p>
<p>可以把<code>grid-auto-flow</code>的值设置成<code>column</code>：</p>
<pre><code>.container {
  display: grid;
  grid-template-columns: 60px 60px 60px 60px 60px;
  grid-template-rows: 30px 30px;
  grid-auto-flow: column;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-c5c9f71733a8437c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="优先排满列"></p>
<h3 id="grid"><a href="#grid" class="headerlink" title="grid"></a>grid</h3><p><code>grid-template-rows</code>+ <code>grid-template-columns</code>+ <code>grid-template-areas</code>,+<code>grid-auto-rows</code>+<code>grid-auto-columns</code>+<code>grid-auto-flow</code>属性的缩写，可以在同一个<code>grid</code>属性里设置显示（<code>explicit</code>）或者隐式（<code>implicit</code>）<code>grid</code>。</p>
<ul>
<li><code>none</code> 设置其所有子属性为原始值</li>
<li><code>&lt;grid-template&gt;</code> 相当于<code>grid-template</code>缩写</li>
<li><code>&lt;grid-template-rows&gt; / [ auto-flow &amp;&amp; dense? ] &lt;grid-auto-columns&gt;?</code> 设置<code>&lt;grid-template-rows&gt;</code>为指定值，如果<code>auto-flow</code>被设置了，<code>grid-auto-flow</code>的值被设置成<code>column</code>，如果设置成<code>dense</code>，自动布局算法使用<code>dense</code>填充算法，如果<code>grid-auto-columns</code>被省略了，将会被自动设置成<code>auto</code>。</li>
<li><code>[ auto-flow &amp;&amp; dense? ] &lt;grid-auto-rows&gt;? / &lt;grid-template-columns&gt;</code> 与上一条类似<code>auto-flow</code>对应<code>grid-auto-flow</code>的值被设置成<code>row</code>。</li>
</ul>
<p>例子：</p>
<p>以下两块代码是等价的：</p>
<pre><code>.container {
    grid: 100px 300px / 3fr 1fr;
  }</code></pre><pre><code>.container {
    grid-template-rows: 100px 300px;
    grid-template-columns: 3fr 1fr;
  }</code></pre><p>以下也是：</p>
<pre><code>.container {
    grid: auto-flow / 200px 1fr;
  }</code></pre><pre><code>.container {
    grid-auto-flow: row;
    grid-template-columns: 200px 1fr;
  }</code></pre><p>以下也是：</p>
<pre><code>.container {
    grid: auto-flow dense 100px / 1fr 2fr;
  }</code></pre><pre><code>.container {
    grid-auto-flow: row dense;
    grid-auto-rows: 100px;
    grid-template-columns: 1fr 2fr;
  }</code></pre><p>以下还是：</p>
<pre><code>.container {
    grid: 100px 300px / auto-flow 200px;
  }</code></pre><pre><code>.container {
    grid-template-rows: 100px 300px;
    grid-auto-flow: column;
    grid-auto-columns: 200px;
  }</code></pre><p>还可以使用更复杂的语法来一次性设置多个值，使用起来十分方便，但是十分复杂：</p>
<pre><code>.container {
    grid: [row1-start] &quot;header header header&quot; 1fr [row1-end]
          [row2-start] &quot;footer footer footer&quot; 25px [row2-end]
          / auto 50px auto;
  }</code></pre><p>上述代码等价于：</p>
<pre><code>.container {
    grid-template-areas: 
      &quot;header header header&quot;
      &quot;footer footer footer&quot;;
    grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end];
    grid-template-columns: auto 50px auto;    
  }</code></pre><h2 id="Grid-Items"><a href="#Grid-Items" class="headerlink" title="Grid Items"></a>Grid Items</h2><p>！注意，<code>float</code>，<code>display: inline-block</code>，<code>display: table-cell</code>， <code>vertical-align</code> 和<code>column-*</code> 属性对<code>grid item</code>没有影响。</p>
<h3 id="grid-column-start、grid-column-end、grid-row-start、grid-row-end"><a href="#grid-column-start、grid-column-end、grid-row-start、grid-row-end" class="headerlink" title="grid-column-start、grid-column-end、grid-row-start、grid-row-end"></a>grid-column-start、grid-column-end、grid-row-start、grid-row-end</h3><pre><code>.item {
  grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;
  grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;
  grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;
  grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto;
}</code></pre><ul>
<li><code>&lt;line&gt;</code> 可以是一个<code>grid line</code>的数字序号或者名字</li>
<li><code>span &lt;number&gt;</code> 项目会占满所提供的<code>grid tracks</code>的序号</li>
<li><code>span &lt;name&gt;</code> 项目会占满所提供的<code>grid tracks</code>的名字</li>
<li><code>auto</code> 自动填充</li>
</ul>
<p>例如：</p>
<pre><code>.item-a {
  grid-column-start: 2;
  grid-column-end: five;
  grid-row-start: row1-start;
  grid-row-end: 3;
}</code></pre><p>其布局效果如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-d030c44eddd9aa43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图五"></p>
<pre><code>.item-b {
  grid-column-start: 1;
  grid-column-end: span col4-start;
  grid-row-start: 2;
  grid-row-end: span 2;
}</code></pre><p>其布局效果如下所示：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-7c0afc52db9432d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图六"></p>
<p>！如果没有指定<code>grid-column-end</code>或者<code>grid-row-end</code>，项目会默认自动跨越一个<code>track</code>的距离。项目之间可能会相互重叠，可以使用<code>z-index</code>来控制显示的顺序。</p>
<h3 id="grid-column和grid-row"><a href="#grid-column和grid-row" class="headerlink" title="grid-column和grid-row"></a>grid-column和grid-row</h3><p>分别是 <code>grid-column-start</code> + <code>grid-column-end</code>和<code>grid-row-start</code> + <code>grid-row-end</code>的缩写。</p>
<pre><code>.item {
  grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;
  grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;;
}</code></pre><ul>
<li><code>&lt;start-line&gt; / &lt;end-line&gt;</code> 所接收的值和前面一致，<code>start</code>和<code>end</code>的值用<code>/</code>隔开。</li>
</ul>
<p>例子：</p>
<pre><code>.item-c {
  grid-column: 3 / span 2;
  grid-row: third-line / 4;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-f6fae30a7b487b9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图七"><br>！如果没有<code>&lt;end-line&gt;</code>值，会默认跨越一个<code>track</code>。</p>
<h3 id="grid-area"><a href="#grid-area" class="headerlink" title="grid-area"></a>grid-area</h3><p>给项目起个名字让使用<code>grid-template-areas</code>属性创建的模板可以调用，另外，这个属性还可以用作<code>grid-row-start</code> + <code>grid-column-start</code> + <code>grid-row-end</code>+<code>grid-column-end</code>的缩写。</p>
<pre><code>.item {
  grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;
}</code></pre><ul>
<li><code>&lt;name&gt;</code> 任意名字</li>
<li><code>&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;</code> 可以是数字或者名字</li>
</ul>
<p>取个名：</p>
<pre><code>.item-d {
  grid-area: header;
}</code></pre><p><code>grid-row-start</code> + <code>grid-column-start</code> + <code>grid-row-end</code>+<code>grid-column-end</code>的缩写：</p>
<pre><code>.item-d {
  grid-area: 1 / col4-start / last-line / 6;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-90596d745fc470c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图八"></p>
<h3 id="justify-self，水平方向"><a href="#justify-self，水平方向" class="headerlink" title="justify-self，水平方向"></a>justify-self，水平方向</h3><p>在一个<code>cell</code>当中对齐一个<code>grid item</code></p>
<pre><code>.item {
  justify-self: start | end | center | stretch;
}</code></pre><pre><code>.item-a {
  justify-self: start;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-554879618c2a6d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左对齐"></p>
<pre><code>.item-a {
  justify-self: end;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-e11e9f933088bb44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右对齐"></p>
<pre><code>.item-a {
  justify-self: center ;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-305ada4fe264ac18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="居中对齐"></p>
<pre><code>.item-a {
  justify-self: stretch;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-f08359120f1fbe5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="填满整个内容"></p>
<h3 id="align-self，垂直方向"><a href="#align-self，垂直方向" class="headerlink" title="align-self，垂直方向"></a>align-self，垂直方向</h3><p>与<code>justify-self</code>类似。</p>
<pre><code>.item {
  align-self: start | end | center | stretch;
}</code></pre><h3 id="place-self"><a href="#place-self" class="headerlink" title="place-self"></a>place-self</h3><p><code>align-self</code> 和<code>justify-self</code>的缩写。</p>
<ul>
<li><code>auto</code> 默认对齐方式</li>
<li><code>&lt;align-self&gt; / &lt;justify-self&gt;</code> 垂直/水平</li>
</ul>
<p>除了<code>Edge</code>浏览器，其他主流浏览器都支持<code>place-self</code>缩写属性。</p>
<h1 id="五、参考（原文）"><a href="#五、参考（原文）" class="headerlink" title="五、参考（原文）"></a>五、参考（原文）</h1><p><a href="https://css-tricks.com/snippets/css/complete-guide-grid" target="_blank" rel="noopener">https://css-tricks.com/snippets/css/complete-guide-grid</a></p>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS Grid</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之原生AJAX的请求过程具体实现</title>
    <url>/2019/10/28/JS%E4%B9%8B%E5%8E%9F%E7%94%9FAJAX%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、AJAX的请求大致过程"><a href="#一、AJAX的请求大致过程" class="headerlink" title="一、AJAX的请求大致过程"></a>一、AJAX的请求大致过程</h1><ul>
<li>创建一个异步调用<code>XMLHttpRequest</code>对象 </li>
<li>打开一个新的<code>HTTP</code>请求，并指定该<code>HTTP</code>请求的方法、<code>URL</code>及验证信息，设置响应<code>HTTP</code>请求状态变化的函数</li>
<li>发送<code>HTTP</code>请求</li>
<li>获取异步调用返回的数据</li>
<li>使用JavaScript和DOM实现局部刷新</li>
</ul>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p>先创建一个兼容各个平台的<code>XMLHttpRequest</code>对象 </p>
<pre><code>function getXHR(){
  var xhr = null;
  if(window.XMLHttpRequest) {// 兼容 IE7+, Firefox, Chrome, Opera, Safari
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);// 即MSXML3
    } catch (e) {
      try {
        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);// // 兼容 IE6, IE5，API很老，不建议使用
      } catch (e) {
        alert(&quot;您的浏览器不支持AJAX.&quot;);
      }
    }
  }
  return xhr;
}</code></pre><a id="more"></a>

<p>一个完整的AJAX实现过程：</p>
<pre><code>var xhr = getXHR(); // 创建异步调用对象 
xhr.open(&apos;GET/POST&apos;, url/file, true);  //设置请求方式，url，以及是否异步
xhr.onreadystatechange = function() {   //设置回调监听函数
   if(xhr.readyState==4){ //表示后台处理完成
        if(xhr.status==200){ //表示处理结果是成功的
            var data = xhr.responseText; //获取成功的返回值
             console.log(data);
   }
};
xhr.onerror = function() {
  console.log(&quot;Something is wrong.&quot;);
};
 xhr.send(); </code></pre><h1 id="三、状态码"><a href="#三、状态码" class="headerlink" title="三、状态码"></a>三、状态码</h1><p><code>readyState</code>一共有5中请求状态，从0 到 4 分别表示：</p>
<pre><code>0: 请求未初始化
1: 服务器连接已建立
2: 请求已接收
3: 请求处理中
4: 请求已完成，且响应已就绪</code></pre><p><code>HTTP</code>响应状态码，常见的表示：</p>
<pre><code>200:  成功
304：未修改，该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。
403：（禁止）服务器拒绝请求。
404：（未找到）服务器找不到请求的网页。
500：（服务器内部错误）服务器遇到错误，无法完成请求。</code></pre><h1 id="四、注意点"><a href="#四、注意点" class="headerlink" title="四、注意点"></a>四、注意点</h1><h3 id="1-xhr-open的参数需熟记："><a href="#1-xhr-open的参数需熟记：" class="headerlink" title="1. xhr.open的参数需熟记："></a>1. <code>xhr.open</code>的参数需熟记：</h3><ul>
<li>method：请求的方法类型，GET 或 POST</li>
<li>url：文件在服务器上的位置，相对位置或绝对位置</li>
<li>async：true 或 false</li>
</ul>
<h3 id="2-post请求与get请求的不同之处"><a href="#2-post请求与get请求的不同之处" class="headerlink" title="2. post请求与get请求的不同之处"></a>2. post请求与get请求的不同之处</h3><p><code>send(string)</code>方法<code>post</code>请求时才需要使用字符串参数，否则不用带参数。</p>
<h3 id="3-post请求一定要设置请求头的格式内容"><a href="#3-post请求一定要设置请求头的格式内容" class="headerlink" title="3. post请求一定要设置请求头的格式内容"></a>3. post请求一定要设置请求头的格式内容</h3><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">"<span class="keyword">POST</span>"</span>, <span class="string">"ajax_test.html"</span>, true);  </span><br><span class="line">xhr.setRequestHeader(<span class="string">"content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);  </span><br><span class="line">xhr.send(<span class="string">"name=Shaw&amp;age=24"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-服务器响应数据格式"><a href="#4-服务器响应数据格式" class="headerlink" title="4. 服务器响应数据格式"></a>4. 服务器响应数据格式</h3><ul>
<li>responseText 字符串形式的响应数据</li>
<li>responseXML XML形式的响应数据</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/5bb470295188255c5e66f88f#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5bb470295188255c5e66f88f#heading-0</a><br><a href="https://www.cnblogs.com/jianxian/p/9069804.html" target="_blank" rel="noopener">https://www.cnblogs.com/jianxian/p/9069804.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之typeof和instanceof方法具体实现</title>
    <url>/2019/10/27/JS%E4%B9%8Btypeof%E5%92%8Cinstanceof%E6%96%B9%E6%B3%95%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、typeof方法的作用"><a href="#一、typeof方法的作用" class="headerlink" title="一、typeof方法的作用"></a>一、typeof方法的作用</h1><ul>
<li>判断变量类型</li>
</ul>
<pre><code>typeof 1 //&quot;number&quot;
typeof &apos;1&apos; //&quot;string&quot;
typeof {} //&quot;object&quot;
typeof true //&quot;boolean&quot;
typeof undefined // &quot;undefined&quot;
typeof null //&quot;object&quot; #bug
typeof Symbol //&quot;function&quot;
typeof Symbol(1) //&quot;symbol&quot;</code></pre><a id="more"></a>

<h1 id="二、typeof方法的具体实现"><a href="#二、typeof方法的具体实现" class="headerlink" title="二、typeof方法的具体实现"></a>二、typeof方法的具体实现</h1><pre><code>if (JSVAL_IS_VOID(v)) {  // (1)
    type = JSTYPE_VOID;
} else if (JSVAL_IS_OBJECT(v)) {  // (2)
    obj = JSVAL_TO_OBJECT(v);
    if (obj &amp;&amp;
        (ops = obj-&gt;map-&gt;ops,
            ops == &amp;js_ObjectOps
            ? (clasp = OBJ_GET_CLASS(cx, obj),
            clasp-&gt;call || clasp == &amp;js_FunctionClass) // (3,4)
            : ops-&gt;call != 0)) {  // (3)
        type = JSTYPE_FUNCTION;
    } else {
        type = JSTYPE_OBJECT;
    }
} else if (JSVAL_IS_NUMBER(v)) {
    type = JSTYPE_NUMBER;
} else if (JSVAL_IS_STRING(v)) {
    type = JSTYPE_STRING;
} else if (JSVAL_IS_BOOLEAN(v)) {
    type = JSTYPE_BOOLEAN;
}</code></pre><p>根据 <code>type tags</code> 的信息，低位是 <code>000</code>，因此 <code>null</code> 被判断成了一个对象。这就是为什么 <code>typeof null</code> 的返回值是 <code>object</code>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null" target="_blank" rel="noopener">MDN</a> 有简单的描述解释了原因，而且以后也不会修复这个 <code>bug</code> ，因为修复这个 <code>bug</code> 会带来更多的问题。</p>
<h1 id="三、更准确的类型判断方法"><a href="#三、更准确的类型判断方法" class="headerlink" title="三、更准确的类型判断方法"></a>三、更准确的类型判断方法</h1><p>由于 <code>typeof</code>存在 <code>null</code> 的类型为 <code>object</code>，所以可以用另外一种更加准确的方法来判断基本类型，那就是<code>Object.prototype.toString</code> ：</p>
<pre><code>Object.prototype.toString.call(2) // &quot;[object Number]&quot;

Object.prototype.toString.call(&apos;hello&apos;) // &quot;[object String]&quot;

Object.prototype.toString.call({hello:&apos;hello&apos;}) // &quot;[object Object]&quot;

Object.prototype.toString.call([2,&apos;hello&apos;]) // &quot;[object Array]&quot;

Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;

Object.prototype.toString.call(() =&gt; {}) // &quot;[object Function]&quot;

Object.prototype.toString.call(null) // &quot;[object Null]&quot;

Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;

Object.prototype.toString.call(Symbol(2)) // &quot;[object Symbol]&quot;</code></pre><h1 id="四、instanceof方法的作用"><a href="#四、instanceof方法的作用" class="headerlink" title="四、instanceof方法的作用"></a>四、instanceof方法的作用</h1><ul>
<li>判断一个引用是否属于某个构造函数</li>
<li>判断继承关系中一个实例是否属于其父类<br>比如：</li>
</ul>
<pre><code>const Animal = function(type) {
  this.type = type;
}
const cat= new Animal(&apos;cat&apos;);
console.log(cat instanceof Animal);  //true
console.log(cat instanceof Object); //true</code></pre><h1 id="五、如何实现一个instanceof方法"><a href="#五、如何实现一个instanceof方法" class="headerlink" title="五、如何实现一个instanceof方法"></a>五、如何实现一个instanceof方法</h1><pre><code>function myInstanceof(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右边 prototype的值
    leftVaule = leftVaule.__proto__; // 取左边__proto__值
    while (true) {
        if (leftVaule === null) { //如果左边的__proto__值为null，返回false
            return false;    
        }
        if (leftVaule === rightProto) { //如果左边的__proto__值等于右边prototype的值，返回true
            return true;    
        } 
        leftVaule = leftVaule.__proto__ ; //以上都不满足，取上一层原型继续循环，直到没取到为null
    }
}</code></pre><p>其实说白了就是在实例的原型链上面去找，看到底有没有找到右边的原型，找到了就返回 <code>true</code>，没找到或者左边不存在原型链，就返回 <code>false</code>。<br>例子：</p>
<pre><code>function Foo() {
}

myInstanceof(Object, Object) // true
myInstanceof(Function , Function)  // true
myInstanceof(Function , Object ) // true
myInstanceof(Foo, Foo) // false
myInstanceof(Foo, Object) // true
myInstanceof(Foo, Function) // true</code></pre><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p><code>typeof</code> 和 <code>instanceof</code> 可以用来判断一些基本类型及原型链的实例与原型之间的关系，但是使用的时候也需要很小心，因为一些潜在的问题会导致意外的问题出现，比如数组的判断：</p>
<pre><code>[1,2] instanceof Array //true
[1,2] instanceof Object //true</code></pre><p>这是因为</p>
<pre><code>Array instanceof  Object //true</code></pre><p>可能这并不是我们想要的结果，所以可以使用更加准确的判断方法 <code>Object.prototype.toString.call</code>：</p>
<pre><code>Object.prototype.toString.call( [1,2,3] ) //&quot;[object Array]&quot;</code></pre><p>此外，<code>instanceof</code> 方法的具体实现需熟练掌握。</p>
<h1 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h1><p><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">https://juejin.im/post/5b0b9b9051882515773ae714</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript typeof instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title>前端框架路由实现的Hash和History两种模式的区别</title>
    <url>/2019/10/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E7%9A%84Hash%E5%92%8CHistory%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-9e5d1063264044c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hash vs History"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>之前面试的时候就有准备过前端框架中两种路由实现方式及区别，但是当时没专门下功夫去深入了解，就在网上搜了下别人总结的临时抱了下佛脚。但是事实证明，出来混，总是要还的，在后来的面试中又遇到了，而且这次问得更加深入，仅仅靠死记硬背来的知识总是遗忘得很快，网上别人总结的东西终归还是别人的，鉴于网上别人总结的内容有点杂乱无章，还是决定自己在此总结记录一番，以加深印象。</li>
</ul>
<h1 id="一、何为前端路由"><a href="#一、何为前端路由" class="headerlink" title="一、何为前端路由"></a>一、何为前端路由</h1><ul>
<li>路由的概念来自于服务器端，在SPA（单页应用）中，路由描述的是URL到函数的映射关系，即在浏览器中输入一个URL，相应的控制器会对提交的请求进行解析，然后进行路由匹配，找到对应的模块和函数进行执行。</li>
</ul>
<h1 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h1><ul>
<li>实现的两个核心问题是如何检测路由变化和如何改变URL而不刷新页面，通常有两种实现模式，一种是Hash模式，一种是History模式。</li>
</ul>
<a id="more"></a>

<h1 id="三、Hash模式"><a href="#三、Hash模式" class="headerlink" title="三、Hash模式"></a>三、Hash模式</h1><ul>
<li>早期的前端路由的实现就是基于<code>location.hash</code>来实现的，<code>location.hash</code>的值就是URL中#后面的内容<br>其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。</li>
<li>使用<code>hashchange</code>事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 <code>hashchange</code> 事件：浏览器前进后退改变 URL、<code>&lt;a&gt;</code>标签改变 URL、window.location改变URL。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li>
<li>只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误</li>
<li>hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换</li>
<li>会覆盖锚点定位元素的功能</li>
<li>不太美观，#后面传输的数据复杂的话会出现问题</li>
</ul>
<h1 id="四、History模式"><a href="#四、History模式" class="headerlink" title="四、History模式"></a>四、History模式</h1><ul>
<li>history 提供了 <code>pushState</code> 和 <code>replaceState</code> 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新</li>
<li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li>
<li><code>pushState(state, title, url)</code> 和 <code>replaceState(state, title, url)</code>都可以接受三个相同的参数：</li>
<li>state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取<ul>
<li>title：标题，基本没用，一般传 null</li>
</ul>
</li>
<li>url：设定新的历史记录的 url，新的 url 与当前 url 的 origin 必须是一样的，否则会抛错，url可以是绝对路径，也可以是相对路径。</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>使用简单，比较美观</li>
<li><code>pushState()</code>设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li>
<li><code>pushState()</code>设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li>
<li><code>pushState()</code>可以通过<code>stateObject</code>参数添加任意类型的数据到记录中，而hash只能添加短字符串</li>
<li><code>pushState()</code>可额外设置title属性供后续使用</li>
<li>前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li>
<li>由于History API的缘故，低版本浏览器有兼容行问题</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/d2aa8fb951e4" target="_blank" rel="noopener">https://www.jianshu.com/p/d2aa8fb951e4</a></li>
<li><a href="https://blog.csdn.net/Benjamin920813/article/details/82764664" target="_blank" rel="noopener">https://blog.csdn.net/Benjamin920813/article/details/82764664</a></li>
<li><a href="https://www.cnblogs.com/lguow/p/10921564.html" target="_blank" rel="noopener">https://www.cnblogs.com/lguow/p/10921564.html</a></li>
<li><a href="https://www.cnblogs.com/funny-code123/p/9599793.html" target="_blank" rel="noopener">https://www.cnblogs.com/funny-code123/p/9599793.html</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 前端 路由 Angular Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JavaScript中卷-读书笔记</title>
    <url>/2019/10/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E4%B8%AD%E5%8D%B7/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-8c92a4538cc134eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JavaScript"></p>
<h1 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a>基本类型值</h1><ul>
<li><p>有一个坑常常被提到，[] + {}，{} +[]，它们返回不同的结果，分别是”[object Object]”，0。</p>
</li>
<li><p>if (a) { foo(); }可以写成a &amp;&amp; foo()a = b || “something” 和a &amp;&amp; b() 用到了“短路”机制。</p>
</li>
<li><p>== 允许在相等比较中进行强制类型转换，===不允许。</p>
</li>
<li><p>NaN 不等于NaN</p>
</li>
<li><p>+0 等于-0</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>我个人建议无论什么情况下都不要使== true 和 == false。</p>
</li>
<li><p>(1) 如果x 为null，y 为undefined，则结果为true。</p>
</li>
<li><p>(2) 如果x 为undefined，y 为null，则结果为true。</p>
<pre><code>&quot;0&quot; == null; // false
&quot;0&quot; == undefined; // false
&quot;0&quot; == false; // true -- 晕！
&quot;0&quot; == NaN; // false
&quot;0&quot; == 0; // true
&quot;0&quot; == &quot;&quot;; // false
false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true -- 晕！
false == &quot;&quot;; // true -- 晕！
false == []; // true -- 晕！
false == {}; // false

&quot;&quot; == null; // false
&quot;&quot; == undefined; // false
&quot;&quot; == NaN; // false
&quot;&quot; == 0; // true -- 晕！
&quot;&quot; == []; // true -- 晕！
&quot;&quot; == {}; // false
0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true -- 晕！
0 == {}; // false

&quot;0&quot; == false; // true -- 晕！
false == 0; // true -- 晕！
false == &quot;&quot;; // true -- 晕！
false == []; // true -- 晕！
&quot;&quot; == 0; // true -- 晕！
&quot;&quot; == []; // true -- 晕！
0 == []; // true -- 晕！</code></pre></li>
</ul>
<ul>
<li><p>[] == ![] // true</p>
</li>
<li><p>根据ToBoolean 规则，它会进行布尔值的显式强制类型转换（同时反转奇偶校验位）。所以[] == ![] 变成了[] == false。前面我们讲过false == []，最后的结果就顺理成章了。</p>
<p>  2 == [2]; // true<br>  “” == [null]; // true</p>
</li>
<li><p>如果两边的值中有true 或者false，千万不要使用==。</p>
</li>
<li><p>如果两边的值中有[]、”” 或者0，尽量不要使用==。</p>
</li>
<li><p>字符串常量中允许的最大字符数（并非只是针对字符串值）；</p>
</li>
<li><p>可以作为参数传递到函数中的数据大小（也称为栈大小，以字节为单位）；</p>
</li>
<li><p>函数声明中的参数个数；</p>
</li>
<li><p>未经优化的调用栈（例如递归）的最大层数，即函数调用链的最大长度；</p>
</li>
<li><p>JavaScript 程序以阻塞方式在浏览器中运行的最长时间（秒）；</p>
</li>
<li><p>变量名的最大长度。</p>
</li>
<li><p>对多数开发者来说，错误处理最自然的形式就是同步的try..catch 结构。遗憾的是，它只能是同步的，无法用于异步代码模式。</p>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li><p>传给Promise.all([ .. ]) 的数组中的值可以是Promise、thenable，甚至是立即值。就本质而言，列表中的每个值都会通过Promise.resolve(..) 过滤，以确保要等待的是一个真正的Promise，所以立即值会被规范化为为这个值构建的Promise。</p>
</li>
<li><p>与Promise.all([ .. ]) 类似，一旦有任何一个Promise 决议为完成，Promise.race([ .. ])就会完成；一旦有任何一个Promise 决议为拒绝，它就会拒绝。</p>
</li>
<li><p>Promise.race([ .. ]) 也接受单个数组参数。这个数组由一个或多个Promise、thenable 或立即值组成。要注意，永远不要递送空数组。</p>
<p>  p.then( fulfilled );<br>  p.then( fulfilled, rejected );<br>  p.catch( rejected ); // 或者p.then( null, rejected )</p>
</li>
<li><p>对Promise.all([ .. ]) 来说，只有传入的所有promise 都完成，返回promise 才能完成。如果有任何promise被拒绝，返回的主promise就立即会被拒绝（抛弃任何其他promise 的结果）。</p>
</li>
<li><p>当心！若向Promise.all([ .. ]) 传入空数组，它会立即完成，但Promise.race([ .. ]) 会挂住，且永远不会决议。</p>
<pre><code>var p1 = Promise.resolve( 42 );
var p2 = Promise.resolve( &quot;Hello World&quot; );
var p3 = Promise.reject( &quot;Oops&quot; );
Promise.race( [p1,p2,p3] )
.then( function(msg){
console.log( msg ); // 42
} );
Promise.all( [p1,p2,p3] )
.catch( function(err){
console.error( err ); // &quot;Oops&quot;
} );
Promise.all( [p1,p2] )
.then( function(msgs){
console.log( msgs ); // [42,&quot;Hello World&quot;]
} );</code></pre></li>
<li><p>Promise 局限性:</p>
</li>
<li><p>顺序错误处理，如果没有错误处理，错误会一直往下传递</p>
</li>
<li><p>单一值</p>
</li>
<li><p>单决议，Promise 只能被决议一次（完成或拒绝）</p>
</li>
<li><p>惯性，运动状态（使用回调的）的代码库会一直保持运动状态（使用回调的），直到受到一位聪明的、理解Promise 的开发者的作用。</p>
</li>
<li><p>无法取消，一旦创建了一个Promise 并为其注册了完成和/ 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。</p>
</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li><p>生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。<br>yield .. 和next(..) 这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统。<br>使用生成器的话，交替执行（甚至在语句当中！）显然是可能的。</p>
</li>
<li><p>生成器实现标准的迭代器接口:</p>
</li>
</ul>
<pre><code>var something = (function(){
var nextVal;
return {
// for..of循环需要
[Symbol.iterator]: function(){ return this; },
// 标准迭代器接口方法
next: function(){
if (nextVal === undefined) {
nextVal = 1;
}
else {
nextVal = (3 * nextVal) + 6;
}
return { done:false, value:nextVal };
}
};
})();

something.next().value; // 1
something.next().value; // 9
something.next().value; // 33
something.next().value; // 105</code></pre><ul>
<li><p>yield 委托的主要目的是代码组织，以达到与普通函数调用的对称。</p>
</li>
<li><p>生成器是ES6 的一个新的函数类型，它并不像普通函数那样总是运行到结束。取而代之的是，生成器可以在运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。</p>
</li>
<li><p>这种交替的暂停和恢复是合作性的而不是抢占式的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字yield 实现的。不过，只有控制生成器的迭代器具有恢复生成器的能力（通过next(..)）。</p>
</li>
<li><p>yield/next(..) 这一对不只是一种控制机制，实际上也是一种双向消息传递机制。yield .. 表达式本质上是暂停下来等待某个值，接下来的next(..) 调用会向被暂停的yield 表达式传回一个值（或者是隐式的undefined）。</p>
</li>
<li><p>在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步/ 顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字yield 的后面，把异步移动到控制生成器的迭代器的代码部分。</p>
</li>
<li><p>换句话说，生成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得大脑可以更自然地追踪代码，解决了基于回调的异步的两个关键缺陷之一。</p>
</li>
</ul>
<p>• 如果要比较的两个值的任意一个（即一边）可能是true 或者false 值，那么要避免使<br>用==，而使用===。<br>• 如果要比较的两个值中的任意一个可能是特定值（0、”” 或者[]——空数组），那么避<br>免使用==，而使用===。<br>• 在所有其他情况下，使用== 都是安全的。不仅仅只是安全而已，这在很多情况下也会<br>简化代码，提高代码的可读性。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Notes 你不知道的JavaScript中卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel 7.5新特性之动态引入和F#管道</title>
    <url>/2019/08/26/Babel7.5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5%E5%92%8CF%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-16b74fc4346ad169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Babel"></p>
<h1 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h1><ul>
<li>F#管道操作符</li>
<li>动态导入</li>
</ul>
<h1 id="二、F-管道操作符"><a href="#二、F-管道操作符" class="headerlink" title="二、F#管道操作符"></a>二、F#管道操作符</h1><p>管道操作符提议还在第一阶段的开发中，同时也意味着其规范还在定义中。Babel 从<code>7.3.0</code> 版本已经支持了管道的变形<code>Smart</code>，以及<code>7.0.0-beta</code>版本以来的<code>minimal</code>变形，并且现在又有了新的<code>F#</code>变形。</p>
<p><code>F#</code>的变形不同于已经存在的<code>smart</code>变形，为何呢?与之前的话题引用（<code>topic references</code>）的概念相比，我们将使用箭头函数来代替。最明显的一个优势就是其更像当今的JavaScript ，并且有着更简洁的语法。换而言之，管道操作符是用在单个参数函数调用时非常有用的且必不可少的语法糖。<br>也就意味着：</p>
<pre><code>sqrt(64)

// 等于

64 |&gt; sqrt</code></pre><p>以上语法的好处就是当链接多个函数的时候可以使代码更具可读性，这就是管道操作符的最明显的作用。</p>
<a id="more"></a>

<h3 id="考虑以下几行代码："><a href="#考虑以下几行代码：" class="headerlink" title="考虑以下几行代码："></a>考虑以下几行代码：</h3><pre><code>function doubleSay (str) {
  return str + &quot;, &quot; + str;
}
function capitalize (str) {
  return str[0].toUpperCase() + str.substring(1);
}
function exclaim (str) {
  return str + &apos;!&apos;;
}</code></pre><p>以下是上面这些函数的调用：</p>
<pre><code>let result = exclaim(capitalize(doubleSay(&quot;hello&quot;)));
console.log(result) //=&gt; &quot;Hello, hello!&quot;</code></pre><p>可以使用<code>F#</code>变形来优化：</p>
<pre><code>let result = &quot;hello&quot;
  |&gt; doubleSay
  |&gt; capitalize
  |&gt; exclaim;
console.log(result) //=&gt; &quot;Hello, hello!&quot;</code></pre><h3 id="多参数的F"><a href="#多参数的F" class="headerlink" title="多参数的F#"></a>多参数的<code>F#</code></h3><p>这种特殊解决方法的好处就是管道操作符不需对多参数函数做任何处理，只管扔给JavaScript就好了：</p>
<pre><code>function double (x) { return x + x; }
function add (x, y) { return x + y; }

function boundScore (min, max, score) {
  return Math.max(min, Math.min(max, score));
}</code></pre><p>可以使用<code>smart</code> 变形来调用：</p>
<pre><code>let person = { score: 25 };
let newScore = boundScore( 0, 100, add(7, double(person.score)))
console.log(newScore) //=&gt; 57</code></pre><p>管道操作符提供的新的或者说更好的与之前的<code>smart</code> 变形截然相反的方法是因为我们可以使用箭头函数，可以用来处理多参数函数，比如： <code>add()</code> 和 <code>boundScore()</code>：</p>
<pre><code>let person = { score: 25 };
let newScore = person.score
  |&gt; double
  |&gt; (n =&gt; add(7, n))
  |&gt; (n =&gt; boundScore(0, 100, n));
console.log(newScore) //=&gt; 57</code></pre><p>尽管可以用来处理多个参数的函数，但是通常推荐用来处理单参数函数，因为管道操作符每次只返回一个结果。</p>
<h3 id="与部分应用语法（Partial-Application-Syntax）一起使用"><a href="#与部分应用语法（Partial-Application-Syntax）一起使用" class="headerlink" title="与部分应用语法（Partial Application Syntax）一起使用"></a>与部分应用语法（Partial Application Syntax）一起使用</h3><p>部分应用语法提出（目前还在第一阶段），在一个通过参数占位符来实现允许部分应用参数列表来调用表达式的参数列表中使用了<code>?</code>操作符来引入的一种新的语法。<br>如果部分语法提议通过审核，也就意味着管道操作符就将会是一种更好更准确的处理之前提到过的函数的方法，即：</p>
<p>不用这么写：</p>
<pre><code>let person = { score: 25 };
let newScore = person.score
  |&gt; double
  |&gt; (n =&gt; add(7, n))
  |&gt; (n =&gt; boundScore(0, 100, n));
console.log(newScore) //=&gt; 57</code></pre><p>可以直接使用<code>?</code>操作符来替换任意参数来这样写：</p>
<pre><code>let person = { score: 25 };
let newScore = person.score
  |&gt; double
  |&gt; add(7, ?)
  |&gt; boundScore(0, 100, ?);
console.log(newScore) //=&gt; 57</code></pre><p>后者更加简单明了，但是先别高兴得太早，目前只是提议阶段，还未完全确定，拭目以待。</p>
<h3 id="与Await一起使用"><a href="#与Await一起使用" class="headerlink" title="与Await一起使用"></a>与Await一起使用</h3><p>每一个提议对于管道中的<code>await</code>都有不同的解决方案，<code>F#</code>变形也不例外，它处理<code>await</code>的方式和<code>smart</code>有点类似但是也有不同之处：</p>
<pre><code>// Smart Pipeline
let newScore = fetch(url)
  |&gt; await #
  |&gt; #.json()
  |&gt; await #
  |&gt; #.ID;</code></pre><p>F# 管道引入箭头函数来处理这些案例：</p>
<pre><code>// F# pipe line
let newScore = fetch(url)
  |&gt; await
  |&gt; r =&gt; r.json()
  |&gt; await
  |&gt; obj =&gt; obj.ID;</code></pre><h3 id="开始尝试-F-管道操作符"><a href="#开始尝试-F-管道操作符" class="headerlink" title="开始尝试 F# 管道操作符"></a>开始尝试 F# 管道操作符</h3><p>可以简单修改<code>babel.config</code>文件然后加入管道操作符插件来使用：</p>
<pre><code>module.exports = {
  plugins: [
    [&quot;@babel/proposal-pipeline-operator&quot;, { proposal: &quot;fsharp&quot; }]
  ]
};</code></pre><h3 id="更多关于此提议-特性"><a href="#更多关于此提议-特性" class="headerlink" title="更多关于此提议/特性"></a>更多关于此提议/特性</h3><p><a href>https://babeljs.io/blog/2019/07/03/7.5.0#f-pipeline-operator-9450-https-githubcom-babel-babel-pull-9450-and-9984-https-githubcom-babel-babel-pull-9984</a></p>
<h1 id="三、动态引入"><a href="#三、动态引入" class="headerlink" title="三、动态引入"></a>三、动态引入</h1><p>在新提议之前：<br>1.如果你使用<code>webpack</code>或者<code>rollup</code>来实现动态引入，需要包含<code>@babel/plugin-syntax-dynamic-import</code>并且不能用<code>babel</code>转化<br>2.如果你使用<code>Node</code>，可以使用<code>babel-plugin-dynamic-import-node</code>插件来转化</p>
<p>在这里讨论的重点时，对于每一个模块来说，可以有不同的方法来转化。通常，是使用唯一的转化插件来转化模块的。大意是，新的动态导入的提议提供了一种结合上述几种用例的方法，一个单一的<code>entry point</code> <code>@babel/plugin-proposal-dynamic-import</code>。</p>
<p>这样，我们就有了一个可以转化所有模块(Webpack, Roll up, Node 等等)可重用的插件。这个插件必须和模块转化插件一起使用，因为<code>Babel</code>需要识别你需要转化的是哪一种模块加载系统。</p>
<p>一个关于AMD有效配置的例子：</p>
<pre><code>module.exports = {
  plugins: [
    &quot;@babel/plugin-proposal-dynamic-import&quot;,
    &quot;@babel/plugin-transform-modules-amd&quot;
  ]
};</code></pre><p> <code>&quot;@babel/plugin-transform-modules-amd&quot;</code>指明了目标模块是AMD类型的，如果不指定的话，<code>Babel</code>将无法识别目标模块是 <code>Node</code> 还是 <code>Rollup</code>，如果你只是解析<code>import()</code>表达式，而不是转化的话，可以只指定<code>@babel/plugin-syntax-dynamic-import</code>。</p>
<p>动态引入在使用<code>@babel/preset-env</code>时默认开启，也无需考虑是否支持<code>webpack</code>或者<code>rollup</code>，<code>babel-loader</code> 和 <code>rollup-plugin-babel</code>都会为了使其他<code>bundler</code>正确处理<code>Babel</code>而自动关闭其转化功能。</p>
<h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><p><a href="https://scotch.io/bar-talk/dynamic-imports-and-f-pipes-officially-land-in-babel-75" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JS中的事件发射器（Event Emitters）</title>
    <url>/2019/08/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-84f3e55abfbaba7a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Event Emitter"></p>
<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>先看一个<code>DOM</code>事件:</p>
<pre><code>const button = document.querySelector(&quot;button&quot;);

button.addEventListener(&quot;click&quot;, (event) =&gt; /* do something with the event */)</code></pre><p>以上代码在<code>button</code>上添加了一个事件监听器，每当点击<code>button</code>的时候，点击事件被触发出去并且同时调用<code>callback</code>函数。</p>
<p>有很多时候可能会有需要触发自定义事件的需求，不单单只是一个点击事件，假设有这样一个需要触发一个基于其他触发器的事件，并且需要有一个事件响应的，可以自定义一个<code>event emitter</code>来实现。</p>
<a id="more"></a>

<p>一个<code>event emitter</code>就是监听一个<code>event</code>，触发一个回调函数，然后<code>emit</code>一个带有<code>value</code>的事件的一种模式，有时候也称为<code>pub/sub</code>模型或者监听器。</p>
<p>在JavaScript中的一种实现如下：</p>
<pre><code>let n = 0;
const event = new EventEmitter();

event.subscribe(&quot;THUNDER_ON_THE_MOUNTAIN&quot;, value =&gt; (n = value));

event.emit(&quot;THUNDER_ON_THE_MOUNTAIN&quot;, 18);

// n: 18

event.emit(&quot;THUNDER_ON_THE_MOUNTAIN&quot;, 5);

// n: 5</code></pre><p>在上面的代码中，我们订阅了一个叫做 <code>THUNDER_ON_THE_MOUNTAIN</code>的事件，并且当事件被 <code>emitted</code> 的时候，回调函数 <code>value =&gt; (n = value)</code> 也会被触发，可以调用 <code>emit()</code>来<code>emit</code>该事件。</p>
<p>这在与异步代码交互的时候，如果有不在当前模块下的值需要更新时十分有用。</p>
<p>一个真实的例子就是<a href="https://react-redux.js.org/" target="_blank" rel="noopener">React Redux</a>，<br><code>Redux</code>需要一种通知外部其内部的值已经更新的机制，其允许<code>React</code>调用<code>setState()</code>并重新渲染UI来获取哪些值已经改变，这个地方也是使用<code>event emitter</code>来实现的。<br><code>Redux store</code>有一个传入一个提供新的<code>store</code>的回调函数作为参数的订阅函数，在这个订阅函数中，调用了 <code>React Redux</code>的以新<code>store</code>的值调用了<code>setState()</code>方法的 <code>&lt;Provider&gt;</code> 组件，可以<a href="https://github.com/reduxjs/react-redux/blob/master/src/components/Provider.js#L36" target="_blank" rel="noopener">在此</a>查看。</p>
<p>现在我们的应用有了两个不同的部分，一部分是<code>React UI</code>，另一部分是<code>Redux store</code>，谁也说不清楚事件究竟是被那一部分触发的。</p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p>先看一个简单的<code>event emitter</code>，其中使用了<code>class</code>，在这个<code>class</code>中跟踪事件。</p>
<pre><code>class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
    }
}</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>定义一个事件接口，用来存储一个每一个<code>key</code>都是一个事件名并且各自的值都是回调函数组成的数组的空白对象。</p>
<pre><code>interface Events {
  [key: string]: Function[];
}

{
  &quot;event&quot;: [fn],
  &quot;event_two&quot;: [fn]
}</code></pre><p>使用数组的原因是因为每一个事件都可能有多个<code>subscriber</code>，因为<code>element.addEventLister(&quot;click&quot;)</code>可能会被多次调用。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>现在需要处理订阅的事件，在上面的例子中，<code>subscribe()</code>函数接收两个参数：一个<code>name</code>和一个<code>callback</code>函数。</p>
<pre><code>event.subscribe(&quot;named event&quot;, value =&gt; value);</code></pre><p>定义一个<code>subscribe</code>方法来接收这两个参数，只需把这两个参数添加到类内部的<code>this.events</code>。</p>
<pre><code>class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
    }

    public subscribe(name: string, cb: Function) {
        (this.events[name] || (this.events[name] = [])).push(cb);
    }
}</code></pre><h3 id="发射"><a href="#发射" class="headerlink" title="发射"></a>发射</h3><p>到此可以订阅事件了，接下来，当一个新事件发射的时候需要触发回调函数，当触发的时候，将使用<code>(emit(&quot;event&quot;))</code>中存储的事件名和需要传递到回调函数<code>(emit(&quot;event&quot;, value))</code>的任意值，我们可以简单地传递任意参数到回调函数在第一个参数后面。</p>
<pre><code>class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
  }

    public subscribe(name: string, cb: Function) {
        (this.events[name] || (this.events[name] = [])).push(cb);
    }

    public emit(name: string, ...args: any[]): void {
        (this.events[name] || []).forEach(fn =&gt; fn(...args));
    }
}</code></pre><p>既然我们知道了我们希望发射的事件，可以使用<code>this.events[name]</code>来查看，返回的是一个回调函数的数组。</p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><pre><code>subscribe(name: string, cb: Function) {
    (this.events[name] || (this.events[name] = [])).push(cb);

    return {
        unsubscribe: () =&gt;
        this.events[name] &amp;&amp; this.events[name].splice(this.events[name].indexOf(cb) &gt;&gt;&gt; 0, 1)
    };
}</code></pre><p>上述代码返回一个带有<code>unsubscribe</code>方法的对象，可以使用箭头函数<code>() =&gt;</code>来获取传递给父对象参数的作用域，在这个函数中，使用<code>&gt;&gt;&gt;</code><a href="https://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it" target="_blank" rel="noopener">操作符</a>可以找到传递给父级回调函数的索引，在这里使用可以保证我们每次在回调函数数组上调用<code>splice()</code> 的时候总是可以取到一个真正的数字，即使<code>indexOf()</code> 都不能返回数字也行。<br>可以这样使用：</p>
<pre><code>const subscription = event.subscribe(&quot;event&quot;, value =&gt; value);

subscription.unsubscribe();</code></pre><p>到此，我们就可以取消这一个特别的订阅了，而且不影响其他的订阅。</p>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><pre><code>interface Events {
    [key: string]: Function[];
}

export class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
    }

    public subscribe(name: string, cb: Function) {
        (this.events[name] || (this.events[name] = [])).push(cb);

    return {
        unsubscribe: () =&gt;
            this.events[name] &amp;&amp; this.events[name].splice(this.events[name].indexOf(cb) &gt;&gt;&gt; 0, 1)
    };
}

    public emit(name: string, ...args: any[]): void {
        (this.events[name] || []).forEach(fn =&gt; fn(...args));
    }
}</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://codepen.io/charliewilco/pen/gEoErR" target="_blank" rel="noopener">https://codepen.io/charliewilco/pen/gEoErR</a></p>
<p>上述代码中，首先在另外一个事件回调中使用了<code>event emitter</code>，在这种情况下，一个<code>event emitter</code>是用来清除一些逻辑，在GitHub上选择一个仓库，获取详情，缓存详情，并更新DOM去显示这些详情。在订阅回调函数中从网络或者缓存中获取结果并更新，可以这样做的原因是当我们发射时间的时候从列表中给了回调函数一个随机的仓库。</p>
<p>现在来考虑一些不太一样的东西，在一个应用中，可能会有许多状态需要登录之后才可以触发，并且可能会有多个订阅器来处理用户试图退出的操作。因为已经发射了一个带<code>false</code>值的事件，每一个订阅器都可以使用这个值，并且需要判断是否需要重定向页面，移除cookie或者禁用表单。</p>
<pre><code>const events = new EventEmitter();

events.emit(&quot;authentication&quot;, false);

events.subscribe(&quot;authentication&quot;, isLoggedIn =&gt; {
    buttonEl.setAttribute(&quot;disabled&quot;, !isLogged);
});

events.subscribe(&quot;authentication&quot;, isLoggedIn =&gt; {
    window.location.replace(!isLoggedIn ? &quot;/login&quot; : &quot;&quot;);
});

events.subscribe(&quot;authentication&quot;, isLoggedIn =&gt; {
    !isLoggedIn &amp;&amp; cookies.remove(&quot;auth_token&quot;);
});</code></pre><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>要让<code>emitters</code>能工作，有几点需要考虑：</p>
<ul>
<li><p>需要在<code>emit()</code>函数中使用<code>forEach</code>或者<code>map</code>来确保我们能创建新的订阅器或者取消订阅。</p>
</li>
<li><p>当一个<code>EventEmitter</code>类被实例化之后，可以传递一个预定义的事件到事件接口。</p>
</li>
<li><p>可以不需要使用<code>class</code>，来实现，个人喜好，但是使用<code>class</code>使事件存储在哪里会更加清晰。<br>可以在一个函数中实现，如下：</p>
<pre><code>function emitter(e?: Events) {
    let events: Events = e || {};

    return {
        events,
        subscribe: (name: string, cb: Function) =&gt; {
        (events[name] || (events[name] = [])).push(cb);

        return {
            unsubscribe: () =&gt; {
            events[name] &amp;&amp; events[name].splice(events[name].indexOf(cb) &gt;&gt;&gt; 0, 1);
            }
        };
        },
        emit: (name: string, ...args: any[]) =&gt; {
            (events[name] || []).forEach(fn =&gt; fn(...args));
        }
    };
}</code></pre></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://css-tricks.com/understanding-event-emitters/" target="_blank" rel="noopener">https://css-tricks.com/understanding-event-emitters/</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Event Emitters</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2019 新特性</title>
    <url>/2019/08/19/ES2019%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-69db7d2ed973e3ae.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ES2019"></p>
<h1 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h1><p>在ES2017中，引入了<code>Object.entries</code>来把<code>Object</code>转成数组，如下：</p>
<pre><code>let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

Object.entries(students) 
// [
//  [ &apos;amelia&apos;, 20 ],
//  [ &apos;beatrice&apos;, 22 ],
//  [ &apos;cece&apos;, 20 ],
//  [ &apos;deirdre&apos;, 19 ],
//  [ &apos;eloise&apos;, 21 ]
// ]</code></pre><a id="more"></a>

<p>引入<code>Object.entries</code>这个方法的目的是为了使<code>Object</code>也可以使用数组的<code>map</code>，<code>filter</code>， <code>reduce</code>等原生方法，但是使用完之后必须要自己手动还原回去，例如：</p>
<pre><code>let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

// convert to array in order to make use of .filter() function
let overTwentyOne = Object.entries(students).filter(([name, age]) =&gt; {
  return age &gt;= 21
}) // [ [ &apos;beatrice&apos;, 22 ], [ &apos;eloise&apos;, 21 ] ]

// turn multidimensional array back into an object
let DrinkingAgeStudents = {}
for (let [name, age] of overTwentyOne) {
    DrinkingAgeStudents[name] = age;
}
// { beatrice: 22, eloise: 21 }</code></pre><p>上述代码使用了<code>Object.entries</code>及数组的<code>filter</code>方法过滤了年龄大于等于21的成员，然后又使用了<code>for...of</code>把数字转变回了<code>Object</code>，<br><code>Object.fromEntries</code>就是用来替代上面代码中的<code>for...of</code>循环的，使得<code>Object</code>调用数组的原生方法更简洁方便，代码如下：</p>
<pre><code>let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

// convert to array in order to make use of .filter() function
let overTwentyOne = Object.entries(students).filter(([name, age]) =&gt; {
  return age &gt;= 21
}) // [ [ &apos;beatrice&apos;, 22 ], [ &apos;eloise&apos;, 21 ] ]

// turn multidimensional array back into an object
let DrinkingAgeStudents = Object.fromEntries(overTwentyOne); 
// { beatrice: 22, eloise: 21 }</code></pre><p>需要注意的一点是，使用<code>Object.fromEntries</code>会把<code>Object</code>中的重复<code>key</code>覆盖掉，只保存最后一个，如下：</p>
<pre><code>let students = [
  [ &apos;amelia&apos;, 22 ], 
  [ &apos;beatrice&apos;, 22 ], 
  [ &apos;eloise&apos;, 21], 
  [ &apos;beatrice&apos;, 20 ]
]

let studentObj = Object.fromEntries(students); 
// { amelia: 22, beatrice: 20, eloise: 21 }
// dropped first beatrice!</code></pre><h1 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat"></a>Array.prototype.flat</h1><p>通常，数组会出现二维或者以上的情况，这个时候如果我们需要降维的话，常用的一种方法时使用<code>concat</code>方法，如下：</p>
<pre><code>let courses = [
  {
    subject: &quot;math&quot;,
    numberOfStudents: 3,
    waitlistStudents: 2,
    students: [&apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [&apos;Phil&apos;, &apos;Candace&apos;]]
  },
  {
    subject: &quot;english&quot;,
    numberOfStudents: 2,
    students: [&apos;Wilson&apos;, &apos;Taylor&apos;]
  },
  {
    subject: &quot;history&quot;,
    numberOfStudents: 4,
    students: [&apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos;]
  }
]

let courseStudents = courses.map(course =&gt; course.students)
// [
//   [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
//   [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
//   [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
// ]

[].concat.apply([], courseStudents) // we&apos;re stuck doing something like this</code></pre><p>但是在ES2019中引入了<code>Array.prototype.flat</code>，其接受一个可选参数表示需要展开的深度，默认值为1，可以帮助我们快速实现数组降维，如下：</p>
<pre><code>let courseStudents = [
  [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
  [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
  [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
]

let flattenOneLevel = courseStudents.flat(1)
console.log(flattenOneLevel)
// [
//   &apos;Janet&apos;,
//   &apos;Martha&apos;,
//   &apos;Bob&apos;,
//   [ &apos;Phil&apos;, &apos;Candace&apos; ],
//   &apos;Wilson&apos;,
//   &apos;Taylor&apos;,
//   &apos;Edith&apos;,
//   &apos;Jacob&apos;,
//   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]

let flattenTwoLevels = courseStudents.flat(2)
console.log(flattenTwoLevels)
// [
//   &apos;Janet&apos;,   &apos;Martha&apos;,
//   &apos;Bob&apos;,     &apos;Phil&apos;,
//   &apos;Candace&apos;, &apos;Wilson&apos;,
//   &apos;Taylor&apos;,  &apos;Edith&apos;,
//   &apos;Jacob&apos;,   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]</code></pre><p>不指定参数与参数值等于1的时候一样：</p>
<pre><code>let courseStudents = [
  [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
  [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
  [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
]

let defaultFlattened = courseStudents.flat()
console.log(defaultFlattened)
// [
//   &apos;Janet&apos;,
//   &apos;Martha&apos;,
//   &apos;Bob&apos;,
//   [ &apos;Phil&apos;, &apos;Candace&apos; ],
//   &apos;Wilson&apos;,
//   &apos;Taylor&apos;,
//   &apos;Edith&apos;,
//   &apos;Jacob&apos;,
//   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]</code></pre><ul>
<li><p>贪心操作<code>Infinity</code><br>对于未知深度的数组，可以使用<code>Infinity</code>参数来实现完全降维：</p>
<pre><code>let courseStudents = [
  [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
  [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
  [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
]

let alwaysFlattened = courseStudents.flat(Infinity)
console.log(alwaysFlattened)
// [
//   &apos;Janet&apos;,   &apos;Martha&apos;,
//   &apos;Bob&apos;,     &apos;Phil&apos;,
//   &apos;Candace&apos;, &apos;Wilson&apos;,
//   &apos;Taylor&apos;,  &apos;Edith&apos;,
//   &apos;Jacob&apos;,   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]</code></pre></li>
</ul>
<p>事实上，<code>Infinity</code>参数在实际情况中应该谨慎使用，而且在真正未知数组维数时并不推荐使用<code>Infinity</code>参数。</p>
<h1 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap"></a>Array.prototype.flatMap</h1><p><code>flatMap</code> 等价于<code>map</code> 和 <code>flat</code>不加参数的结合体，所以<code>flatMap</code> 只展开一层数组。</p>
<ul>
<li><p>普通半版数组中插入值：</p>
<pre><code>let grades = [78, 62, 80, 64]

let curved = grades.map(grade =&gt; [grade, grade + 7])
// [ [ 78, 85 ], [ 62, 69 ], [ 80, 87 ], [ 64, 71 ] ]

let flatMapped = [].concat.apply([], curved) // now flatten, could use flat but that didn&apos;t exist before either
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]</code></pre></li>
</ul>
<ul>
<li><p><code>Array.prototype.flat</code>版</p>
<pre><code>let grades = [78, 62, 80, 64]

let flatMapped = grades.map(grade =&gt; [grade, grade + 7]).flat()
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]</code></pre></li>
</ul>
<ul>
<li><p><code>flatMap</code>进阶版</p>
<pre><code>let grades = [78, 62, 80, 64]

let flatMapped = grades.flatMap(grade =&gt; [grade, grade + 7]);
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]</code></pre></li>
</ul>
<p>由于是<code>map</code> 和 <code>flat</code>不加参数的结合体，<code>flatMap</code> 只展开一层数组：</p>
<pre><code>let grades = [78, 62, 80, 64]

let flatMapped = grades.flatMap(grade =&gt; [grade, [grade + 7]]);
// [
//   78, [ 85 ],
//   62, [ 69 ],
//   80, [ 87 ],
//   64, [ 71 ]
// ]</code></pre><h1 id="String-trimStart-和-String-trimEnd"><a href="#String-trimStart-和-String-trimEnd" class="headerlink" title="String.trimStart 和 String.trimEnd"></a>String.trimStart 和 String.trimEnd</h1><p>等价于之前的<code>String.trimRight</code> 和 <code>String.trimLeft</code> </p>
<pre><code>let message = &quot;   Welcome to CS 101    &quot;
message.trimRight()
// &apos;   Welcome to CS 101&apos;
message.trimLeft()
// &apos;Welcome to CS 101   &apos;
message.trimRight().trimLeft()
// &apos;Welcome to CS 101&apos;</code></pre><p>等价于</p>
<pre><code>let message = &quot;   Welcome to CS 101    &quot;
message.trimEnd()
// &apos;   Welcome to CS 101&apos;
message.trimStart()
// &apos;Welcome to CS 101   &apos;
message.trimEnd().trimStart()
// &apos;Welcome to CS 101&apos;</code></pre><h1 id="可选的catch绑定"><a href="#可选的catch绑定" class="headerlink" title="可选的catch绑定"></a>可选的catch绑定</h1><p>在之前的版本中，<code>try...catch</code>中的<code>catch</code>后面必须要跟一个参数，即使<code>catch</code>块里面什么内容都没有，所以在ES2019中，<code>catch</code>块后面的参数是可选的，如下：</p>
<pre><code>try {
  let parsed = JSON.parse(obj)
} catch(e) {
  // ignore e, or use
  console.log(obj)
}</code></pre><p><code>e</code>可以不写：</p>
<pre><code>try {
  let parsed = JSON.parse(obj)
} catch {
  console.log(obj)
}</code></pre><h1 id="Function-toString-更新"><a href="#Function-toString-更新" class="headerlink" title="Function.toString() 更新"></a>Function.toString() 更新</h1><p>之前的版本中，<code>Function.toString()</code>直接把空格去掉了：</p>
<pre><code>function greeting() {
  const name = &apos;CSS Tricks&apos;
  console.log(`hello from ${name}`)
}

greeting.toString()
//&apos;function greeting() {\nconst name = \&apos;CSS Tricks\&apos;\nconsole.log(`hello from ${name} //`)\n}&apos;</code></pre><p>但是，在ES2019中，会完全保留源码格式打印：</p>
<pre><code>function greeting() {
  const name = &apos;CSS Tricks&apos;
  console.log(`hello from ${name}`)
}

greeting.toString()
// &apos;function greeting() {\n&apos; +
//  &quot;  const name = &apos;CSS Tricks&apos;\n&quot; +
//  &apos;  console.log(`hello from ${name}`)\n&apos; +
//  &apos;}&apos;</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://css-tricks.com/all-the-new-es2019-tips-and-tricks/" target="_blank" rel="noopener">https://css-tricks.com/all-the-new-es2019-tips-and-tricks/</a></p>
]]></content>
      <categories>
        <category>JavaScript ES2019</category>
      </categories>
      <tags>
        <tag>ES2019 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之Set和Map及WeakSet和WeakMap总结</title>
    <url>/2019/08/19/ES6%E4%B9%8BSet%E5%92%8CMap%E5%8F%8AWeakSet%E5%92%8CWeakMap%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-96533cae7400a3a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Set &amp; Map"></p>
<h1 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h1><ul>
<li><p>概念<br><code>Set</code>类似于数组，本身是一个构造函数，用来生成 <code>Set</code> 数据结构，成员值都是唯一的，常用于数组去重。</p>
</li>
<li><p>属性<br><code>Set.prototype.size</code>：返回Set实例的成员总数</p>
</li>
<li><p>方法<br><code>add()</code> 添加值，返回 Set 结构本身。<br><code>delete()</code> 删除值，返回一个布尔值，表示删除是否成功。<br><code>has()</code> 返回一个布尔值，表示该值是否为<code>Set</code>的成员。<br><code>clear()</code> 清除所有成员，没有返回值。</p>
</li>
<li><p>遍历<br><code>Set.prototype.keys()</code>：返回键名的遍历器<br><code>Set.prototype.values()</code>：返回键值的遍历器<br><code>Set.prototype.entries()</code>：返回键值对的遍历器<br><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</p>
</li>
</ul>
<a id="more"></a>

<h1 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h1><ul>
<li><p>概念<br>由于<code>Object</code>只能使用字符串作为<code>key</code>，在使用上面会有很大的限制，比如使用<code>DOM</code>节点作为<code>key</code>时，就会被自动转为字符串<code>[object HTMLDivElement]</code>。<br>为了解决上述问题，ES6 引入了 <code>Map</code> ，它类似于对象，也是键值对的集合，但是其key的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br><code>Object</code> 结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
</li>
<li><p>与Object的区别<br><code>Object</code>：<br><code>k-v</code>(键-值对)，<code>key</code>只能是字符串，<code>value</code>可以为任意类型，无序，不可遍历，有默认属性<br><code>Map</code>:<br><code>k-v</code>(键-值对)，<code>key</code>与<code>value</code>可以为任意类型，可使用<code>for...of</code>遍历，按插入顺序遍历，可存储大量数据，但是由于<code>.get</code> 函数，可能比<code>Object</code>慢</p>
</li>
</ul>
<p>常用方法比较：</p>
<pre><code>Object:
   var o = {};
   var o = Object.create(null);
   o.key = 1;
   o.key += 10;
   for(let k in o) o[k]++;
   var sum = 0;
   for(let v of Object.values(m)) sum += v;
   if(&apos;key&apos; in o);
   if(o.hasOwnProperty(&apos;key&apos;));
   delete(o.key);
   Object.keys(o).length
Map:
   var m = new Map();
   m.set(&apos;key&apos;, 1);
   m.set(&apos;key&apos;, m.get(&apos;key&apos;) + 10);
   m.foreach((k, v) =&gt; m.set(k, m.get(k) + 1));
   for(let k of m.keys()) m.set(k, m.get(k) + 1);
   var sum = 0;
   for(let v of m.values()) sum += v;
   if(m.has(&apos;key&apos;));
   m.delete(&apos;key&apos;);
   m.size();</code></pre><ul>
<li><p>属性与方法<br><code>size</code><br><code>set(k,v)</code><br><code>get(K)</code><br><code>has(k)</code><br><code>delete(k)</code><br><code>clear()</code></p>
</li>
<li><p>遍历<br><code>Map.prototype.keys()</code>：返回键名的遍历器。<br><code>Map.prototype.values()</code>：返回键值的遍历器。<br><code>Map.prototype.entries()</code>：返回所有成员的遍历器。<br><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</p>
</li>
<li><p>遍历顺序就是插入顺序</p>
</li>
<li><p><code>Map</code> 转为数组最方便的方法，就是使用扩展运算符<code>（...）</code></p>
</li>
</ul>
<h1 id="三、WeakSet"><a href="#三、WeakSet" class="headerlink" title="三、WeakSet"></a>三、WeakSet</h1><ul>
<li><p><code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值</p>
</li>
<li><p>对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中。</p>
</li>
<li><p><code>WeakSet</code> 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 <code>WeakSet</code> 里面的引用就会自动消失，所以<code>WeakSet</code> 的成员是不适合引用的。</p>
</li>
<li><p>由于 <code>WeakSet</code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet</code> 不可遍历。</p>
</li>
<li><p>方法<br><code>WeakSet.prototype.add(value)</code>：向 WeakSet 实例添加一个新成员。<br><code>WeakSet.prototype.delete(value)</code>：清除 WeakSet 实例的指定成员。<br><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在 <code>WeakSet</code> 实例之中。</p>
</li>
</ul>
<h1 id="四、WeakMap"><a href="#四、WeakMap" class="headerlink" title="四、WeakMap"></a>四、WeakMap</h1><ul>
<li><code>WeakMap</code>只接受对象作为键名（null除外）</li>
<li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制</li>
<li><code>WeakMap</code>的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内</li>
<li>没有遍历方法，即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法</li>
<li>没有<code>size</code>属性、<code>clear()</code>方法</li>
<li><code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code></li>
</ul>
<p>一个典型应用场景是，在网页的 <code>DOM</code> 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 <code>DOM</code> 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/set-map</a><br><a href="https://stackoverflow.com/questions/18541940/map-vs-object-in-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/18541940/map-vs-object-in-javascript</a></p>
]]></content>
      <categories>
        <category>JavaScript ES6</category>
      </categories>
      <tags>
        <tag>ES6 Set Map WeakSet WeakMap</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript中的Web Worker</title>
    <url>/2019/08/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84WebWorker/</url>
    <content><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>由于JavaScript是单线程模型，即所有任务只能在同一个线程上面完成，前面的任务没有做完，后面的就只能等待，这对于日益增强的计算能力来说不是一件好事。所以在HTML5中引入了Web Worker的概念，来为JavaScript创建多线程环境，将其中一些任务分配给Web Worker运行，二者可以同时运行，互不干扰，如图：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-d566f191add913c3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="With or without worker"></p>
<p>Web Worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，引入Web Worker的好处是一些计算密集型或高延迟的任务，被 Web Worker 线程所处理，主线程就会很流畅，不会被阻塞或拖慢，而此时 Web Worker 在后台运行。但是这也正是 Web Worker 比较耗费资源的原因，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<h1 id="二、浏览器支持"><a href="#二、浏览器支持" class="headerlink" title="二、浏览器支持"></a>二、浏览器支持</h1><p>所有主流浏览器均支持 Worker，除了 Internet Explorer。<br>可以使用如下代码检测 Worker 支持<br>在创建 Worker 之前，请检测用户的浏览器是否支持它：</p>
<pre><code>if(typeof(Worker)!==&quot;undefined&quot;)
  {
  // Yes! Web worker support!
  // Some code.....
  }
else
  {
  // Sorry! No Web Worker support..
  }</code></pre><a id="more"></a>

<h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>Web Worker 在独立线程中运行。因此，它们执行的代码需要保存在一个单独的文件中。但在保存代码前，我们要先在主线程上创建新的 Worker 对象。构造函数采用 Worker 脚本的名称：</p>
<pre><code>var worker = new Worker(&apos;worker.js&apos;);</code></pre><p>如果指定的异步下载文件存在，浏览器就会生成新的 Worker 线程。在完全下载并执行文件之前，系统不会生成 Worker。如果指向您 Worker 的路径返回 404，Worker 就会在不显示任何提示的情况下失败。</p>
<p>创建 Worker 之后，通过调用 postMessage() 方法启动：</p>
<pre><code>worker.postMessage(); // Start the worker.</code></pre><ul>
<li>传递变量，也可以给Worker传递一个变量</li>
</ul>
<pre><code>// Create a new worker object
var worker = new Worker(&apos;worker.js&apos;);

// Send a message to start the worker and pass a variable to it
var info = &apos;Web Workers&apos;;
worker.postMessage(info);</code></pre><p>在Worker中，例如，在<code>worker.js</code>内部，可以使用<code>onmessage</code>事件来接收来自主线程的消息并且实现一些操作，可以通过<code>event.data</code>来获取到传递的变量：</p>
<pre><code>// Receive the message from the main thread
onmessage = function(event) {
  // Do something
  var info = event.data;
};</code></pre><p>从Worker 发送消息到主线程也是同样的方法(<code>worker.js</code>)：</p>
<pre><code>// Receive the message from the main thread
onmessage = function(event) {
  // Do something
  var info = event.data;
  var result = info + &apos; rise up!&apos;;
  postMessage(result);
};</code></pre><p>主线程：</p>
<pre><code>// Create a new worker object
var worker = new Worker(&apos;worker.js&apos;);

// Send a message to start the worker and pass a variable to it
var info = &apos;Web Workers&apos;;
worker.postMessage(info);

// Receive a message from the worker
worker.onmessage = function (event) {
  // Do something
  alert(event.data);
};</code></pre><p>也可以使用<code>addEventListener</code>来替换<code>onmessage</code>（JavaScript 高手们总是会推荐 <code>addEventListener</code>），例如：<br>主线程：</p>
<pre><code>var worker = new Worker(&apos;doWork.js&apos;);

worker.addEventListener(&apos;message&apos;, function(e) {
  console.log(&apos;Worker said: &apos;, e.data);
}, false);

worker.postMessage(&apos;Hello World&apos;); // Send data to our worker.</code></pre><p><code>doWork.js</code> (Worker)：</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e) {
  self.postMessage(e.data);
}, false);</code></pre><p>在主线程和 Worker 之间传递的消息是复制而不是共享的。例如，下一示例中 JSON 消息的“msg”属性在两个位置中均可访问。即使对象运行在单独的专用空间中，系统似乎也会将其直接传递给 Worker。实际发生的情况是，系统将对象传递给 Worker 后，会将其序列化，随后在另一端解取消序列化。由于网页和 Worker 并不共享同一实例，因此每次传递时都要进行复制。大部分浏览器通过在任一端上对值进行自动 JSON 编码/解码来实施此功能。</p>
<p>主线程：</p>
<pre><code>&lt;button onclick=&quot;sayHI()&quot;&gt;Say HI&lt;/button&gt;
&lt;button onclick=&quot;unknownCmd()&quot;&gt;Send unknown command&lt;/button&gt;
&lt;button onclick=&quot;stop()&quot;&gt;Stop worker&lt;/button&gt;
&lt;output id=&quot;result&quot;&gt;&lt;/output&gt;

&lt;script&gt;
  function sayHI() {
    worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;Hi&apos;});
  }

  function stop() {
    // Calling worker.terminate() from this script would also stop the worker.
    worker.postMessage({&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;Bye&apos;});
  }

  function unknownCmd() {
    worker.postMessage({&apos;cmd&apos;: &apos;foobard&apos;, &apos;msg&apos;: &apos;???&apos;});
  }

  var worker = new Worker(&apos;doWork2.js&apos;);

  worker.addEventListener(&apos;message&apos;, function(e) {
    document.getElementById(&apos;result&apos;).textContent = e.data;
  }, false);
&lt;/script&gt;</code></pre><p><code>doWork2.js</code>：</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e) {
  var data = e.data;
  switch (data.cmd) {
    case &apos;start&apos;:
      self.postMessage(&apos;WORKER STARTED: &apos; + data.msg);
      break;
    case &apos;stop&apos;:
      self.postMessage(&apos;WORKER STOPPED: &apos; + data.msg + &apos;. (buttons will no longer work)&apos;);
      self.close(); // Terminates the worker.
      break;
    default:
      self.postMessage(&apos;Unknown command: &apos; + data.msg);
  };
}, false);</code></pre><ul>
<li>停止 Worker<br>停止 Worker 的方法有两种：在主线程中调用 <code>worker.terminate()</code>，或在 Worker 本身内部调用 <code>self.close()</code>。</li>
<li>Worker 作用域</li>
</ul>
<p>就 Worker 来说，self 和 this 指的都是 Worker 的全局作用域。因此，上一示例也可以写成：</p>
<pre><code>addEventListener(&apos;message&apos;, function(e) {
  var data = e.data;
  switch (data.cmd) {
    case &apos;start&apos;:
      postMessage(&apos;WORKER STARTED: &apos; + data.msg);
      break;
    case &apos;stop&apos;:
  ...
}, false);</code></pre><h1 id="四、加载外部脚本"><a href="#四、加载外部脚本" class="headerlink" title="四、加载外部脚本"></a>四、加载外部脚本</h1><p>可以通过 <code>importScripts()</code> 函数将外部脚本文件或库加载到 Worker 中。该方法采用零个或多个字符串表示要导入的资源的文件名。</p>
<p>此示例将 script1.js 和 script2.js 加载到了 Worker 中：</p>
<pre><code>importScripts(&apos;script1.js&apos;);
importScripts(&apos;script2.js&apos;);</code></pre><p>也可以写成单个导入语句：</p>
<pre><code>importScripts(&apos;script1.js&apos;, &apos;script2.js&apos;);</code></pre><h1 id="五、子-Worker"><a href="#五、子-Worker" class="headerlink" title="五、子 Worker"></a>五、子 Worker</h1><p>Worker 可以生成子 Worker。这对于在运行时进一步拆分大任务来说非常重要。但是，子 Worker 还有几点注意事项：</p>
<ul>
<li>子 Worker 必须托管在与父线程相同的origin中。</li>
<li>子 Worker 中的 URI 应相对于父 Worker 的位置进行解析（与主线程不同）。</li>
</ul>
<p>注意，大部分浏览器会为每个 Worker 生成单独的进程。在开始生成 Worker 场之前，请注意不要占用太多的用户系统资源。这样做的一个原因是，在主线程和 Worker 之间传递的消息是复制而不是共享的。</p>
<h1 id="六、处理错误"><a href="#六、处理错误" class="headerlink" title="六、处理错误"></a>六、处理错误</h1><p>与任何 JavaScript 逻辑一样，您需要处理 Web Worker 中出现的任何错误。如果在执行 Worker 时出现错误，就会触发 ErrorEvent。相关界面中包含用于找出错误内容的三个实用属性：filename - 导致错误的 Worker 脚本的名称；lineno - 出现错误的行号；以及 message - 有关错误的实用说明。以下示例设置了 onerror 事件处理程序以便打印错误内容：</p>
<pre><code>&lt;output id=&quot;error&quot; style=&quot;color: red;&quot;&gt;&lt;/output&gt;
&lt;output id=&quot;result&quot;&gt;&lt;/output&gt;

&lt;script&gt;
  function onError(e) {
    document.getElementById(&apos;error&apos;).textContent = [
      &apos;ERROR: Line &apos;, e.lineno, &apos; in &apos;, e.filename, &apos;: &apos;, e.message].join(&apos;&apos;);
  }

  function onMsg(e) {
    document.getElementById(&apos;result&apos;).textContent = e.data;
  }

  var worker = new Worker(&apos;workerWithError.js&apos;);
  worker.addEventListener(&apos;message&apos;, onMsg, false);
  worker.addEventListener(&apos;error&apos;, onError, false);
  worker.postMessage(); // Start worker without a message.
&lt;/script&gt;</code></pre><p><code>workerWithError.js</code>：</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e) {
  postMessage(1/x); // Intentional error.
};</code></pre><h1 id="七、适用和不适用-Worker-的功能"><a href="#七、适用和不适用-Worker-的功能" class="headerlink" title="七、适用和不适用 Worker 的功能"></a>七、适用和不适用 Worker 的功能</h1><p>由于 Web Worker 的多线程行为，所以它们只能使用 JavaScript 功能的子集：</p>
<ul>
<li><code>navigator</code> 对象</li>
<li><code>location</code> 对象（只读）</li>
<li><code>XMLHttpRequest</code></li>
<li><code>setTimeout()/clearTimeout()</code> 和 <code>setInterval()/clearInterval()</code></li>
<li>应用缓存</li>
<li>使用 <code>importScripts()</code> 方法导入外部脚本</li>
<li>生成其他 Web Worker</li>
</ul>
<p>Worker 无法使用：</p>
<ul>
<li>DOM（非线程安全）</li>
<li><code>window</code> 对象</li>
<li><code>document</code> 对象</li>
<li><code>parent</code> 对象</li>
<li><code>alert()</code></li>
<li><code>confirm()</code></li>
<li><code>document.getElementById()</code></li>
</ul>
<h1 id="八、更多使用方向"><a href="#八、更多使用方向" class="headerlink" title="八、更多使用方向"></a>八、更多使用方向</h1><ul>
<li>预先抓取或缓存数据以便稍后使用</li>
<li>突出显示代码语法或其他实时文本格式</li>
<li>拼写检查</li>
<li>分析视频或音频数据</li>
<li>背景 I/O 或网络服务轮询</li>
<li>处理较大数组或超大 JSON 响应</li>
<li><code>&lt;canvas&gt;</code> 中的图片过滤</li>
<li>更新本地网络数据库中的多行内容</li>
</ul>
<h1 id="九、一些示例"><a href="#九、一些示例" class="headerlink" title="九、一些示例"></a>九、一些示例</h1><ul>
<li><a href="http://slides.html5rocks.com/#web-workers" target="_blank" rel="noopener">Example from HTML5Rocks slides</a></li>
<li><a href="http://htmlfive.appspot.com/static/tracker1.html" target="_blank" rel="noopener">Motion tracker</a></li>
<li><a href="http://people.mozilla.com/~prouget/demos/worker_and_simulatedannealing/index.xhtml" target="_blank" rel="noopener">Simulated Annealing</a></li>
<li><a href="http://html5demos.com/worker" target="_blank" rel="noopener">HTML5demos sample</a></li>
</ul>
<h1 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h1><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</a><br><a href="https://dev.opera.com/articles/web-workers-rise-up/" target="_blank" rel="noopener">https://dev.opera.com/articles/web-workers-rise-up/</a><br><a href="https://www.html5rocks.com/en/tutorials/workers/basics/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/workers/basics/</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Web Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Javascript中的Prototype原型</title>
    <url>/2019/07/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Javascript%E4%B8%AD%E7%9A%84Prototype%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>刚开始学Javascript的时候觉得很简单，其中的东西也就是那是基本的，但是还是太年轻，最近因为面试中常被问到关于原型和原型链的问题，然后自己也是模棱两可的，含含糊糊说不清楚，所以痛下思定，决定好好下一番功夫来搞懂吃透原型与原型链究竟是什么。</li>
</ul>
<h1 id="关于new"><a href="#关于new" class="headerlink" title="关于new"></a>关于<code>new</code></h1><p><code>new</code>的过程</p>
<blockquote>
<ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象</li>
</ul>
</blockquote>
<p>知道了<code>new</code>的原理后，也可以自己实现一个<code>new</code>函数：</p>
<pre><code>function myNew() {
    // 创建一个空的对象
    let obj = new Object()
    // 获得构造函数
    let Con = [].shift.call(arguments)
    // 链接到原型
    obj.__proto__ = Con.prototype
    // 绑定 this，执行构造函数
    let result = Con.apply(obj, arguments)
    // 确保 new 出来的是个对象
    return typeof result === &apos;object&apos; ? result : obj
}</code></pre><a id="more"></a>

<p>先来看几个例子：</p>
<ul>
<li>普通函数</li>
</ul>
<pre><code>function test(name){
    console.log(name);  
}
typeof(test) // function</code></pre><ul>
<li>使用<em>new</em>新建对象</li>
</ul>
<pre><code>function test(name){
    console.log(name);  
}

var te = new test(&quot;Hal&quot;);
typeof(te) // object
console.log(JSON.stringify(test.prototype)) //{}，是个空对象
console.log(JSON.stringify(te.prototype)) //undefined</code></pre><ul>
<li>直接声明的函数拥有<code>prototype</code>这个属性，而<code>new</code>构造出来的函数不存在<code>prototype</code>。</li>
</ul>
<h1 id="关于prototype"><a href="#关于prototype" class="headerlink" title="关于prototype"></a>关于<code>prototype</code></h1><p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象  <code>prototype</code>，这个对象就是我们所说的<code>prototype</code>，每一个对象都会从<code>prototype</code>“继承”属性。除了<code>new</code>出来的函数，每个函数都有一个<code>prototype</code>属性，如下，在<code>prototype</code>上可以设置属性，然后打印出一些东西：</p>
<pre><code>function Employee() {}

// prototype是函数才会有的属性
Employee.prototype.name = &apos;Hal&apos;;
var employee1 = new Employee();
var employee2 = new Employee();
console.log(employee1.name) // Hal
console.log(employee2.name) // Hal
console.log(employee1.constructor) // Employee() {}
console.log(employee1.constructor.name) // Employee
console.log(employee1.prototype) // undefined
console.log(employee1.__proto__) // {name: &quot;Hal&quot;, constructor: ƒ}
console.log(Employee.prototype) // {name: &quot;Hal&quot;, constructor: ƒ}
console.log(Employee.prototype === employee1.__proto__) // true
console.log(Employee.prototype.constructor === Employee) // true</code></pre><h1 id="关于-proto"><a href="#关于-proto" class="headerlink" title="关于__proto__"></a>关于<code>__proto__</code></h1><p>从刚才的例子中已经可以很清楚地看出了，employee1的<code>__proto__</code>和Employee.prototype是相等的，也就是指向同一个对象，也就是说，实例中有一个<code>__proto__</code>指针指向构造函数的<code>prototype</code>。使用<code>Object.getPrototypeOf</code>与<code>__proto__</code>是同样的效果。</p>
<pre><code>Object.getPrototypeOf(employee1) === Employee.prototype //true</code></pre><h1 id="关于constructor"><a href="#关于constructor" class="headerlink" title="关于constructor"></a>关于<code>constructor</code></h1><p>从上面可以看到，原型<code>prototype</code>里面还有一个<code>constructor</code>的属性，然后这个<code>constructor</code>又指向了函数本身。<br>好像有一点绕，但是看一下下面的图就一目了然了：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-f6343d487e11fe0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>Object</code> 是所有对象的祖先，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的祖先，所有函数都可以通过 <code>__proto__</code>找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，由引擎创建，而且<code>Function.__proto__.__proto__</code>是指向<code>Object.prototype</code>的<br>即：<br><code>Function.__proto__.__proto__ === Object.prototype // true</code></li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 new 出来的<br>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.ifyouseewendy.com/blog/2017/07/03/review-you-dont-know-js-this-and-object-prototypes/#what-is-the-prototype-" target="_blank" rel="noopener">http://blog.ifyouseewendy.com/blog/2017/07/03/review-you-dont-know-js-this-and-object-prototypes/#what-is-the-prototype-</a></li>
<li><a href="https://github.com/KieSun/Dream/issues/2" target="_blank" rel="noopener">https://github.com/KieSun/Dream/issues/2</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/2</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现JQuery中的链式操作具体实现</title>
    <url>/2019/07/15/JS%E5%AE%9E%E7%8E%B0JQuery%E4%B8%AD%E7%9A%84%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<ul>
<li><p>前不久面试某大厂被问到关于JQuery中的链式操作的问题，才疏学浅的我一脸懵逼，这东西只是用过，怎么还要求自己动手实现呢，究其原因还是自己修为不够，达不到大厂的水平，平时“拿来主义”习惯了，也不会去深究其底层原理，可见学习思维与方式还需改进，今天就来好好学习一番。</p>
</li>
<li><p>网上查了一下，其原理其实很简单，就是在每次方法执行完后返回this对象，然后后面的方法就可以继续在this环境下执行。</p>
</li>
<li><p>然后自己动手实现一下：</p>
<pre><code>function Employee(){};
// 在原型上定义对应的方法
Employee.prototype ={
  setName:function(name){
    this.name = name;
    return this;
  },
  setAge:function(age){
    this.age = age;
    return this;
  },
  setSex:function(sex){
    this.sex = sex;
    return this;
  }
}

var employee= new Employee();
employee.setName(&quot;Hal&quot;).setAge(24).setSex(&quot;male&quot;);
// Employee {name: &quot;Hal&quot;, age: 24, sex: &quot;male&quot;}</code></pre></li>
<li><p>因为每次返回的结果都是<em>this</em>，所以 ‘.’ 后面的方法就相当于每次都在调用<em>this</em>，如下：</p>
<pre><code>employee.setName(&quot;Hal&quot;) === employee.setName(&quot;Hal&quot;).setAge(24) // true
employee.setName(&quot;Hal&quot;) === employee.setName(&quot;Hal&quot;).setAge(24).setSex(&quot;male&quot;) // true</code></pre></li>
</ul>
<ul>
<li><p>优点<br>链式操作使得异步编程的流程更加清晰，不会像回调函数一样相互耦合，难以分辨函数的执行顺序且维护困难，实现了水平扩展。在ES6中，Promise也正是沿用了这一思想，每一个异步任务返回一个Promise对象，通过then方法指定回调函数。</p>
</li>
<li><p>缺点<br>只能应用在不需要返回值的情况下，或者说只能最后一步才能设置返回值，因为要支持链式调用返回的只能是<em>this</em>，但jQuery主要是对DOM元素进行操作，只需要改变DOM元素的表现而不需要返回值，所以适合链式操作。</p>
</li>
<li><p>参考<br><a href="https://www.cnblogs.com/youhong/p/6899466.html" target="_blank" rel="noopener">https://www.cnblogs.com/youhong/p/6899466.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Proxy用法详解</title>
    <url>/2019/07/11/ES6Proxy%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-96fbd7ec39c2fcb4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Proxy"></p>
<p><strong>前不久换工作的时候面试某大厂被问到关于Proxy的问题，脑子里有点印象但是又说不出具体使用方法，主要还是自己平时积累不够，所以赶紧来恶补一下。</strong></p>
<h1 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h1><p>正式开始之前，先一起来理解下什么是Metaprogramming（元编程），因为Proxy就是一种基于Metaprogramming概念的对象 ，维基百科上这样解释：</p>
<blockquote>
<p>Metaprogramming is a programming technique in which computer programs have the ability to treat other programs as their data.</p>
</blockquote>
<p>翻译过来就是</p>
<blockquote>
<p>元编程就是可以使用其他程序来作为输入数据的一种编程技术</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><blockquote>
<p>Proxy wraps objects and intercepts their behavior through traps</p>
</blockquote>
<blockquote>
<p>The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc).</p>
</blockquote>
<a id="more"></a>

<p>简单说来就是Proxy可以用来改变对象的默认操作，比如自行定义set和get等，常用的有以下这些：</p>
<ul>
<li>apply</li>
<li>construct</li>
<li>defineProperty</li>
<li>deleteProperty</li>
<li>get</li>
<li>getOwnPropertyDescriptor</li>
<li>getPrototypeOf</li>
<li>has</li>
<li>isExtensible</li>
<li>ownKeys</li>
<li>preventExtensions</li>
<li>set</li>
<li>setPrototypeOf</li>
</ul>
<p>Proxy中需要理解的三个属性：</p>
<ul>
<li>target: an Object which the proxy virtualizes.（目标对象）</li>
<li>handler: a Placeholder Object which contains traps.（包含重写方法的对象）</li>
<li>trap: the Methods that provide property access of the target object.（重写的方法，比如get和set）</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>新建一个Proxy对象</p>
<pre><code>let p = new Proxy(target, handler);</code></pre><p>新建一个employee对象然后输出其中的一些属性</p>
<pre><code>const employee = {
    firstName: &apos;Tapas&apos;,
    lastName: &apos;Adhikary&apos;
};

console.group(&apos;employee&apos;);
console.log(employee.firstName);
console.log(employee.lastName);
console.log(employee.org);
console.log(employee.fullName);
console.groupEnd()</code></pre><p>上面的输出如下所示：</p>
<pre><code>employee
Tapas
Adhikary
undefined
undefined</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-14ae06c68fdb9b67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>
<p>接下来使用Proxy来更改一些默认行为：</p>
<ul>
<li><p>第一步 新建一个使用trap的handler<br>以下是一个覆盖get方法的handler，当target中取不到相应的fieldName时，你可以自定义输出:</p>
<pre><code>let handler = {
    get: function(target, fieldName) {        

        if(fieldName === &apos;fullName&apos; ) {
            return `${target.firstName} ${target.lastName}`;
        }

        return fieldName in target ?
            target[fieldName] :
                `No such property as, &apos;${fieldName}&apos;!`

    }
};</code></pre></li>
<li><p>第二步 新建一个Proxy对象，并把之前定义的employee作为target传入</p>
<pre><code>let p = new Proxy(employee, handler);</code></pre></li>
<li><p>第三步 输出p的属性</p>
<pre><code>console.group(&apos;proxy&apos;);
console.log(p.firstName);
console.log(p.lastName);
console.log(p.org);
console.log(p.fullName);
console.groupEnd()</code></pre></li>
</ul>
<p>然后就可以看到输出结果和之前不一样了，期望结果与实际结果如下所示：</p>
<pre><code>proxy
  Tapas
  Adhikary
  No such property as, &apos;org&apos;!
  Tapas Adhikary</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-62701d1cce29ae4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"><br>现在，清楚Proxy的作用了吧，其实就是用来更改对象默认方法的。</p>
<p>下面是改变set方法来实现一个验证的例子：<br>新建一个handler，重新命名为validator：</p>
<pre><code>const validator = {
    set: function(obj, prop, value) {
        if (prop === &apos;age&apos;) {
            if(!Number.isInteger(value)) {
                throw new TypeError(&apos;Age is always an Integer, Please Correct it!&apos;);
            }
            if(value &lt; 0) {
                throw new TypeError(&apos;This is insane, a negative age?&apos;);
            }
        }
    }
};</code></pre><p>然后再新建一个Proxy：</p>
<pre><code>let pr = new Proxy(employee, validator);</code></pre><p>然后可以尝试设置一个不合法的属性，比如：</p>
<pre><code>pr.age = &quot;test&quot;；</code></pre><p>你将会得到如下报错：</p>
<pre><code>Uncaught TypeError: Age is always an Integer, Please Correct it!
    at Object.set (&lt;anonymous&gt;:5:23)
    at &lt;anonymous&gt;:1:7
set @ VM2381:5
(anonymous) @ VM2434:1</code></pre><p>或者：</p>
<pre><code>pr.age = -1；</code></pre><p>结果：</p>
<pre><code>Uncaught TypeError: This is insane, a negative age?
    at Object.set (&lt;anonymous&gt;:8:23)
    at &lt;anonymous&gt;:1:7
set @ VM2381:8
(anonymous) @ VM2531:1</code></pre><p>由上可见，Proxy的功能还是很强大也非常实用，常用应用场景有：</p>
<ul>
<li>保护ID字段不受删除（重写deleteProperty）</li>
<li>取值和写值（数据绑定）（重写get，set）</li>
<li>改变 in 操作的默认行为等</li>
</ul>
<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>需要注意的是，proxy会改变target中的this指向，一旦proxy代理了target，target内部的this则指向了proxy，而不是target。</p>
<pre><code>const target = {
  get: function () {
    console.log(this === proxy);
  }
};
const handler = {};
const proxy = new Proxy(target, handler);

target.get() // false
proxy.get()  // true</code></pre><p>而有些原生对象的内部属性，只有通过正确的this才能拿到，所以proxy也无法代理这些原生对象的属性。</p>
<pre><code>const target = new Date();
const handler = {};
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.</code></pre><p>对于以上的代码，getDate方法只能在Date对象的实例上面拿到，如果this不是Date就会报错。可以通过this绑定原始对象来解决这个问题。</p>
<pre><code>const target = new Date(&apos;2019-07-11&apos;);
const handler = {
  get(target, prop) {
    if (prop === &apos;getDate&apos;) {
      return target.getDate.bind(target);
    }
    return Reflect.get(target, prop);
  }
};
const proxy = new Proxy(target, handler);

proxy.getDate() // 11</code></pre><p>这里又引入了另一个ES6的新增的对象Reflect，Reflect对象就是用来获取对象中默认方法的，这个下篇文章再具体讨论。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Proxy可以用于更改方法的默认输出，比如get方法取不到值时不返回undefined，以及在set方法上加验证及数据绑定等等，很强大也有用，需熟练掌握。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.greenroots.info/metaprogramming-an-introduction-to-javascriptes6-proxy-cjwkk64ly000gvds10db4l034" target="_blank" rel="noopener">Tapas Adhikary</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy - JavaScript | MDN</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/proxy</a></p>
]]></content>
      <categories>
        <category>JavaScript ES6</category>
      </categories>
      <tags>
        <tag>ES6 Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客部署于Github与Coding</title>
    <url>/2016/08/14/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E4%BA%8EGithub%E4%B8%8ECoding/</url>
    <content><![CDATA[<ul>
<li>早就听说可以自己弄一个博客然后免费部署到github上面，但是一直没机会着手去做，前几天，机缘巧合之下，发现了<a href="https://www.npmjs.com/package/hexo" target="_blank" rel="noopener">Hexo</a>这个好东西，这才发现原来它就是我苦苦找寻的的东西啊。真是“<strong>踏破铁鞋无觅处，得来全不费功夫。</strong>”啊。</li>
<li>那好，lz要开始搭建个人博客啦（入坑了）。期间各种坑只能自己体会，虽然外面已经很多搭建的教程了，但是我也来凑个热闹，其实也算是记录一下自己学习的过程，还有期间所遇的各种坑以至于不得不中断到改日再战的坑，在次记录一下让后面的小伙伴们更方便一些，不至于那么惨。</li>
<li>首先必须<strong>安装一下<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a> for windows</strong>,然后申请个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号啊，建议日后想从事CS相关的童鞋多上上全球最大的同性交友网站（GitHub），里面的好东西真不少，受益匪浅啊。</li>
<li>Git不会的童鞋网上搜一下，很简单，在此附上一张命令速查表，方便快捷，虽然貌似后面都没用到git命令。<br><img src="http://upload-images.jianshu.io/upload_images/1741029-4f7a27cef1b46665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-e5035d2c74ba60c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git命令"></p>
<a id="more"></a>

<ul>
<li><p>然后是<strong><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>下载</strong>,稳定版和最新版都可以，个人喜好，Hexo是靠node驱动，所以以上除了github以外都是是必须的。</p>
</li>
<li><p>有不想用国外网站的童鞋也可以使用国内的<a href="https://coding.net" target="_blank" rel="noopener">Coding</a>，原理一样，反正都是仿Github的。虽说国外网站有可能被墙，而且比起国内的慢一点，但是我同时部署了Coding和Github，后者瞬间就能访问了，而前者，呵呵。</p>
</li>
<li><p>对了，第一个坑来了，安装完毕之后一定要重启，不然后面使用<em>npm</em>命令安装Hexo时会提示找不到命令，然后才能继续后面的步骤。重启完毕之后就可以愉快地开始安装了，在Git Bash端执行下面的命令就可以安装Hexo了。</p>
<pre><code>$ npm install hexo-cli -g</code></pre></li>
<li><p>然后初始化hexo，进入文件之后就可以执行后面的命令了。</p>
<pre><code>$ hexo init blog
$ cd blog</code></pre></li>
<li><p>介绍一下hexo下用到的命令：</p>
<pre><code>$ hexo g/generate #生成静态文件
$ hexo s/server #启动服务器，主要用来本地预览
$ hexo d/deploy #将本地文件发布到github或Coding上
$ hexo n/new &quot;postName&quot;#新建一篇文章
$ hexo n/new page &quot;pageName&quot; #新建页面
$ hexo h/help # 查看帮助
$ hexo v/version #查看Hexo的版本</code></pre></li>
<li><p>进入文件之后执行<strong>hexo g</strong>和<strong>hexo s</strong>之后然后用浏览器打开<em><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></em>，不出意外的话，你就可以看到你的博客了，就像下面这个样子的，当然这个博客只是在本地的，hexo3.0使用的默认主题是landscape。</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-22f51ce15050f2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>然后你就可以进行愉快的个性化玩耍了，其中也是各种坑，首先是挑选自己喜欢的<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">主题</a>，然后使用<strong>git clone</strong>下载到本地，就可以开心地设置了。</li>
<li>首先打开hexo文件的_condig.yml配置文件，还有一个是themes主题下你选择主题的配置文件_condig.yml，两个配置文件名一样，但是一个是主配置文件，一个是主题配置文件，不要搞混。</li>
<li>配置过程中也有不少坑，有遇到一个地方多了或者少了个空格什么的导致整个项目不能运行的，还有配置之后没有达到预期效果的，其实只要按照你选择的主题的文档来，仔细一点，基本上是没什么问题的。</li>
<li>当然，我就是按照文档来配置的，中间也是各种各样的问题，但是，基本上都是网上查查就能查到的普通问题。</li>
<li>我选的主题是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next.Picces</a>,配置好之后效果如下所示</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-80b1d4c4eb437f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>有点小清新是不是，嗯，<a href="https://halshaw.github.io/" target="_blank" rel="noopener">地址</a>在此,欢迎来踩。</li>
<li>主题中所包含的功能就已经很多了，比如百度统计、打赏、搜索等功能，只要去找到文件中相对应的地方，然后设置就可以使用了。愚蠢的我一开始还想去自己实现一些功能，但是后来仔细阅读主题文档之后才发现，原来都有啊，其自带的功能已足够满足我等骚年。</li>
<li>所以我又去百度统计、多说、leancloud网站注册之后，然后拿到id之后放在配置文件中相应的地方就可以了，而且还实现了打赏功能，但是并没什么卵用。</li>
<li>使用文档很重要啊，这是我主题的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">使用文档</a>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-b94e68dd00f6f723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li><p>好了，到此，你已经配置好本地，然后预览好之后就可以发布了，使用下面</p>
<pre><code>hexo g
hexo d</code></pre></li>
<li><p>命令就可以啦，但是天有不测风云，遇到错误，</p>
<pre><code>ERROR Deployer not found : github</code></pre></li>
<li><p>不用急，执行一下这条命令就可以，还有可能遇到说你的github地址不是仓库，那是因为你的地址没有设置正确，检查一下空格之类的。</p>
<pre><code>npm install hexo-deployer-git --save</code></pre></li>
<li><p>要想以上命令起作用，前提是你的配置文件已经配置如下，这个是同时发布到Github和Coding上面</p>
<pre><code>deploy:
  type: git
  repo: 
    coding: git@git.coding.net:HalShaw/halshaw.git,master
    github: https://github.com/HalShaw/halshaw.github.io.git,master</code></pre></li>
</ul>
<ul>
<li><p>如果只想发布到GIthub上，稍微改一下</p>
<pre><code>deploy:  
  type: git
  repository: https://github.com/HalShaw/halshaw.github.io.git 
  branch: master</code></pre></li>
<li><p>一切顺利的话，就可以啦。但是，慢着，又出现问题了。命令行返回</p>
<pre><code>Invalid argument        </code></pre></li>
<li><p>what?什么鬼？明明本地都可以成功预览了，但是为什么发布不了了呢，我就被这个<strong>hexo d</strong>搞了好久，查了好久才明白，原因是我在我的hexo目录下，我又执行了</p>
<pre><code>npm install</code></pre></li>
<li><p>又安装了一个hexo，所以不能发布了，所以删除之后就可以高兴滴执行<strong>hexo d</strong>啦。</p>
</li>
<li><p>谢天谢地，终于发布上去了，然而，不到一分钟，我就收到了Github发来的邮件</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-fbd6b116e700b063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>创建page失败，madan，招谁惹谁了我，怎么遇到这么多问题呢。又是一番搜索之后找到了一个我认为满意的答案</p>
<pre><code>- Make a backup of the content locally
- Delete the repository from GitHub
- Delete the repository locally
- Recreate the repository, ensuring that you don&apos;t include the repository within the repository locally, which is what you did previously
- Push it to GitHub</code></pre><ul>
<li>意思就是我git仓库里面又包括其他仓库啦，让我把他们搞好之后再上传，果然，我到主题文件下把.git文件删除之后，然后再次发布，终于，大功告成。就是刚才那个小清新的博客啦。</li>
<li>然后就开始写文章吧，该博客只支持<a href="http://www.jianshu.com/p/q81RER/" target="_blank" rel="noopener">markdown</a>语法，所以不会的小伙伴也不要怕，花个几分钟就可以上手啦。在Git终端输入上面的新建文章命令就可以新建一篇文章啦。然后会显示文章所在路径，找到并打开开始写文章吧。</li>
</ul>
<pre><code>$ hexo n my first
INFO  Created: D:\hexo1\hexo\source\_posts\first.md</code></pre><ul>
<li><p>打开之后是这样的，你可以自己设置标签和分类，然后就开始写你自己的故事吧。</p>
<pre><code>title: my first#标题和日期必须唯一，因为访问文章的url是根据二者生成的
date: 2016-08-25 15:33:58
tags: &apos;try&apos; #标签
categories: &quot;技术&quot; #分类</code></pre></li>
</ul>
<ul>
<li>然后之后写文章每次部署都需要执行如下的命令，需要先清理数据库，生成静态文件之后预览，然后发布。</li>
</ul>
<pre><code>hexo clean
hexo g
hexo s
hexo d</code></pre><ul>
<li>好啦，到这里，文章已经写好，然后发布之后就可以去找小伙伴炫耀啦。</li>
</ul>
<h3 id="本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。"><a href="#本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。" class="headerlink" title="本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。"></a>本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。</h3>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo Blog</tag>
      </tags>
  </entry>
</search>
