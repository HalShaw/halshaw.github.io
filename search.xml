<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深入理解CSS布局之Grid</title>
    <url>/2019/11/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3CSS%E5%B8%83%E5%B1%80%E4%B9%8BGrid/</url>
    <content><![CDATA[<h1 id="一、-前言"><a href="#一、-前言" class="headerlink" title="一、 前言"></a>一、 前言</h1><p>一直听说<code>CSS</code>的<code>Grid</code>布局是一项非常强大的布局技术，不像<code>Flex</code>布局只是一维的系统，<code>Grid</code>布局是个二维的系统，也就是说其可以同时处理行和列。<code>Grid</code>布局分为两个部分，<code>Grid</code>容器（Container）和<code>Grid</code>项目（Items）。</p>
<h1 id="二、-一些重要概念及术语"><a href="#二、-一些重要概念及术语" class="headerlink" title="二、 一些重要概念及术语"></a>二、 一些重要概念及术语</h1><h3 id="Grid-Container"><a href="#Grid-Container" class="headerlink" title="Grid Container"></a>Grid Container</h3><p>应用了<code>display: grid</code>的元素，它是所有<code>grid items</code>的直接父元素，例如：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item item-1"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item item-2"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item item-3"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<h3 id="Grid-Item"><a href="#Grid-Item" class="headerlink" title="Grid Item"></a>Grid Item</h3><p><code>Grid Container</code>的直接后代元素，所有<code>div.item</code>都是，但是<code>p.sun-item</code>不是。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"container"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;&lt;/<span class="keyword">div</span>&gt; </span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">  	&lt;p <span class="built_in">class</span>=<span class="string">"sub-item"</span>&gt;&lt;/p&gt;</span><br><span class="line">  &lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">div</span> <span class="built_in">class</span>=<span class="string">"item"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h3 id="Grid-Line"><a href="#Grid-Line" class="headerlink" title="Grid Line"></a>Grid Line</h3><p>组成<code>Grid</code>结构的分割线，可垂直（<code>column grid lines</code>）可水平（<code>row grid lines</code>）。</p>
<h3 id="Grid-Track"><a href="#Grid-Track" class="headerlink" title="Grid Track"></a>Grid Track</h3><p>两个相邻<code>Grid</code>行之间的距离，其实就是一整行或整列的距离，如第二行与第三行之间的<code>Grid Track</code>就只第二行一整行。</p>
<h3 id="Grid-Cell"><a href="#Grid-Cell" class="headerlink" title="Grid Cell"></a>Grid Cell</h3><p>两个相邻行与相邻列之间的距离，就相当于田字格或九宫格当中的一小格。</p>
<h3 id="Grid-Area"><a href="#Grid-Area" class="headerlink" title="Grid Area"></a>Grid Area</h3><p>四<code>Grid</code>行包围的空间，一个<code>Grid Area</code>可能包含许多<code>grid cells</code>。</p>
<h1 id="三、Grid-属性"><a href="#三、Grid-属性" class="headerlink" title="三、Grid 属性"></a>三、Grid 属性</h1><h3 id="Grid-Container相关"><a href="#Grid-Container相关" class="headerlink" title="Grid Container相关"></a>Grid Container相关</h3><ul>
<li>display</li>
<li>grid-template-columns</li>
<li>grid-template-rows</li>
<li>grid-template-areas</li>
<li>grid-template</li>
<li>grid-column-gap</li>
<li>grid-row-gap</li>
<li>grid-gap</li>
<li>justify-items</li>
<li>align-items</li>
<li>place-items</li>
<li>justify-content</li>
<li>align-content</li>
<li>place-content</li>
<li>grid-auto-columns</li>
<li>grid-auto-rows</li>
<li>grid-auto-flow</li>
<li>grid</li>
</ul>
<h3 id="Grid-Items相关"><a href="#Grid-Items相关" class="headerlink" title="Grid Items相关"></a>Grid Items相关</h3><ul>
<li>grid-column-start</li>
<li>grid-column-end</li>
<li>grid-row-start</li>
<li>grid-row-end</li>
<li>grid-column</li>
<li>grid-row</li>
<li>grid-area</li>
<li>justify-self</li>
<li>align-self</li>
<li>place-self</li>
</ul>
<h1 id="四、具体布局"><a href="#四、具体布局" class="headerlink" title="四、具体布局"></a>四、具体布局</h1><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid | inline-grid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>grid</code>表示生成一个块级<code>grid</code></li>
<li><code>inline-grid</code>表示生成一个行内<code>grid</code></li>
</ul>
<h3 id="grid-template-columns-amp-grid-template-rows"><a href="#grid-template-columns-amp-grid-template-rows" class="headerlink" title="grid-template-columns &amp; grid-template-rows"></a>grid-template-columns &amp; grid-template-rows</h3><figure class="highlight mel"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">  <span class="keyword">grid</span>-template-columns: &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ... | &lt;line-name&gt; &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ...;</span><br><span class="line">  <span class="keyword">grid</span>-template-rows: &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ... | &lt;line-name&gt; &lt;<span class="keyword">track</span>-<span class="keyword">size</span>&gt; ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><track-size></track-size></strong> - 可以是长度值、百分比或者<code>grid</code>中的可用空间的一部分单位<code>fr</code></li>
<li><strong><line-name></line-name></strong> - 一个任意的名字</li>
</ul>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">40px</span> <span class="number">50px</span> auto <span class="number">50px</span> <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">25px</span> <span class="number">25px</span> <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其布局效果如图一所示，<br><img src="https://upload-images.jianshu.io/upload_images/1741029-1348aa9354dbe2ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一"></p>
<p>还可以为每一行或列的距离起个名字，比如：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><span class="line">.<span class="keyword">container</span> &#123;</span><br><span class="line">  grid-template-columns: <span class="comment">[first]</span> 40px <span class="comment">[line2]</span> 50px <span class="comment">[line3]</span> auto <span class="comment">[col4-start]</span> 50px <span class="comment">[five]</span> 40px <span class="comment">[end]</span>;</span><br><span class="line">  grid-template-rows: <span class="comment">[row1-start]</span> 25% <span class="comment">[row1-end]</span> 100px <span class="comment">[third-line]</span> auto <span class="comment">[last-line]</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/1741029-94476deb2dcede4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二"></p>
<p>还可以有多个名字，主要是为了在<code>Items</code>相关的地方方便使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25%</span> [row1-end row2-start] <span class="number">25%</span> [row2-end];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat()"></a>repeat()</h3><p>多个值一致的话可以使用<code>repeat()</code>函数来代替多次重复赋值：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 20px [col-start]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面就相当于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start] <span class="number">20px</span> [col-start];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果多行拥有相同的名字，可以使用名字和数字的语法简化：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: col-start <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fr-单位"><a href="#fr-单位" class="headerlink" title="fr 单位"></a>fr 单位</h3><p><code>fr</code>单位允许将<code>track</code>的尺寸作为一个<code>fraction</code>设置容器剩余可用空间，例如，如下代码会设置每一个项目的宽为容器三分之一的宽度：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>fr</code>所占宽度不包括已分配固定值的宽度，如下，分配给三个<code>fr</code>单位的宽度不包括<code>50px</code>：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">1</span>fr <span class="number">50px</span> <span class="number">1</span>fr <span class="number">1</span>fr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="grid-template-areas"><a href="#grid-template-areas" class="headerlink" title="grid-template-areas"></a>grid-template-areas</h3><p>使用<code>grid-area</code>属性首先定义一个<code>grid</code>模板，重复这些<code>grid</code>区域使其变成一个个<code>cells</code>，<code>.</code>代表一个空的<code>cell</code>，语法自身提供了<code>grid</code>结构的可视化。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"&lt;grid-area-name&gt; | . | none | ..."</span></span><br><span class="line">    <span class="string">"..."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;grid-area-name&gt;</code> 使用<code>grid-area</code>指定区域的名字</li>
<li><code>.</code> 一个空的<code>grid cell</code></li>
<li><code>none</code> 没有<code>grid areas</code>被定义</li>
</ul>
<p>例如：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.item-a</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: header;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-b</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: main;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-c</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: sidebar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-d</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: footer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span> <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: auto;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header header"</span></span><br><span class="line">    <span class="string">"main main . sidebar"</span></span><br><span class="line">    <span class="string">"footer footer footer footer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码生成了一个三行四列的<code>grid</code>容器，第一行为头部区域组成，中间由三部分组成，一部分是<code>main</code>区域，一部分是空<code>cell</code>，另一部分是<code>sidebar</code>，最后一行全是<code>footer</code>，如图：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-54a2979e02ee63b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三"><br>每一行都需要有相同数量的<code>cell</code>，只要空<code>cell</code>之间没有空间，就可以设置任意个<code>.</code> 空<code>cell</code>。<br>注意，如果你的<code>grid</code>区域的名字是<code>foo</code>，其起始行和最终行会被自动命名为<code>foo-start</code>和 <code>foo-end</code>，也就是说一些行可以有多个名字。</p>
<h3 id="grid-template"><a href="#grid-template" class="headerlink" title="grid-template"></a>grid-template</h3><p> <code>grid-template-rows</code>、 <code>grid-template-columns</code>和 <code>grid-template-areas</code>在同一个声明里的缩写。</p>
<ul>
<li><code>none</code> 设置三个属性为其原始值</li>
<li><code>&lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;</code> 设置<code>grid-template-rows</code>和<code>grid-template-columns</code>为指定值，并设置<code>grid-template-areas</code>为<code>none</code>。<br>例如：</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  grid-<span class="keyword">template</span>:</span><br><span class="line">    [row1-start] <span class="string">"header header header"</span> <span class="number">25</span>px [row1-<span class="built_in">end</span>]</span><br><span class="line">    [row2-start] <span class="string">"footer footer footer"</span> <span class="number">25</span>px [row2-<span class="built_in">end</span>]</span><br><span class="line">    / <span class="keyword">auto</span> <span class="number">50</span>px <span class="keyword">auto</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上等价于：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [row1-start] <span class="number">25px</span> [row1-end row2-start] <span class="number">25px</span> [row2-end];</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">50px</span> auto;</span><br><span class="line">  <span class="attribute">grid-template-areas</span>: </span><br><span class="line">    <span class="string">"header header header"</span> </span><br><span class="line">    <span class="string">"footer footer footer"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>！因为<code>grid-template</code>不会重置隐式<code>grid</code>属性（<code>grid-auto-columns</code>，<code>grid-auto-rows</code>， <code>grid-auto-flow</code>），也许正是大部分情况下我们所不想要的，所以建议使用<code>grid</code>属性而不是<code>grid-template</code>属性。</li>
</ul>
<h3 id="grid-column-gap和grid-row-gap"><a href="#grid-column-gap和grid-row-gap" class="headerlink" title="grid-column-gap和grid-row-gap"></a>grid-column-gap和grid-row-gap</h3><p>可以认为就是设置行和列之间的间距：</p>
<pre><code>.container {
  grid-column-gap: &lt;line-size&gt;;
  grid-row-gap: &lt;line-size&gt;;
}</code></pre><p>例如：</p>
<pre><code>.container {
  grid-template-columns: 100px 50px 100px;
  grid-template-rows: 80px auto 80px; 
  grid-column-gap: 10px;
  grid-row-gap: 15px;
}</code></pre><p>！只能设置<code>item</code>之间的间距。不能设置外部边距。<br><img src="https://upload-images.jianshu.io/upload_images/1741029-b46294b5451c2c09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图四"><br>！注意：<code>grid-</code>将会被移除，即<code>grid-column-gap</code>和<code>grid-row-gap</code>将会被重命名为<code>column-gap</code>和<code>row-gap</code>，目前已经支持的浏览器有<code>Chrome 68+</code>，<code>Safari 11.2 Release 50+</code> 和<code>Opera 54+</code>。</p>
<h3 id="grid-gap"><a href="#grid-gap" class="headerlink" title="grid-gap"></a>grid-gap</h3><p><code>grid-column-gap</code>和<code>grid-row-gap</code>的简写版。</p>
<pre><code>.container {
  grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;
}</code></pre><p>例如：</p>
<pre><code>.container {
  grid-template-columns: 100px 50px 100px;
  grid-template-rows: 80px auto 80px; 
  grid-gap: 15px 10px;
}</code></pre><p>如果<code>grid-row-gap</code>或者<code>grid-column-gap</code>值没有被指定，即只给了一个值，二者皆使用该值。同样，<code>grid-</code>前缀也会被移除并重命名为<code>gap</code>。</p>
<h3 id="justify-items-水平对齐"><a href="#justify-items-水平对齐" class="headerlink" title="justify-items 水平对齐"></a>justify-items 水平对齐</h3><pre><code>.container {
  justify-items: start | end | center | stretch;
}</code></pre><ul>
<li><code>start</code> 相当于左对齐</li>
<li><code>end</code> 相当于右对齐</li>
<li><code>center</code> 相当于居中对齐</li>
<li><code>stretch</code> 相当于占满整个<code>cell</code><br>例子：<pre><code>.container {
justify-items: start;
}</code></pre><img src="https://upload-images.jianshu.io/upload_images/1741029-33118e7b74756863.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左对齐"></li>
</ul>
<pre><code>.container {
  justify-items: end;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-11eeaaa01e4c9f75.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="右对其"></p>
<pre><code>.container {
  justify-items: center ;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-c8c54173e304129e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="居中对其"></p>
<pre><code>.container {
  justify-items: stretch;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-0cc3dceb3fdf1039.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="占满空间"></p>
<h3 id="align-items-垂直对齐，与justify-items对应"><a href="#align-items-垂直对齐，与justify-items对应" class="headerlink" title="align-items 垂直对齐，与justify-items对应"></a>align-items 垂直对齐，与justify-items对应</h3><pre><code>.container {
  align-items: start | end | center | stretch;
}</code></pre><h3 id="place-items"><a href="#place-items" class="headerlink" title="place-items"></a>place-items</h3><p><code>place-items</code>同时设置<code>align-items</code>和<code>justify-items</code>的值，类似地，如果只给了一个值，二者皆使用该值。</p>
<ul>
<li><code>&lt;align-items&gt; / &lt;justify-items&gt;</code> 第一个值为<code>align-items</code>，第二个为<code>justify-items</code>，<code>/</code>隔开。</li>
</ul>
<h3 id="justify-content，整体内容水平分布"><a href="#justify-content，整体内容水平分布" class="headerlink" title="justify-content，整体内容水平分布"></a>justify-content，整体内容水平分布</h3><pre><code>.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}</code></pre><ul>
<li><code>start</code> 容器整体内容左对齐</li>
<li><code>end</code> 容器整体内容右对齐</li>
<li><code>center</code> 容器整体内容居中对齐</li>
<li><code>stretch</code> 容器整体内容占满</li>
<li><code>space-around</code> 内容左右均分空间对齐</li>
<li><code>space-between</code> 除了最左和最右两个最外侧没有空间，其余均分剩余空间对齐</li>
<li><code>space-evenly</code> 所有项目均分对齐</li>
</ul>
<pre><code>.container {
  justify-content: start;
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-9d0d51d66134570c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体左对齐"></p>
<pre><code>.container {
  justify-content: end; 
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-8b1e2723140638cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体右对齐"></p>
<pre><code>.container {
  justify-content: center;  
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-42217e1fee81d0e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体居中对齐"></p>
<pre><code>.container {
  justify-content: stretch; 
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-ad675954b395bee1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体占满容器空间"></p>
<pre><code>.container {
  justify-content: space-around;  
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-b8563bfa9bf07c3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="左右皆有间距"></p>
<pre><code>.container {
  justify-content: space-between; 
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-118d5c8cffd9ebab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最外侧没有间距"></p>
<pre><code>.container {
  justify-content: space-evenly;  
}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-e58d57a51c421b8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整体等分间距"></p>
<h3 id="align-content，整体内容垂直分布"><a href="#align-content，整体内容垂直分布" class="headerlink" title="align-content，整体内容垂直分布"></a>align-content，整体内容垂直分布</h3><p>与<code>justify-content</code>类似</p>
<pre><code>.container {
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}</code></pre><h3 id="place-content"><a href="#place-content" class="headerlink" title="place-content"></a>place-content</h3><p><code>place-content</code>同时设置<code>align-content</code>和<code>justify-content</code>的值，类似地，如果只给了一个值，二者皆使用该值。</p>
<ul>
<li><code>&lt;align-content&gt; / &lt;justify-content&gt;</code> 第一个值为<code>align-content</code>，第二个为<code>justify-content</code>，<code>/</code>隔开。</li>
</ul>
<p>除了<code>Edge</code>浏览器，其他主流浏览器都支持<code>place-content</code>缩写属性。</p>
<h3 id="grid-auto-columns和grid-auto-rows"><a href="#grid-auto-columns和grid-auto-rows" class="headerlink" title="grid-auto-columns和grid-auto-rows"></a>grid-auto-columns和grid-auto-rows</h3><p>设置任意自动生成的<code>grid tracks</code>（又被叫做<code>implicit grid tracks</code>）的尺寸，<code>Implicit tracks</code>在<code>grid items</code>的数量多于<code>cells</code>数量的时候被创建出来，或者当一个<code>grid item</code>被放在一个<code>explicit grid</code>外部的时候。</p>
<pre><code>.container {
  grid-auto-columns: &lt;track-size&gt; ...;
  grid-auto-rows: &lt;track-size&gt; ...;
}</code></pre><ul>
<li><strong><track-size></track-size></strong> - 长度、百分比或者<code>fr</code><br>为了描述<code>implicit grid tracks</code>怎样被创建，考虑以下代码：<pre><code>.container {
grid-template-columns: 60px 60px;
grid-template-rows: 90px 90px;
}</code></pre><img src="https://upload-images.jianshu.io/upload_images/1741029-67c6d9e668314e9c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>如图所示，一个<code>2x2</code>的<code>grid</code>布局被创建出来，但是想象一下使用<code>grid-column</code>和<code>grid-row</code> 来进行如下布局：<pre><code>.item-a {
grid-column: 1 / 2;
grid-row: 2 / 3;
}
.item-b {
grid-column: 5 / 6;
grid-row: 2 / 3;
}</code></pre><img src="https://upload-images.jianshu.io/upload_images/1741029-470d5386ca060153.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>我们设置了<code>.item-b</code>从第五列开始到第六列结束，但是我们并没有定义第五列和第六列，只有两列，这个时候，宽度为零的<code>implicit tracks</code>就会被创建出来填满这些<code>gap</code>，此时就可以使用<code>grid-auto-columns</code>和<code>grid-auto-rows</code>来设置这些<code>implicit tracks</code>的宽度，如：<pre><code>.container {
grid-auto-columns: 60px;
}</code></pre><img src="https://upload-images.jianshu.io/upload_images/1741029-5caea9963bf657ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<h3 id="grid-auto-flow"><a href="#grid-auto-flow" class="headerlink" title="grid-auto-flow"></a>grid-auto-flow</h3><p>如果你有没有显示地布局在<code>grid</code>上的<code>grid items</code>，自动布局算法就会自动地将这<code>grid items</code>放进去，这个属性控制着自动布局算法怎样工作。</p>
<pre><code>.container {
  grid-auto-flow: row | column | row dense | column dense;
}</code></pre><ul>
<li><code>row</code> 告诉自动布局算法依次填满每一行，有必要的话可以添加新的行</li>
<li><code>column</code> 告诉自动布局算法依次填满每一列，有必要的话可以添加新的列</li>
<li><code>dense</code> 告诉自动布局算法如果出现比较小的<code>item</code>的话尝试填满之前剩余空间<br>例子：<pre><code>&lt;section class=&quot;container&quot;&gt;
&lt;div class=&quot;item-a&quot;&gt;item-a&lt;/div&gt;
&lt;div class=&quot;item-b&quot;&gt;item-b&lt;/div&gt;
&lt;div class=&quot;item-c&quot;&gt;item-c&lt;/div&gt;
&lt;div class=&quot;item-d&quot;&gt;item-d&lt;/div&gt;
&lt;div class=&quot;item-e&quot;&gt;item-e&lt;/div&gt;
&lt;/section&gt;
</code></pre></li>
</ul>
<p>.container {<br>  display: grid;<br>  grid-template-columns: 60px 60px 60px 60px 60px;<br>  grid-template-rows: 30px 30px;<br>  grid-auto-flow: row; // 优先排满行<br>}</p>
<p>//指定item-a和item-e占两行<br>.item-a {<br>  grid-column: 1;<br>  grid-row: 1 / 3;<br>}<br>.item-e {<br>  grid-column: 5;<br>  grid-row: 1 / 3;<br>}</p>
<pre><code>![优先排满行](https://upload-images.jianshu.io/upload_images/1741029-8a5e076c0310b0f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以把`grid-auto-flow`的值设置成`column`：</code></pre><p>.container {<br>  display: grid;<br>  grid-template-columns: 60px 60px 60px 60px 60px;<br>  grid-template-rows: 30px 30px;<br>  grid-auto-flow: column;<br>}</p>
<pre><code>![优先排满列](https://upload-images.jianshu.io/upload_images/1741029-c5c9f71733a8437c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### grid

`grid-template-rows`+ `grid-template-columns`+ `grid-template-areas`,+`grid-auto-rows`+`grid-auto-columns`+`grid-auto-flow`属性的缩写，可以在同一个`grid `属性里设置显示（`explicit `）或者隐式（`implicit `）`grid`。



## Grid Items
！注意，`float`，`display: inline-block`，`display: table-cell`， `vertical-align` 和`column-*` 属性对`grid item`没有影响。
### grid-column-start、grid-column-end、grid-row-start、grid-row-end
</code></pre><p>.item {<br>  grid-column-start: <number> | <name> | span <number> | span <name> | auto;<br>  grid-column-end: <number> | <name> | span <number> | span <name> | auto;<br>  grid-row-start: <number> | <name> | span <number> | span <name> | auto;<br>  grid-row-end: <number> | <name> | span <number> | span <name> | auto;<br>}</name></number></name></number></name></number></name></number></name></number></name></number></name></number></name></number></p>
<pre><code>- `&lt;line&gt;` 可以是一个`grid line`的数字序号或者名字
- `span &lt;number&gt;` 项目会占满所提供的`grid tracks`的序号
- `span &lt;name&gt;` 项目会占满所提供的`grid tracks`的名字
- `auto` 自动填充

例如：</code></pre><p>.item-a {<br>  grid-column-start: 2;<br>  grid-column-end: five;<br>  grid-row-start: row1-start;<br>  grid-row-end: 3;<br>}</p>
<pre><code>其布局效果如下所示：
![图五](https://upload-images.jianshu.io/upload_images/1741029-d030c44eddd9aa43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre><p>.item-b {<br>  grid-column-start: 1;<br>  grid-column-end: span col4-start;<br>  grid-row-start: 2;<br>  grid-row-end: span 2;<br>}</p>
<pre><code>其布局效果如下所示：
![图六](https://upload-images.jianshu.io/upload_images/1741029-7c0afc52db9432d3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

！如果没有指定`grid-column-end`或者`grid-row-end`，项目会默认自动跨越一个`track `的距离。项目之间可能会相互重叠，可以使用`z-index`来控制显示的顺序。

### grid-column和grid-row
分别是 `grid-column-start` + `grid-column-end`和`grid-row-start` + `grid-row-end`的缩写。</code></pre><p>.item {<br>  grid-column: <start-line> / <end-line> | <start-line> / span <value>;<br>  grid-row: <start-line> / <end-line> | <start-line> / span <value>;<br>}</value></start-line></end-line></start-line></value></start-line></end-line></start-line></p>
<pre><code>- `&lt;start-line&gt; / &lt;end-line&gt;` 所接收的值和前面一致，`start`和`end`的值用`/ `隔开。
例子：</code></pre><p>.item-c {<br>  grid-column: 3 / span 2;<br>  grid-row: third-line / 4;<br>}</p>
<pre><code>![图七](https://upload-images.jianshu.io/upload_images/1741029-f6fae30a7b487b9d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
！如果没有` &lt;end-line&gt;`值，会默认跨越一个`track`。

### grid-area
给项目起个名字让使用`grid-template-areas`属性创建的模板可以调用，另外，这个属性还可以用作`grid-row-start` + `grid-column-start` + `grid-row-end`+`grid-column-end`的缩写。</code></pre><p>.item {<br>  grid-area: <name> | <row-start> / <column-start> / <row-end> / <column-end>;<br>}</column-end></row-end></column-start></row-start></name></p>
<pre><code>- `&lt;name&gt;` 任意名字
- `&lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;` 可以是数字或者名字
取个名：</code></pre><p>.item-d {<br>  grid-area: header;<br>}</p>
<pre><code>`grid-row-start` + `grid-column-start` + `grid-row-end`+`grid-column-end`的缩写：</code></pre><p>.item-d {<br>  grid-area: 1 / col4-start / last-line / 6;<br>}</p>
<pre><code>![图八](https://upload-images.jianshu.io/upload_images/1741029-90596d745fc470c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### justify-self，水平方向
在一个`cell`当中对齐一个`grid item `
</code></pre><p>.item {<br>  justify-self: start | end | center | stretch;<br>}</p>
<pre><code></code></pre><p>.item-a {<br>  justify-self: start;<br>}</p>
<pre><code>![左对齐](https://upload-images.jianshu.io/upload_images/1741029-554879618c2a6d3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre><p>.item-a {<br>  justify-self: end;<br>}</p>
<pre><code>![右对齐](https://upload-images.jianshu.io/upload_images/1741029-e11e9f933088bb44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre><p>.item-a {<br>  justify-self: center ;<br>}</p>
<pre><code>![居中对齐](https://upload-images.jianshu.io/upload_images/1741029-305ada4fe264ac18.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
</code></pre><p>.item-a {<br>  justify-self: stretch;<br>}</p>
<pre><code>![填满整个内容](https://upload-images.jianshu.io/upload_images/1741029-f08359120f1fbe5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### align-self，垂直方向
与` justify-self`类似。</code></pre><p>.item {<br>  align-self: start | end | center | stretch;<br>}</p>
<pre><code>
### place-self
`align-self ` 和`justify-self `的缩写。
- `auto ` 默认对齐方式
- `&lt;align-self&gt; / &lt;justify-self&gt;` 垂直/水平
除了`Edge`浏览器，其他主流浏览器都支持`place-self `缩写属性。

</code></pre>]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS Grid</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之原生AJAX的请求过程具体实现</title>
    <url>/2019/10/28/JS%E4%B9%8B%E5%8E%9F%E7%94%9FAJAX%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、AJAX的请求大致过程"><a href="#一、AJAX的请求大致过程" class="headerlink" title="一、AJAX的请求大致过程"></a>一、AJAX的请求大致过程</h1><ul>
<li>创建一个异步调用<code>XMLHttpRequest</code>对象 </li>
<li>打开一个新的<code>HTTP</code>请求，并指定该<code>HTTP</code>请求的方法、<code>URL</code>及验证信息，设置响应<code>HTTP</code>请求状态变化的函数</li>
<li>发送<code>HTTP</code>请求</li>
<li>获取异步调用返回的数据</li>
<li>使用JavaScript和DOM实现局部刷新</li>
</ul>
<h1 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h1><p>先创建一个兼容各个平台的<code>XMLHttpRequest</code>对象 </p>
<pre><code>function getXHR(){
  var xhr = null;
  if(window.XMLHttpRequest) {// 兼容 IE7+, Firefox, Chrome, Opera, Safari
    xhr = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    try {
      xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;);// 即MSXML3
    } catch (e) {
      try {
        xhr = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);// // 兼容 IE6, IE5，API很老，不建议使用
      } catch (e) {
        alert(&quot;您的浏览器不支持AJAX.&quot;);
      }
    }
  }
  return xhr;
}</code></pre><a id="more"></a>

<p>一个完整的AJAX实现过程：</p>
<pre><code>var xhr = getXHR(); // 创建异步调用对象 
xhr.open(&apos;GET/POST&apos;, url/file, true);  //设置请求方式，url，以及是否异步
xhr.onreadystatechange = function() {   //设置回调监听函数
   if(xhr.readyState==4){ //表示后台处理完成
        if(xhr.status==200){ //表示处理结果是成功的
            var data = xhr.responseText; //获取成功的返回值
             console.log(data);
   }
};
xhr.onerror = function() {
  console.log(&quot;Something is wrong.&quot;);
};
 xhr.send(); </code></pre><h1 id="三、状态码"><a href="#三、状态码" class="headerlink" title="三、状态码"></a>三、状态码</h1><p><code>readyState</code>一共有5中请求状态，从0 到 4 分别表示：</p>
<pre><code>0: 请求未初始化
1: 服务器连接已建立
2: 请求已接收
3: 请求处理中
4: 请求已完成，且响应已就绪</code></pre><p><code>HTTP</code>响应状态码，常见的表示：</p>
<pre><code>200:  成功
304：未修改，该资源在上次请求之后没有任何修改（这通常用于浏览器的缓存机制，使用GET请求时尤其需要注意）。
403：（禁止）服务器拒绝请求。
404：（未找到）服务器找不到请求的网页。
500：（服务器内部错误）服务器遇到错误，无法完成请求。</code></pre><h1 id="四、注意点"><a href="#四、注意点" class="headerlink" title="四、注意点"></a>四、注意点</h1><h3 id="1-xhr-open的参数需熟记："><a href="#1-xhr-open的参数需熟记：" class="headerlink" title="1. xhr.open的参数需熟记："></a>1. <code>xhr.open</code>的参数需熟记：</h3><ul>
<li>method：请求的方法类型，GET 或 POST</li>
<li>url：文件在服务器上的位置，相对位置或绝对位置</li>
<li>async：true 或 false</li>
</ul>
<h3 id="2-post请求与get请求的不同之处"><a href="#2-post请求与get请求的不同之处" class="headerlink" title="2. post请求与get请求的不同之处"></a>2. post请求与get请求的不同之处</h3><p><code>send(string)</code>方法<code>post</code>请求时才需要使用字符串参数，否则不用带参数。</p>
<h3 id="3-post请求一定要设置请求头的格式内容"><a href="#3-post请求一定要设置请求头的格式内容" class="headerlink" title="3. post请求一定要设置请求头的格式内容"></a>3. post请求一定要设置请求头的格式内容</h3><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">xhr.open(<span class="string">"<span class="keyword">POST</span>"</span>, <span class="string">"ajax_test.html"</span>, true);  </span><br><span class="line">xhr.setRequestHeader(<span class="string">"content-type"</span>, <span class="string">"application/x-www-form-urlencoded"</span>);  </span><br><span class="line">xhr.send(<span class="string">"name=Shaw&amp;age=24"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-服务器响应数据格式"><a href="#4-服务器响应数据格式" class="headerlink" title="4. 服务器响应数据格式"></a>4. 服务器响应数据格式</h3><ul>
<li>responseText 字符串形式的响应数据</li>
<li>responseXML XML形式的响应数据</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://juejin.im/post/5bb470295188255c5e66f88f#heading-0" target="_blank" rel="noopener">https://juejin.im/post/5bb470295188255c5e66f88f#heading-0</a><br><a href="https://www.cnblogs.com/jianxian/p/9069804.html" target="_blank" rel="noopener">https://www.cnblogs.com/jianxian/p/9069804.html</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>JS之typeof和instanceof方法具体实现</title>
    <url>/2019/10/27/JS%E4%B9%8Btypeof%E5%92%8Cinstanceof%E6%96%B9%E6%B3%95%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="一、typeof方法的作用"><a href="#一、typeof方法的作用" class="headerlink" title="一、typeof方法的作用"></a>一、typeof方法的作用</h1><ul>
<li>判断变量类型</li>
</ul>
<pre><code>typeof 1 //&quot;number&quot;
typeof &apos;1&apos; //&quot;string&quot;
typeof {} //&quot;object&quot;
typeof true //&quot;boolean&quot;
typeof undefined // &quot;undefined&quot;
typeof null //&quot;object&quot; #bug
typeof Symbol //&quot;function&quot;
typeof Symbol(1) //&quot;symbol&quot;</code></pre><a id="more"></a>

<h1 id="二、typeof方法的具体实现"><a href="#二、typeof方法的具体实现" class="headerlink" title="二、typeof方法的具体实现"></a>二、typeof方法的具体实现</h1><pre><code>if (JSVAL_IS_VOID(v)) {  // (1)
    type = JSTYPE_VOID;
} else if (JSVAL_IS_OBJECT(v)) {  // (2)
    obj = JSVAL_TO_OBJECT(v);
    if (obj &amp;&amp;
        (ops = obj-&gt;map-&gt;ops,
            ops == &amp;js_ObjectOps
            ? (clasp = OBJ_GET_CLASS(cx, obj),
            clasp-&gt;call || clasp == &amp;js_FunctionClass) // (3,4)
            : ops-&gt;call != 0)) {  // (3)
        type = JSTYPE_FUNCTION;
    } else {
        type = JSTYPE_OBJECT;
    }
} else if (JSVAL_IS_NUMBER(v)) {
    type = JSTYPE_NUMBER;
} else if (JSVAL_IS_STRING(v)) {
    type = JSTYPE_STRING;
} else if (JSVAL_IS_BOOLEAN(v)) {
    type = JSTYPE_BOOLEAN;
}</code></pre><p>根据 <code>type tags</code> 的信息，低位是 <code>000</code>，因此 <code>null</code> 被判断成了一个对象。这就是为什么 <code>typeof null</code> 的返回值是 <code>object</code>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof#null" target="_blank" rel="noopener">MDN</a> 有简单的描述解释了原因，而且以后也不会修复这个 <code>bug</code> ，因为修复这个 <code>bug</code> 会带来更多的问题。</p>
<h1 id="三、更准确的类型判断方法"><a href="#三、更准确的类型判断方法" class="headerlink" title="三、更准确的类型判断方法"></a>三、更准确的类型判断方法</h1><p>由于 <code>typeof</code>存在 <code>null</code> 的类型为 <code>object</code>，所以可以用另外一种更加准确的方法来判断基本类型，那就是<code>Object.prototype.toString</code> ：</p>
<pre><code>Object.prototype.toString.call(2) // &quot;[object Number]&quot;

Object.prototype.toString.call(&apos;hello&apos;) // &quot;[object String]&quot;

Object.prototype.toString.call({hello:&apos;hello&apos;}) // &quot;[object Object]&quot;

Object.prototype.toString.call([2,&apos;hello&apos;]) // &quot;[object Array]&quot;

Object.prototype.toString.call(true) // &quot;[object Boolean]&quot;

Object.prototype.toString.call(() =&gt; {}) // &quot;[object Function]&quot;

Object.prototype.toString.call(null) // &quot;[object Null]&quot;

Object.prototype.toString.call(undefined) // &quot;[object Undefined]&quot;

Object.prototype.toString.call(Symbol(2)) // &quot;[object Symbol]&quot;</code></pre><h1 id="四、instanceof方法的作用"><a href="#四、instanceof方法的作用" class="headerlink" title="四、instanceof方法的作用"></a>四、instanceof方法的作用</h1><ul>
<li>判断一个引用是否属于某个构造函数</li>
<li>判断继承关系中一个实例是否属于其父类<br>比如：</li>
</ul>
<pre><code>const Animal = function(type) {
  this.type = type;
}
const cat= new Animal(&apos;cat&apos;);
console.log(cat instanceof Animal);  //true
console.log(cat instanceof Object); //true</code></pre><h1 id="五、如何实现一个instanceof方法"><a href="#五、如何实现一个instanceof方法" class="headerlink" title="五、如何实现一个instanceof方法"></a>五、如何实现一个instanceof方法</h1><pre><code>function myInstanceof(leftVaule, rightVaule) { 
    let rightProto = rightVaule.prototype; // 取右边 prototype的值
    leftVaule = leftVaule.__proto__; // 取左边__proto__值
    while (true) {
        if (leftVaule === null) { //如果左边的__proto__值为null，返回false
            return false;    
        }
        if (leftVaule === rightProto) { //如果左边的__proto__值等于右边prototype的值，返回true
            return true;    
        } 
        leftVaule = leftVaule.__proto__ ; //以上都不满足，取上一层原型继续循环，直到没取到为null
    }
}</code></pre><p>其实说白了就是在实例的原型链上面去找，看到底有没有找到右边的原型，找到了就返回 <code>true</code>，没找到或者左边不存在原型链，就返回 <code>false</code>。<br>例子：</p>
<pre><code>function Foo() {
}

myInstanceof(Object, Object) // true
myInstanceof(Function , Function)  // true
myInstanceof(Function , Object ) // true
myInstanceof(Foo, Foo) // false
myInstanceof(Foo, Object) // true
myInstanceof(Foo, Function) // true</code></pre><h1 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h1><p><code>typeof</code> 和 <code>instanceof</code> 可以用来判断一些基本类型及原型链的实例与原型之间的关系，但是使用的时候也需要很小心，因为一些潜在的问题会导致意外的问题出现，比如数组的判断：</p>
<pre><code>[1,2] instanceof Array //true
[1,2] instanceof Object //true</code></pre><p>这是因为</p>
<pre><code>Array instanceof  Object //true</code></pre><p>可能这并不是我们想要的结果，所以可以使用更加准确的判断方法 <code>Object.prototype.toString.call</code>：</p>
<pre><code>Object.prototype.toString.call( [1,2,3] ) //&quot;[object Array]&quot;</code></pre><p>此外，<code>instanceof</code> 方法的具体实现需熟练掌握。</p>
<h1 id="七、参考"><a href="#七、参考" class="headerlink" title="七、参考"></a>七、参考</h1><p><a href="https://juejin.im/post/5b0b9b9051882515773ae714" target="_blank" rel="noopener">https://juejin.im/post/5b0b9b9051882515773ae714</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript typeof instanceof</tag>
      </tags>
  </entry>
  <entry>
    <title>前端框架路由实现的Hash和History两种模式的区别</title>
    <url>/2019/10/18/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E7%9A%84Hash%E5%92%8CHistory%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-9e5d1063264044c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Hash vs History"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><ul>
<li>之前面试的时候就有准备过前端框架中两种路由实现方式及区别，但是当时没专门下功夫去深入了解，就在网上搜了下别人总结的临时抱了下佛脚。但是事实证明，出来混，总是要还的，在后来的面试中又遇到了，而且这次问得更加深入，仅仅靠死记硬背来的知识总是遗忘得很快，网上别人总结的东西终归还是别人的，鉴于网上别人总结的内容有点杂乱无章，还是决定自己在此总结记录一番，以加深印象。</li>
</ul>
<h1 id="一、何为前端路由"><a href="#一、何为前端路由" class="headerlink" title="一、何为前端路由"></a>一、何为前端路由</h1><ul>
<li>路由的概念来自于服务器端，在SPA（单页应用）中，路由描述的是URL到函数的映射关系，即在浏览器中输入一个URL，相应的控制器会对提交的请求进行解析，然后进行路由匹配，找到对应的模块和函数进行执行。</li>
</ul>
<h1 id="二、如何实现"><a href="#二、如何实现" class="headerlink" title="二、如何实现"></a>二、如何实现</h1><ul>
<li>实现的两个核心问题是如何检测路由变化和如何改变URL而不刷新页面，通常有两种实现模式，一种是Hash模式，一种是History模式。</li>
</ul>
<a id="more"></a>

<h1 id="三、Hash模式"><a href="#三、Hash模式" class="headerlink" title="三、Hash模式"></a>三、Hash模式</h1><ul>
<li>早期的前端路由的实现就是基于<code>location.hash</code>来实现的，<code>location.hash</code>的值就是URL中#后面的内容<br>其实现原理就是监听#后面的内容来发起Ajax请求来进行局部更新，而不需要刷新整个页面。</li>
<li>使用<code>hashchange</code>事件来监听 URL 的变化，以下这几种情况改变 URL 都会触发 <code>hashchange</code> 事件：浏览器前进后退改变 URL、<code>&lt;a&gt;</code>标签改变 URL、window.location改变URL。</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>兼容低版本浏览器，Angular1.x和Vue默认使用的就是hash路由</li>
<li>只有#符号之前的内容才会包含在请求中被发送到后端，也就是说就算后端没有对路由全覆盖，但是不会返回404错误</li>
<li>hash值的改变，都会在浏览器的访问历史中增加一个记录，所以可以通过浏览器的回退、前进按钮控制hash的切换</li>
<li>会覆盖锚点定位元素的功能</li>
<li>不太美观，#后面传输的数据复杂的话会出现问题</li>
</ul>
<h1 id="四、History模式"><a href="#四、History模式" class="headerlink" title="四、History模式"></a>四、History模式</h1><ul>
<li>history 提供了 <code>pushState</code> 和 <code>replaceState</code> 两个方法来记录路由状态，这两个方法改变 URL 不会引起页面刷新</li>
<li>history 提供类似 hashchange 事件的 popstate 事件，但 popstate 事件有些不同：通过浏览器前进后退改变 URL 时会触发 popstate 事件，通过pushState/replaceState或<code>&lt;a&gt;</code>标签改变 URL 不会触发 popstate 事件。好在我们可以拦截 pushState/replaceState的调用和<code>&lt;a&gt;</code>标签的点击事件来检测 URL 变化，所以监听 URL 变化可以实现，只是没有 hashchange 那么方便。</li>
<li><code>pushState(state, title, url)</code> 和 <code>replaceState(state, title, url)</code>都可以接受三个相同的参数：</li>
<li>state：需要保存的数据，这个数据在触发popstate事件时，可以在event.state里获取<ul>
<li>title：标题，基本没用，一般传 null</li>
</ul>
</li>
<li>url：设定新的历史记录的 url，新的 url 与当前 url 的 origin 必须是一样的，否则会抛错，url可以是绝对路径，也可以是相对路径。</li>
</ul>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>使用简单，比较美观</li>
<li><code>pushState()</code>设置新的URL可以是任意与当前URL同源的URL，而hash只能改变#后面的内容，因此只能设置与当前URL同文档的URL</li>
<li><code>pushState()</code>设置的URL与当前URL一模一样时也会被添加到历史记录栈中，而hash#后面的内容必须被修改才会被添加到新的记录栈中</li>
<li><code>pushState()</code>可以通过<code>stateObject</code>参数添加任意类型的数据到记录中，而hash只能添加短字符串</li>
<li><code>pushState()</code>可额外设置title属性供后续使用</li>
<li>前端的URL必须和向发送请求后端URL保持一致，否则会报404错误</li>
<li>由于History API的缘故，低版本浏览器有兼容行问题</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://www.jianshu.com/p/d2aa8fb951e4" target="_blank" rel="noopener">https://www.jianshu.com/p/d2aa8fb951e4</a></li>
<li><a href="https://blog.csdn.net/Benjamin920813/article/details/82764664" target="_blank" rel="noopener">https://blog.csdn.net/Benjamin920813/article/details/82764664</a></li>
<li><a href="https://www.cnblogs.com/lguow/p/10921564.html" target="_blank" rel="noopener">https://www.cnblogs.com/lguow/p/10921564.html</a></li>
<li><a href="https://www.cnblogs.com/funny-code123/p/9599793.html" target="_blank" rel="noopener">https://www.cnblogs.com/funny-code123/p/9599793.html</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript 前端 路由 Angular Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>你不知道的JavaScript中卷-读书笔记</title>
    <url>/2019/10/07/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JS%E4%B8%AD%E5%8D%B7/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-8c92a4538cc134eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JavaScript"></p>
<h1 id="基本类型值"><a href="#基本类型值" class="headerlink" title="基本类型值"></a>基本类型值</h1><ul>
<li><p>有一个坑常常被提到，[] + {}，{} +[]，它们返回不同的结果，分别是”[object Object]”，0。</p>
</li>
<li><p>if (a) { foo(); }可以写成a &amp;&amp; foo()a = b || “something” 和a &amp;&amp; b() 用到了“短路”机制。</p>
</li>
<li><p>== 允许在相等比较中进行强制类型转换，===不允许。</p>
</li>
<li><p>NaN 不等于NaN</p>
</li>
<li><p>+0 等于-0</p>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>我个人建议无论什么情况下都不要使== true 和 == false。</p>
</li>
<li><p>(1) 如果x 为null，y 为undefined，则结果为true。</p>
</li>
<li><p>(2) 如果x 为undefined，y 为null，则结果为true。</p>
<pre><code>&quot;0&quot; == null; // false
&quot;0&quot; == undefined; // false
&quot;0&quot; == false; // true -- 晕！
&quot;0&quot; == NaN; // false
&quot;0&quot; == 0; // true
&quot;0&quot; == &quot;&quot;; // false
false == null; // false
false == undefined; // false
false == NaN; // false
false == 0; // true -- 晕！
false == &quot;&quot;; // true -- 晕！
false == []; // true -- 晕！
false == {}; // false

&quot;&quot; == null; // false
&quot;&quot; == undefined; // false
&quot;&quot; == NaN; // false
&quot;&quot; == 0; // true -- 晕！
&quot;&quot; == []; // true -- 晕！
&quot;&quot; == {}; // false
0 == null; // false
0 == undefined; // false
0 == NaN; // false
0 == []; // true -- 晕！
0 == {}; // false

&quot;0&quot; == false; // true -- 晕！
false == 0; // true -- 晕！
false == &quot;&quot;; // true -- 晕！
false == []; // true -- 晕！
&quot;&quot; == 0; // true -- 晕！
&quot;&quot; == []; // true -- 晕！
0 == []; // true -- 晕！</code></pre></li>
</ul>
<ul>
<li><p>[] == ![] // true</p>
</li>
<li><p>根据ToBoolean 规则，它会进行布尔值的显式强制类型转换（同时反转奇偶校验位）。所以[] == ![] 变成了[] == false。前面我们讲过false == []，最后的结果就顺理成章了。</p>
<p>  2 == [2]; // true<br>  “” == [null]; // true</p>
</li>
<li><p>如果两边的值中有true 或者false，千万不要使用==。</p>
</li>
<li><p>如果两边的值中有[]、”” 或者0，尽量不要使用==。</p>
</li>
<li><p>字符串常量中允许的最大字符数（并非只是针对字符串值）；</p>
</li>
<li><p>可以作为参数传递到函数中的数据大小（也称为栈大小，以字节为单位）；</p>
</li>
<li><p>函数声明中的参数个数；</p>
</li>
<li><p>未经优化的调用栈（例如递归）的最大层数，即函数调用链的最大长度；</p>
</li>
<li><p>JavaScript 程序以阻塞方式在浏览器中运行的最长时间（秒）；</p>
</li>
<li><p>变量名的最大长度。</p>
</li>
<li><p>对多数开发者来说，错误处理最自然的形式就是同步的try..catch 结构。遗憾的是，它只能是同步的，无法用于异步代码模式。</p>
</li>
</ul>
<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><ul>
<li><p>传给Promise.all([ .. ]) 的数组中的值可以是Promise、thenable，甚至是立即值。就本质而言，列表中的每个值都会通过Promise.resolve(..) 过滤，以确保要等待的是一个真正的Promise，所以立即值会被规范化为为这个值构建的Promise。</p>
</li>
<li><p>与Promise.all([ .. ]) 类似，一旦有任何一个Promise 决议为完成，Promise.race([ .. ])就会完成；一旦有任何一个Promise 决议为拒绝，它就会拒绝。</p>
</li>
<li><p>Promise.race([ .. ]) 也接受单个数组参数。这个数组由一个或多个Promise、thenable 或立即值组成。要注意，永远不要递送空数组。</p>
<p>  p.then( fulfilled );<br>  p.then( fulfilled, rejected );<br>  p.catch( rejected ); // 或者p.then( null, rejected )</p>
</li>
<li><p>对Promise.all([ .. ]) 来说，只有传入的所有promise 都完成，返回promise 才能完成。如果有任何promise被拒绝，返回的主promise就立即会被拒绝（抛弃任何其他promise 的结果）。</p>
</li>
<li><p>当心！若向Promise.all([ .. ]) 传入空数组，它会立即完成，但Promise.race([ .. ]) 会挂住，且永远不会决议。</p>
<pre><code>var p1 = Promise.resolve( 42 );
var p2 = Promise.resolve( &quot;Hello World&quot; );
var p3 = Promise.reject( &quot;Oops&quot; );
Promise.race( [p1,p2,p3] )
.then( function(msg){
console.log( msg ); // 42
} );
Promise.all( [p1,p2,p3] )
.catch( function(err){
console.error( err ); // &quot;Oops&quot;
} );
Promise.all( [p1,p2] )
.then( function(msgs){
console.log( msgs ); // [42,&quot;Hello World&quot;]
} );</code></pre></li>
<li><p>Promise 局限性:</p>
</li>
<li><p>顺序错误处理，如果没有错误处理，错误会一直往下传递</p>
</li>
<li><p>单一值</p>
</li>
<li><p>单决议，Promise 只能被决议一次（完成或拒绝）</p>
</li>
<li><p>惯性，运动状态（使用回调的）的代码库会一直保持运动状态（使用回调的），直到受到一位聪明的、理解Promise 的开发者的作用。</p>
</li>
<li><p>无法取消，一旦创建了一个Promise 并为其注册了完成和/ 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。</p>
</li>
</ul>
<h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><ul>
<li><p>生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。<br>yield .. 和next(..) 这一对组合起来，在生成器的执行过程中构成了一个双向消息传递系统。<br>使用生成器的话，交替执行（甚至在语句当中！）显然是可能的。</p>
</li>
<li><p>生成器实现标准的迭代器接口:</p>
</li>
</ul>
<pre><code>var something = (function(){
var nextVal;
return {
// for..of循环需要
[Symbol.iterator]: function(){ return this; },
// 标准迭代器接口方法
next: function(){
if (nextVal === undefined) {
nextVal = 1;
}
else {
nextVal = (3 * nextVal) + 6;
}
return { done:false, value:nextVal };
}
};
})();

something.next().value; // 1
something.next().value; // 9
something.next().value; // 33
something.next().value; // 105</code></pre><ul>
<li><p>yield 委托的主要目的是代码组织，以达到与普通函数调用的对称。</p>
</li>
<li><p>生成器是ES6 的一个新的函数类型，它并不像普通函数那样总是运行到结束。取而代之的是，生成器可以在运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。</p>
</li>
<li><p>这种交替的暂停和恢复是合作性的而不是抢占式的，这意味着生成器具有独一无二的能力来暂停自身，这是通过关键字yield 实现的。不过，只有控制生成器的迭代器具有恢复生成器的能力（通过next(..)）。</p>
</li>
<li><p>yield/next(..) 这一对不只是一种控制机制，实际上也是一种双向消息传递机制。yield .. 表达式本质上是暂停下来等待某个值，接下来的next(..) 调用会向被暂停的yield 表达式传回一个值（或者是隐式的undefined）。</p>
</li>
<li><p>在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步/ 顺序方式表达任务的一系列步骤。其技巧在于，我们把可能的异步隐藏在了关键字yield 的后面，把异步移动到控制生成器的迭代器的代码部分。</p>
</li>
<li><p>换句话说，生成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得大脑可以更自然地追踪代码，解决了基于回调的异步的两个关键缺陷之一。</p>
</li>
</ul>
<p>• 如果要比较的两个值的任意一个（即一边）可能是true 或者false 值，那么要避免使<br>用==，而使用===。<br>• 如果要比较的两个值中的任意一个可能是特定值（0、”” 或者[]——空数组），那么避<br>免使用==，而使用===。<br>• 在所有其他情况下，使用== 都是安全的。不仅仅只是安全而已，这在很多情况下也会<br>简化代码，提高代码的可读性。</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Notes 你不知道的JavaScript中卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Babel 7.5新特性之动态引入和F#管道</title>
    <url>/2019/08/26/Babel7.5%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8B%E5%8A%A8%E6%80%81%E5%BC%95%E5%85%A5%E5%92%8CF%E7%AE%A1%E9%81%93/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-16b74fc4346ad169.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Babel"></p>
<h1 id="一、目录"><a href="#一、目录" class="headerlink" title="一、目录"></a>一、目录</h1><ul>
<li>F#管道操作符</li>
<li>动态导入</li>
</ul>
<h1 id="二、F-管道操作符"><a href="#二、F-管道操作符" class="headerlink" title="二、F#管道操作符"></a>二、F#管道操作符</h1><p>管道操作符提议还在第一阶段的开发中，同时也意味着其规范还在定义中。Babel 从<code>7.3.0</code> 版本已经支持了管道的变形<code>Smart</code>，以及<code>7.0.0-beta</code>版本以来的<code>minimal</code>变形，并且现在又有了新的<code>F#</code>变形。</p>
<p><code>F#</code>的变形不同于已经存在的<code>smart</code>变形，为何呢?与之前的话题引用（<code>topic references</code>）的概念相比，我们将使用箭头函数来代替。最明显的一个优势就是其更像当今的JavaScript ，并且有着更简洁的语法。换而言之，管道操作符是用在单个参数函数调用时非常有用的且必不可少的语法糖。<br>也就意味着：</p>
<pre><code>sqrt(64)

// 等于

64 |&gt; sqrt</code></pre><p>以上语法的好处就是当链接多个函数的时候可以使代码更具可读性，这就是管道操作符的最明显的作用。</p>
<a id="more"></a>

<h3 id="考虑以下几行代码："><a href="#考虑以下几行代码：" class="headerlink" title="考虑以下几行代码："></a>考虑以下几行代码：</h3><pre><code>function doubleSay (str) {
  return str + &quot;, &quot; + str;
}
function capitalize (str) {
  return str[0].toUpperCase() + str.substring(1);
}
function exclaim (str) {
  return str + &apos;!&apos;;
}</code></pre><p>以下是上面这些函数的调用：</p>
<pre><code>let result = exclaim(capitalize(doubleSay(&quot;hello&quot;)));
console.log(result) //=&gt; &quot;Hello, hello!&quot;</code></pre><p>可以使用<code>F#</code>变形来优化：</p>
<pre><code>let result = &quot;hello&quot;
  |&gt; doubleSay
  |&gt; capitalize
  |&gt; exclaim;
console.log(result) //=&gt; &quot;Hello, hello!&quot;</code></pre><h3 id="多参数的F"><a href="#多参数的F" class="headerlink" title="多参数的F#"></a>多参数的<code>F#</code></h3><p>这种特殊解决方法的好处就是管道操作符不需对多参数函数做任何处理，只管扔给JavaScript就好了：</p>
<pre><code>function double (x) { return x + x; }
function add (x, y) { return x + y; }

function boundScore (min, max, score) {
  return Math.max(min, Math.min(max, score));
}</code></pre><p>可以使用<code>smart</code> 变形来调用：</p>
<pre><code>let person = { score: 25 };
let newScore = boundScore( 0, 100, add(7, double(person.score)))
console.log(newScore) //=&gt; 57</code></pre><p>管道操作符提供的新的或者说更好的与之前的<code>smart</code> 变形截然相反的方法是因为我们可以使用箭头函数，可以用来处理多参数函数，比如： <code>add()</code> 和 <code>boundScore()</code>：</p>
<pre><code>let person = { score: 25 };
let newScore = person.score
  |&gt; double
  |&gt; (n =&gt; add(7, n))
  |&gt; (n =&gt; boundScore(0, 100, n));
console.log(newScore) //=&gt; 57</code></pre><p>尽管可以用来处理多个参数的函数，但是通常推荐用来处理单参数函数，因为管道操作符每次只返回一个结果。</p>
<h3 id="与部分应用语法（Partial-Application-Syntax）一起使用"><a href="#与部分应用语法（Partial-Application-Syntax）一起使用" class="headerlink" title="与部分应用语法（Partial Application Syntax）一起使用"></a>与部分应用语法（Partial Application Syntax）一起使用</h3><p>部分应用语法提出（目前还在第一阶段），在一个通过参数占位符来实现允许部分应用参数列表来调用表达式的参数列表中使用了<code>?</code>操作符来引入的一种新的语法。<br>如果部分语法提议通过审核，也就意味着管道操作符就将会是一种更好更准确的处理之前提到过的函数的方法，即：</p>
<p>不用这么写：</p>
<pre><code>let person = { score: 25 };
let newScore = person.score
  |&gt; double
  |&gt; (n =&gt; add(7, n))
  |&gt; (n =&gt; boundScore(0, 100, n));
console.log(newScore) //=&gt; 57</code></pre><p>可以直接使用<code>?</code>操作符来替换任意参数来这样写：</p>
<pre><code>let person = { score: 25 };
let newScore = person.score
  |&gt; double
  |&gt; add(7, ?)
  |&gt; boundScore(0, 100, ?);
console.log(newScore) //=&gt; 57</code></pre><p>后者更加简单明了，但是先别高兴得太早，目前只是提议阶段，还未完全确定，拭目以待。</p>
<h3 id="与Await一起使用"><a href="#与Await一起使用" class="headerlink" title="与Await一起使用"></a>与Await一起使用</h3><p>每一个提议对于管道中的<code>await</code>都有不同的解决方案，<code>F#</code>变形也不例外，它处理<code>await</code>的方式和<code>smart</code>有点类似但是也有不同之处：</p>
<pre><code>// Smart Pipeline
let newScore = fetch(url)
  |&gt; await #
  |&gt; #.json()
  |&gt; await #
  |&gt; #.ID;</code></pre><p>F# 管道引入箭头函数来处理这些案例：</p>
<pre><code>// F# pipe line
let newScore = fetch(url)
  |&gt; await
  |&gt; r =&gt; r.json()
  |&gt; await
  |&gt; obj =&gt; obj.ID;</code></pre><h3 id="开始尝试-F-管道操作符"><a href="#开始尝试-F-管道操作符" class="headerlink" title="开始尝试 F# 管道操作符"></a>开始尝试 F# 管道操作符</h3><p>可以简单修改<code>babel.config</code>文件然后加入管道操作符插件来使用：</p>
<pre><code>module.exports = {
  plugins: [
    [&quot;@babel/proposal-pipeline-operator&quot;, { proposal: &quot;fsharp&quot; }]
  ]
};</code></pre><h3 id="更多关于此提议-特性"><a href="#更多关于此提议-特性" class="headerlink" title="更多关于此提议/特性"></a>更多关于此提议/特性</h3><p><a href>https://babeljs.io/blog/2019/07/03/7.5.0#f-pipeline-operator-9450-https-githubcom-babel-babel-pull-9450-and-9984-https-githubcom-babel-babel-pull-9984</a></p>
<h1 id="三、动态引入"><a href="#三、动态引入" class="headerlink" title="三、动态引入"></a>三、动态引入</h1><p>在新提议之前：<br>1.如果你使用<code>webpack</code>或者<code>rollup</code>来实现动态引入，需要包含<code>@babel/plugin-syntax-dynamic-import</code>并且不能用<code>babel</code>转化<br>2.如果你使用<code>Node</code>，可以使用<code>babel-plugin-dynamic-import-node</code>插件来转化</p>
<p>在这里讨论的重点时，对于每一个模块来说，可以有不同的方法来转化。通常，是使用唯一的转化插件来转化模块的。大意是，新的动态导入的提议提供了一种结合上述几种用例的方法，一个单一的<code>entry point</code> <code>@babel/plugin-proposal-dynamic-import</code>。</p>
<p>这样，我们就有了一个可以转化所有模块(Webpack, Roll up, Node 等等)可重用的插件。这个插件必须和模块转化插件一起使用，因为<code>Babel</code>需要识别你需要转化的是哪一种模块加载系统。</p>
<p>一个关于AMD有效配置的例子：</p>
<pre><code>module.exports = {
  plugins: [
    &quot;@babel/plugin-proposal-dynamic-import&quot;,
    &quot;@babel/plugin-transform-modules-amd&quot;
  ]
};</code></pre><p> <code>&quot;@babel/plugin-transform-modules-amd&quot;</code>指明了目标模块是AMD类型的，如果不指定的话，<code>Babel</code>将无法识别目标模块是 <code>Node</code> 还是 <code>Rollup</code>，如果你只是解析<code>import()</code>表达式，而不是转化的话，可以只指定<code>@babel/plugin-syntax-dynamic-import</code>。</p>
<p>动态引入在使用<code>@babel/preset-env</code>时默认开启，也无需考虑是否支持<code>webpack</code>或者<code>rollup</code>，<code>babel-loader</code> 和 <code>rollup-plugin-babel</code>都会为了使其他<code>bundler</code>正确处理<code>Babel</code>而自动关闭其转化功能。</p>
<h1 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h1><p><a href="https://scotch.io/bar-talk/dynamic-imports-and-f-pipes-officially-land-in-babel-75" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Babel</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JS中的事件发射器（Event Emitters）</title>
    <url>/2019/08/22/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%8F%91%E5%B0%84%E5%99%A8/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-84f3e55abfbaba7a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Event Emitter"></p>
<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>先看一个<code>DOM</code>事件:</p>
<pre><code>const button = document.querySelector(&quot;button&quot;);

button.addEventListener(&quot;click&quot;, (event) =&gt; /* do something with the event */)</code></pre><p>以上代码在<code>button</code>上添加了一个事件监听器，每当点击<code>button</code>的时候，点击事件被触发出去并且同时调用<code>callback</code>函数。</p>
<p>有很多时候可能会有需要触发自定义事件的需求，不单单只是一个点击事件，假设有这样一个需要触发一个基于其他触发器的事件，并且需要有一个事件响应的，可以自定义一个<code>event emitter</code>来实现。</p>
<a id="more"></a>

<p>一个<code>event emitter</code>就是监听一个<code>event</code>，触发一个回调函数，然后<code>emit</code>一个带有<code>value</code>的事件的一种模式，有时候也称为<code>pub/sub</code>模型或者监听器。</p>
<p>在JavaScript中的一种实现如下：</p>
<pre><code>let n = 0;
const event = new EventEmitter();

event.subscribe(&quot;THUNDER_ON_THE_MOUNTAIN&quot;, value =&gt; (n = value));

event.emit(&quot;THUNDER_ON_THE_MOUNTAIN&quot;, 18);

// n: 18

event.emit(&quot;THUNDER_ON_THE_MOUNTAIN&quot;, 5);

// n: 5</code></pre><p>在上面的代码中，我们订阅了一个叫做 <code>THUNDER_ON_THE_MOUNTAIN</code>的事件，并且当事件被 <code>emitted</code> 的时候，回调函数 <code>value =&gt; (n = value)</code> 也会被触发，可以调用 <code>emit()</code>来<code>emit</code>该事件。</p>
<p>这在与异步代码交互的时候，如果有不在当前模块下的值需要更新时十分有用。</p>
<p>一个真实的例子就是<a href="https://react-redux.js.org/" target="_blank" rel="noopener">React Redux</a>，<br><code>Redux</code>需要一种通知外部其内部的值已经更新的机制，其允许<code>React</code>调用<code>setState()</code>并重新渲染UI来获取哪些值已经改变，这个地方也是使用<code>event emitter</code>来实现的。<br><code>Redux store</code>有一个传入一个提供新的<code>store</code>的回调函数作为参数的订阅函数，在这个订阅函数中，调用了 <code>React Redux</code>的以新<code>store</code>的值调用了<code>setState()</code>方法的 <code>&lt;Provider&gt;</code> 组件，可以<a href="https://github.com/reduxjs/react-redux/blob/master/src/components/Provider.js#L36" target="_blank" rel="noopener">在此</a>查看。</p>
<p>现在我们的应用有了两个不同的部分，一部分是<code>React UI</code>，另一部分是<code>Redux store</code>，谁也说不清楚事件究竟是被那一部分触发的。</p>
<h1 id="二、实现"><a href="#二、实现" class="headerlink" title="二、实现"></a>二、实现</h1><p>先看一个简单的<code>event emitter</code>，其中使用了<code>class</code>，在这个<code>class</code>中跟踪事件。</p>
<pre><code>class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
    }
}</code></pre><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>定义一个事件接口，用来存储一个每一个<code>key</code>都是一个事件名并且各自的值都是回调函数组成的数组的空白对象。</p>
<pre><code>interface Events {
  [key: string]: Function[];
}

{
  &quot;event&quot;: [fn],
  &quot;event_two&quot;: [fn]
}</code></pre><p>使用数组的原因是因为每一个事件都可能有多个<code>subscriber</code>，因为<code>element.addEventLister(&quot;click&quot;)</code>可能会被多次调用。</p>
<h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><p>现在需要处理订阅的事件，在上面的例子中，<code>subscribe()</code>函数接收两个参数：一个<code>name</code>和一个<code>callback</code>函数。</p>
<pre><code>event.subscribe(&quot;named event&quot;, value =&gt; value);</code></pre><p>定义一个<code>subscribe</code>方法来接收这两个参数，只需把这两个参数添加到类内部的<code>this.events</code>。</p>
<pre><code>class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
    }

    public subscribe(name: string, cb: Function) {
        (this.events[name] || (this.events[name] = [])).push(cb);
    }
}</code></pre><h3 id="发射"><a href="#发射" class="headerlink" title="发射"></a>发射</h3><p>到此可以订阅事件了，接下来，当一个新事件发射的时候需要触发回调函数，当触发的时候，将使用<code>(emit(&quot;event&quot;))</code>中存储的事件名和需要传递到回调函数<code>(emit(&quot;event&quot;, value))</code>的任意值，我们可以简单地传递任意参数到回调函数在第一个参数后面。</p>
<pre><code>class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
  }

    public subscribe(name: string, cb: Function) {
        (this.events[name] || (this.events[name] = [])).push(cb);
    }

    public emit(name: string, ...args: any[]): void {
        (this.events[name] || []).forEach(fn =&gt; fn(...args));
    }
}</code></pre><p>既然我们知道了我们希望发射的事件，可以使用<code>this.events[name]</code>来查看，返回的是一个回调函数的数组。</p>
<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><pre><code>subscribe(name: string, cb: Function) {
    (this.events[name] || (this.events[name] = [])).push(cb);

    return {
        unsubscribe: () =&gt;
        this.events[name] &amp;&amp; this.events[name].splice(this.events[name].indexOf(cb) &gt;&gt;&gt; 0, 1)
    };
}</code></pre><p>上述代码返回一个带有<code>unsubscribe</code>方法的对象，可以使用箭头函数<code>() =&gt;</code>来获取传递给父对象参数的作用域，在这个函数中，使用<code>&gt;&gt;&gt;</code><a href="https://stackoverflow.com/questions/1822350/what-is-the-javascript-operator-and-how-do-you-use-it" target="_blank" rel="noopener">操作符</a>可以找到传递给父级回调函数的索引，在这里使用可以保证我们每次在回调函数数组上调用<code>splice()</code> 的时候总是可以取到一个真正的数字，即使<code>indexOf()</code> 都不能返回数字也行。<br>可以这样使用：</p>
<pre><code>const subscription = event.subscribe(&quot;event&quot;, value =&gt; value);

subscription.unsubscribe();</code></pre><p>到此，我们就可以取消这一个特别的订阅了，而且不影响其他的订阅。</p>
<h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><pre><code>interface Events {
    [key: string]: Function[];
}

export class EventEmitter {
    public events: Events;
    constructor(events?: Events) {
        this.events = events || {};
    }

    public subscribe(name: string, cb: Function) {
        (this.events[name] || (this.events[name] = [])).push(cb);

    return {
        unsubscribe: () =&gt;
            this.events[name] &amp;&amp; this.events[name].splice(this.events[name].indexOf(cb) &gt;&gt;&gt; 0, 1)
    };
}

    public emit(name: string, ...args: any[]): void {
        (this.events[name] || []).forEach(fn =&gt; fn(...args));
    }
}</code></pre><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p><a href="https://codepen.io/charliewilco/pen/gEoErR" target="_blank" rel="noopener">https://codepen.io/charliewilco/pen/gEoErR</a></p>
<p>上述代码中，首先在另外一个事件回调中使用了<code>event emitter</code>，在这种情况下，一个<code>event emitter</code>是用来清除一些逻辑，在GitHub上选择一个仓库，获取详情，缓存详情，并更新DOM去显示这些详情。在订阅回调函数中从网络或者缓存中获取结果并更新，可以这样做的原因是当我们发射时间的时候从列表中给了回调函数一个随机的仓库。</p>
<p>现在来考虑一些不太一样的东西，在一个应用中，可能会有许多状态需要登录之后才可以触发，并且可能会有多个订阅器来处理用户试图退出的操作。因为已经发射了一个带<code>false</code>值的事件，每一个订阅器都可以使用这个值，并且需要判断是否需要重定向页面，移除cookie或者禁用表单。</p>
<pre><code>const events = new EventEmitter();

events.emit(&quot;authentication&quot;, false);

events.subscribe(&quot;authentication&quot;, isLoggedIn =&gt; {
    buttonEl.setAttribute(&quot;disabled&quot;, !isLogged);
});

events.subscribe(&quot;authentication&quot;, isLoggedIn =&gt; {
    window.location.replace(!isLoggedIn ? &quot;/login&quot; : &quot;&quot;);
});

events.subscribe(&quot;authentication&quot;, isLoggedIn =&gt; {
    !isLoggedIn &amp;&amp; cookies.remove(&quot;auth_token&quot;);
});</code></pre><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>要让<code>emitters</code>能工作，有几点需要考虑：</p>
<ul>
<li><p>需要在<code>emit()</code>函数中使用<code>forEach</code>或者<code>map</code>来确保我们能创建新的订阅器或者取消订阅。</p>
</li>
<li><p>当一个<code>EventEmitter</code>类被实例化之后，可以传递一个预定义的事件到事件接口。</p>
</li>
<li><p>可以不需要使用<code>class</code>，来实现，个人喜好，但是使用<code>class</code>使事件存储在哪里会更加清晰。<br>可以在一个函数中实现，如下：</p>
<pre><code>function emitter(e?: Events) {
    let events: Events = e || {};

    return {
        events,
        subscribe: (name: string, cb: Function) =&gt; {
        (events[name] || (events[name] = [])).push(cb);

        return {
            unsubscribe: () =&gt; {
            events[name] &amp;&amp; events[name].splice(events[name].indexOf(cb) &gt;&gt;&gt; 0, 1);
            }
        };
        },
        emit: (name: string, ...args: any[]) =&gt; {
            (events[name] || []).forEach(fn =&gt; fn(...args));
        }
    };
}</code></pre></li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://css-tricks.com/understanding-event-emitters/" target="_blank" rel="noopener">https://css-tricks.com/understanding-event-emitters/</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Event Emitters</tag>
      </tags>
  </entry>
  <entry>
    <title>ES2019 新特性</title>
    <url>/2019/08/19/ES2019%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-69db7d2ed973e3ae.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ES2019"></p>
<h1 id="Object-fromEntries"><a href="#Object-fromEntries" class="headerlink" title="Object.fromEntries"></a>Object.fromEntries</h1><p>在ES2017中，引入了<code>Object.entries</code>来把<code>Object</code>转成数组，如下：</p>
<pre><code>let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

Object.entries(students) 
// [
//  [ &apos;amelia&apos;, 20 ],
//  [ &apos;beatrice&apos;, 22 ],
//  [ &apos;cece&apos;, 20 ],
//  [ &apos;deirdre&apos;, 19 ],
//  [ &apos;eloise&apos;, 21 ]
// ]</code></pre><a id="more"></a>

<p>引入<code>Object.entries</code>这个方法的目的是为了使<code>Object</code>也可以使用数组的<code>map</code>，<code>filter</code>， <code>reduce</code>等原生方法，但是使用完之后必须要自己手动还原回去，例如：</p>
<pre><code>let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

// convert to array in order to make use of .filter() function
let overTwentyOne = Object.entries(students).filter(([name, age]) =&gt; {
  return age &gt;= 21
}) // [ [ &apos;beatrice&apos;, 22 ], [ &apos;eloise&apos;, 21 ] ]

// turn multidimensional array back into an object
let DrinkingAgeStudents = {}
for (let [name, age] of overTwentyOne) {
    DrinkingAgeStudents[name] = age;
}
// { beatrice: 22, eloise: 21 }</code></pre><p>上述代码使用了<code>Object.entries</code>及数组的<code>filter</code>方法过滤了年龄大于等于21的成员，然后又使用了<code>for...of</code>把数字转变回了<code>Object</code>，<br><code>Object.fromEntries</code>就是用来替代上面代码中的<code>for...of</code>循环的，使得<code>Object</code>调用数组的原生方法更简洁方便，代码如下：</p>
<pre><code>let students = {
  amelia: 20,
  beatrice: 22,
  cece: 20,
  deirdre: 19,
  eloise: 21
}

// convert to array in order to make use of .filter() function
let overTwentyOne = Object.entries(students).filter(([name, age]) =&gt; {
  return age &gt;= 21
}) // [ [ &apos;beatrice&apos;, 22 ], [ &apos;eloise&apos;, 21 ] ]

// turn multidimensional array back into an object
let DrinkingAgeStudents = Object.fromEntries(overTwentyOne); 
// { beatrice: 22, eloise: 21 }</code></pre><p>需要注意的一点是，使用<code>Object.fromEntries</code>会把<code>Object</code>中的重复<code>key</code>覆盖掉，只保存最后一个，如下：</p>
<pre><code>let students = [
  [ &apos;amelia&apos;, 22 ], 
  [ &apos;beatrice&apos;, 22 ], 
  [ &apos;eloise&apos;, 21], 
  [ &apos;beatrice&apos;, 20 ]
]

let studentObj = Object.fromEntries(students); 
// { amelia: 22, beatrice: 20, eloise: 21 }
// dropped first beatrice!</code></pre><h1 id="Array-prototype-flat"><a href="#Array-prototype-flat" class="headerlink" title="Array.prototype.flat"></a>Array.prototype.flat</h1><p>通常，数组会出现二维或者以上的情况，这个时候如果我们需要降维的话，常用的一种方法时使用<code>concat</code>方法，如下：</p>
<pre><code>let courses = [
  {
    subject: &quot;math&quot;,
    numberOfStudents: 3,
    waitlistStudents: 2,
    students: [&apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [&apos;Phil&apos;, &apos;Candace&apos;]]
  },
  {
    subject: &quot;english&quot;,
    numberOfStudents: 2,
    students: [&apos;Wilson&apos;, &apos;Taylor&apos;]
  },
  {
    subject: &quot;history&quot;,
    numberOfStudents: 4,
    students: [&apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos;]
  }
]

let courseStudents = courses.map(course =&gt; course.students)
// [
//   [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
//   [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
//   [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
// ]

[].concat.apply([], courseStudents) // we&apos;re stuck doing something like this</code></pre><p>但是在ES2019中引入了<code>Array.prototype.flat</code>，其接受一个可选参数表示需要展开的深度，默认值为1，可以帮助我们快速实现数组降维，如下：</p>
<pre><code>let courseStudents = [
  [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
  [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
  [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
]

let flattenOneLevel = courseStudents.flat(1)
console.log(flattenOneLevel)
// [
//   &apos;Janet&apos;,
//   &apos;Martha&apos;,
//   &apos;Bob&apos;,
//   [ &apos;Phil&apos;, &apos;Candace&apos; ],
//   &apos;Wilson&apos;,
//   &apos;Taylor&apos;,
//   &apos;Edith&apos;,
//   &apos;Jacob&apos;,
//   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]

let flattenTwoLevels = courseStudents.flat(2)
console.log(flattenTwoLevels)
// [
//   &apos;Janet&apos;,   &apos;Martha&apos;,
//   &apos;Bob&apos;,     &apos;Phil&apos;,
//   &apos;Candace&apos;, &apos;Wilson&apos;,
//   &apos;Taylor&apos;,  &apos;Edith&apos;,
//   &apos;Jacob&apos;,   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]</code></pre><p>不指定参数与参数值等于1的时候一样：</p>
<pre><code>let courseStudents = [
  [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
  [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
  [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
]

let defaultFlattened = courseStudents.flat()
console.log(defaultFlattened)
// [
//   &apos;Janet&apos;,
//   &apos;Martha&apos;,
//   &apos;Bob&apos;,
//   [ &apos;Phil&apos;, &apos;Candace&apos; ],
//   &apos;Wilson&apos;,
//   &apos;Taylor&apos;,
//   &apos;Edith&apos;,
//   &apos;Jacob&apos;,
//   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]</code></pre><ul>
<li><p>贪心操作<code>Infinity</code><br>对于未知深度的数组，可以使用<code>Infinity</code>参数来实现完全降维：</p>
<pre><code>let courseStudents = [
  [ &apos;Janet&apos;, &apos;Martha&apos;, &apos;Bob&apos;, [ &apos;Phil&apos;, &apos;Candace&apos; ] ],
  [ &apos;Wilson&apos;, &apos;Taylor&apos; ],
  [ &apos;Edith&apos;, &apos;Jacob&apos;, &apos;Peter&apos;, &apos;Betty&apos; ]
]

let alwaysFlattened = courseStudents.flat(Infinity)
console.log(alwaysFlattened)
// [
//   &apos;Janet&apos;,   &apos;Martha&apos;,
//   &apos;Bob&apos;,     &apos;Phil&apos;,
//   &apos;Candace&apos;, &apos;Wilson&apos;,
//   &apos;Taylor&apos;,  &apos;Edith&apos;,
//   &apos;Jacob&apos;,   &apos;Peter&apos;,
//   &apos;Betty&apos;
// ]</code></pre></li>
</ul>
<p>事实上，<code>Infinity</code>参数在实际情况中应该谨慎使用，而且在真正未知数组维数时并不推荐使用<code>Infinity</code>参数。</p>
<h1 id="Array-prototype-flatMap"><a href="#Array-prototype-flatMap" class="headerlink" title="Array.prototype.flatMap"></a>Array.prototype.flatMap</h1><p><code>flatMap</code> 等价于<code>map</code> 和 <code>flat</code>不加参数的结合体，所以<code>flatMap</code> 只展开一层数组。</p>
<ul>
<li><p>普通半版数组中插入值：</p>
<pre><code>let grades = [78, 62, 80, 64]

let curved = grades.map(grade =&gt; [grade, grade + 7])
// [ [ 78, 85 ], [ 62, 69 ], [ 80, 87 ], [ 64, 71 ] ]

let flatMapped = [].concat.apply([], curved) // now flatten, could use flat but that didn&apos;t exist before either
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]</code></pre></li>
</ul>
<ul>
<li><p><code>Array.prototype.flat</code>版</p>
<pre><code>let grades = [78, 62, 80, 64]

let flatMapped = grades.map(grade =&gt; [grade, grade + 7]).flat()
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]</code></pre></li>
</ul>
<ul>
<li><p><code>flatMap</code>进阶版</p>
<pre><code>let grades = [78, 62, 80, 64]

let flatMapped = grades.flatMap(grade =&gt; [grade, grade + 7]);
// [
//  78, 85, 62, 69,
//  80, 87, 64, 71
// ]</code></pre></li>
</ul>
<p>由于是<code>map</code> 和 <code>flat</code>不加参数的结合体，<code>flatMap</code> 只展开一层数组：</p>
<pre><code>let grades = [78, 62, 80, 64]

let flatMapped = grades.flatMap(grade =&gt; [grade, [grade + 7]]);
// [
//   78, [ 85 ],
//   62, [ 69 ],
//   80, [ 87 ],
//   64, [ 71 ]
// ]</code></pre><h1 id="String-trimStart-和-String-trimEnd"><a href="#String-trimStart-和-String-trimEnd" class="headerlink" title="String.trimStart 和 String.trimEnd"></a>String.trimStart 和 String.trimEnd</h1><p>等价于之前的<code>String.trimRight</code> 和 <code>String.trimLeft</code> </p>
<pre><code>let message = &quot;   Welcome to CS 101    &quot;
message.trimRight()
// &apos;   Welcome to CS 101&apos;
message.trimLeft()
// &apos;Welcome to CS 101   &apos;
message.trimRight().trimLeft()
// &apos;Welcome to CS 101&apos;</code></pre><p>等价于</p>
<pre><code>let message = &quot;   Welcome to CS 101    &quot;
message.trimEnd()
// &apos;   Welcome to CS 101&apos;
message.trimStart()
// &apos;Welcome to CS 101   &apos;
message.trimEnd().trimStart()
// &apos;Welcome to CS 101&apos;</code></pre><h1 id="可选的catch绑定"><a href="#可选的catch绑定" class="headerlink" title="可选的catch绑定"></a>可选的catch绑定</h1><p>在之前的版本中，<code>try...catch</code>中的<code>catch</code>后面必须要跟一个参数，即使<code>catch</code>块里面什么内容都没有，所以在ES2019中，<code>catch</code>块后面的参数是可选的，如下：</p>
<pre><code>try {
  let parsed = JSON.parse(obj)
} catch(e) {
  // ignore e, or use
  console.log(obj)
}</code></pre><p><code>e</code>可以不写：</p>
<pre><code>try {
  let parsed = JSON.parse(obj)
} catch {
  console.log(obj)
}</code></pre><h1 id="Function-toString-更新"><a href="#Function-toString-更新" class="headerlink" title="Function.toString() 更新"></a>Function.toString() 更新</h1><p>之前的版本中，<code>Function.toString()</code>直接把空格去掉了：</p>
<pre><code>function greeting() {
  const name = &apos;CSS Tricks&apos;
  console.log(`hello from ${name}`)
}

greeting.toString()
//&apos;function greeting() {\nconst name = \&apos;CSS Tricks\&apos;\nconsole.log(`hello from ${name} //`)\n}&apos;</code></pre><p>但是，在ES2019中，会完全保留源码格式打印：</p>
<pre><code>function greeting() {
  const name = &apos;CSS Tricks&apos;
  console.log(`hello from ${name}`)
}

greeting.toString()
// &apos;function greeting() {\n&apos; +
//  &quot;  const name = &apos;CSS Tricks&apos;\n&quot; +
//  &apos;  console.log(`hello from ${name}`)\n&apos; +
//  &apos;}&apos;</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://css-tricks.com/all-the-new-es2019-tips-and-tricks/" target="_blank" rel="noopener">https://css-tricks.com/all-the-new-es2019-tips-and-tricks/</a></p>
]]></content>
      <categories>
        <category>JavaScript ES2019</category>
      </categories>
      <tags>
        <tag>ES2019 JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6之Set和Map及WeakSet和WeakMap总结</title>
    <url>/2019/08/19/ES6%E4%B9%8BSet%E5%92%8CMap%E5%8F%8AWeakSet%E5%92%8CWeakMap%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-96533cae7400a3a1.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Set &amp; Map"></p>
<h1 id="一、Set"><a href="#一、Set" class="headerlink" title="一、Set"></a>一、Set</h1><ul>
<li><p>概念<br><code>Set</code>类似于数组，本身是一个构造函数，用来生成 <code>Set</code> 数据结构，成员值都是唯一的，常用于数组去重。</p>
</li>
<li><p>属性<br><code>Set.prototype.size</code>：返回Set实例的成员总数</p>
</li>
<li><p>方法<br><code>add()</code> 添加值，返回 Set 结构本身。<br><code>delete()</code> 删除值，返回一个布尔值，表示删除是否成功。<br><code>has()</code> 返回一个布尔值，表示该值是否为<code>Set</code>的成员。<br><code>clear()</code> 清除所有成员，没有返回值。</p>
</li>
<li><p>遍历<br><code>Set.prototype.keys()</code>：返回键名的遍历器<br><code>Set.prototype.values()</code>：返回键值的遍历器<br><code>Set.prototype.entries()</code>：返回键值对的遍历器<br><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</p>
</li>
</ul>
<a id="more"></a>

<h1 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h1><ul>
<li><p>概念<br>由于<code>Object</code>只能使用字符串作为<code>key</code>，在使用上面会有很大的限制，比如使用<code>DOM</code>节点作为<code>key</code>时，就会被自动转为字符串<code>[object HTMLDivElement]</code>。<br>为了解决上述问题，ES6 引入了 <code>Map</code> ，它类似于对象，也是键值对的集合，但是其key的范围不限于字符串，各种类型的值（包括对象）都可以当作键。<br><code>Object</code> 结构提供了“字符串—值”的对应，<code>Map</code> 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</p>
</li>
<li><p>与Object的区别<br><code>Object</code>：<br><code>k-v</code>(键-值对)，<code>key</code>只能是字符串，<code>value</code>可以为任意类型，无序，不可遍历，有默认属性<br><code>Map</code>:<br><code>k-v</code>(键-值对)，<code>key</code>与<code>value</code>可以为任意类型，可使用<code>for...of</code>遍历，按插入顺序遍历，可存储大量数据，但是由于<code>.get</code> 函数，可能比<code>Object</code>慢</p>
</li>
</ul>
<p>常用方法比较：</p>
<pre><code>Object:
   var o = {};
   var o = Object.create(null);
   o.key = 1;
   o.key += 10;
   for(let k in o) o[k]++;
   var sum = 0;
   for(let v of Object.values(m)) sum += v;
   if(&apos;key&apos; in o);
   if(o.hasOwnProperty(&apos;key&apos;));
   delete(o.key);
   Object.keys(o).length
Map:
   var m = new Map();
   m.set(&apos;key&apos;, 1);
   m.set(&apos;key&apos;, m.get(&apos;key&apos;) + 10);
   m.foreach((k, v) =&gt; m.set(k, m.get(k) + 1));
   for(let k of m.keys()) m.set(k, m.get(k) + 1);
   var sum = 0;
   for(let v of m.values()) sum += v;
   if(m.has(&apos;key&apos;));
   m.delete(&apos;key&apos;);
   m.size();</code></pre><ul>
<li><p>属性与方法<br><code>size</code><br><code>set(k,v)</code><br><code>get(K)</code><br><code>has(k)</code><br><code>delete(k)</code><br><code>clear()</code></p>
</li>
<li><p>遍历<br><code>Map.prototype.keys()</code>：返回键名的遍历器。<br><code>Map.prototype.values()</code>：返回键值的遍历器。<br><code>Map.prototype.entries()</code>：返回所有成员的遍历器。<br><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</p>
</li>
<li><p>遍历顺序就是插入顺序</p>
</li>
<li><p><code>Map</code> 转为数组最方便的方法，就是使用扩展运算符<code>（...）</code></p>
</li>
</ul>
<h1 id="三、WeakSet"><a href="#三、WeakSet" class="headerlink" title="三、WeakSet"></a>三、WeakSet</h1><ul>
<li><p><code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值</p>
</li>
<li><p>对象都是弱引用，即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用。如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中。</p>
</li>
<li><p><code>WeakSet</code> 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 <code>WeakSet</code> 里面的引用就会自动消失，所以<code>WeakSet</code> 的成员是不适合引用的。</p>
</li>
<li><p>由于 <code>WeakSet</code> 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 <code>WeakSet</code> 不可遍历。</p>
</li>
<li><p>方法<br><code>WeakSet.prototype.add(value)</code>：向 WeakSet 实例添加一个新成员。<br><code>WeakSet.prototype.delete(value)</code>：清除 WeakSet 实例的指定成员。<br><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在 <code>WeakSet</code> 实例之中。</p>
</li>
</ul>
<h1 id="四、WeakMap"><a href="#四、WeakMap" class="headerlink" title="四、WeakMap"></a>四、WeakMap</h1><ul>
<li><code>WeakMap</code>只接受对象作为键名（null除外）</li>
<li><code>WeakMap</code>的键名所指向的对象，不计入垃圾回收机制</li>
<li><code>WeakMap</code>的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内</li>
<li>没有遍历方法，即没有<code>keys()</code>、<code>values()</code>和<code>entries()</code>方法</li>
<li>没有<code>size</code>属性、<code>clear()</code>方法</li>
<li><code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code></li>
</ul>
<p>一个典型应用场景是，在网页的 <code>DOM</code> 元素上添加数据，就可以使用<code>WeakMap</code>结构。当该 <code>DOM</code> 元素被清除，其所对应的<code>WeakMap</code>记录就会自动被移除。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://es6.ruanyifeng.com/#docs/set-map" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/set-map</a><br><a href="https://stackoverflow.com/questions/18541940/map-vs-object-in-javascript" target="_blank" rel="noopener">https://stackoverflow.com/questions/18541940/map-vs-object-in-javascript</a></p>
]]></content>
      <categories>
        <category>JavaScript ES6</category>
      </categories>
      <tags>
        <tag>ES6 Set Map WeakSet WeakMap</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JavaScript中的Web Worker</title>
    <url>/2019/08/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JavaScript%E4%B8%AD%E7%9A%84WebWorker/</url>
    <content><![CDATA[<h1 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h1><p>由于JavaScript是单线程模型，即所有任务只能在同一个线程上面完成，前面的任务没有做完，后面的就只能等待，这对于日益增强的计算能力来说不是一件好事。所以在HTML5中引入了Web Worker的概念，来为JavaScript创建多线程环境，将其中一些任务分配给Web Worker运行，二者可以同时运行，互不干扰，如图：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-d566f191add913c3?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="With or without worker"></p>
<p>Web Worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，引入Web Worker的好处是一些计算密集型或高延迟的任务，被 Web Worker 线程所处理，主线程就会很流畅，不会被阻塞或拖慢，而此时 Web Worker 在后台运行。但是这也正是 Web Worker 比较耗费资源的原因，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<h1 id="二、浏览器支持"><a href="#二、浏览器支持" class="headerlink" title="二、浏览器支持"></a>二、浏览器支持</h1><p>所有主流浏览器均支持 Worker，除了 Internet Explorer。<br>可以使用如下代码检测 Worker 支持<br>在创建 Worker 之前，请检测用户的浏览器是否支持它：</p>
<pre><code>if(typeof(Worker)!==&quot;undefined&quot;)
  {
  // Yes! Web worker support!
  // Some code.....
  }
else
  {
  // Sorry! No Web Worker support..
  }</code></pre><a id="more"></a>

<h1 id="三、使用"><a href="#三、使用" class="headerlink" title="三、使用"></a>三、使用</h1><p>Web Worker 在独立线程中运行。因此，它们执行的代码需要保存在一个单独的文件中。但在保存代码前，我们要先在主线程上创建新的 Worker 对象。构造函数采用 Worker 脚本的名称：</p>
<pre><code>var worker = new Worker(&apos;worker.js&apos;);</code></pre><p>如果指定的异步下载文件存在，浏览器就会生成新的 Worker 线程。在完全下载并执行文件之前，系统不会生成 Worker。如果指向您 Worker 的路径返回 404，Worker 就会在不显示任何提示的情况下失败。</p>
<p>创建 Worker 之后，通过调用 postMessage() 方法启动：</p>
<pre><code>worker.postMessage(); // Start the worker.</code></pre><ul>
<li>传递变量，也可以给Worker传递一个变量</li>
</ul>
<pre><code>// Create a new worker object
var worker = new Worker(&apos;worker.js&apos;);

// Send a message to start the worker and pass a variable to it
var info = &apos;Web Workers&apos;;
worker.postMessage(info);</code></pre><p>在Worker中，例如，在<code>worker.js</code>内部，可以使用<code>onmessage</code>事件来接收来自主线程的消息并且实现一些操作，可以通过<code>event.data</code>来获取到传递的变量：</p>
<pre><code>// Receive the message from the main thread
onmessage = function(event) {
  // Do something
  var info = event.data;
};</code></pre><p>从Worker 发送消息到主线程也是同样的方法(<code>worker.js</code>)：</p>
<pre><code>// Receive the message from the main thread
onmessage = function(event) {
  // Do something
  var info = event.data;
  var result = info + &apos; rise up!&apos;;
  postMessage(result);
};</code></pre><p>主线程：</p>
<pre><code>// Create a new worker object
var worker = new Worker(&apos;worker.js&apos;);

// Send a message to start the worker and pass a variable to it
var info = &apos;Web Workers&apos;;
worker.postMessage(info);

// Receive a message from the worker
worker.onmessage = function (event) {
  // Do something
  alert(event.data);
};</code></pre><p>也可以使用<code>addEventListener</code>来替换<code>onmessage</code>（JavaScript 高手们总是会推荐 <code>addEventListener</code>），例如：<br>主线程：</p>
<pre><code>var worker = new Worker(&apos;doWork.js&apos;);

worker.addEventListener(&apos;message&apos;, function(e) {
  console.log(&apos;Worker said: &apos;, e.data);
}, false);

worker.postMessage(&apos;Hello World&apos;); // Send data to our worker.</code></pre><p><code>doWork.js</code> (Worker)：</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e) {
  self.postMessage(e.data);
}, false);</code></pre><p>在主线程和 Worker 之间传递的消息是复制而不是共享的。例如，下一示例中 JSON 消息的“msg”属性在两个位置中均可访问。即使对象运行在单独的专用空间中，系统似乎也会将其直接传递给 Worker。实际发生的情况是，系统将对象传递给 Worker 后，会将其序列化，随后在另一端解取消序列化。由于网页和 Worker 并不共享同一实例，因此每次传递时都要进行复制。大部分浏览器通过在任一端上对值进行自动 JSON 编码/解码来实施此功能。</p>
<p>主线程：</p>
<pre><code>&lt;button onclick=&quot;sayHI()&quot;&gt;Say HI&lt;/button&gt;
&lt;button onclick=&quot;unknownCmd()&quot;&gt;Send unknown command&lt;/button&gt;
&lt;button onclick=&quot;stop()&quot;&gt;Stop worker&lt;/button&gt;
&lt;output id=&quot;result&quot;&gt;&lt;/output&gt;

&lt;script&gt;
  function sayHI() {
    worker.postMessage({&apos;cmd&apos;: &apos;start&apos;, &apos;msg&apos;: &apos;Hi&apos;});
  }

  function stop() {
    // Calling worker.terminate() from this script would also stop the worker.
    worker.postMessage({&apos;cmd&apos;: &apos;stop&apos;, &apos;msg&apos;: &apos;Bye&apos;});
  }

  function unknownCmd() {
    worker.postMessage({&apos;cmd&apos;: &apos;foobard&apos;, &apos;msg&apos;: &apos;???&apos;});
  }

  var worker = new Worker(&apos;doWork2.js&apos;);

  worker.addEventListener(&apos;message&apos;, function(e) {
    document.getElementById(&apos;result&apos;).textContent = e.data;
  }, false);
&lt;/script&gt;</code></pre><p><code>doWork2.js</code>：</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e) {
  var data = e.data;
  switch (data.cmd) {
    case &apos;start&apos;:
      self.postMessage(&apos;WORKER STARTED: &apos; + data.msg);
      break;
    case &apos;stop&apos;:
      self.postMessage(&apos;WORKER STOPPED: &apos; + data.msg + &apos;. (buttons will no longer work)&apos;);
      self.close(); // Terminates the worker.
      break;
    default:
      self.postMessage(&apos;Unknown command: &apos; + data.msg);
  };
}, false);</code></pre><ul>
<li>停止 Worker<br>停止 Worker 的方法有两种：在主线程中调用 <code>worker.terminate()</code>，或在 Worker 本身内部调用 <code>self.close()</code>。</li>
<li>Worker 作用域</li>
</ul>
<p>就 Worker 来说，self 和 this 指的都是 Worker 的全局作用域。因此，上一示例也可以写成：</p>
<pre><code>addEventListener(&apos;message&apos;, function(e) {
  var data = e.data;
  switch (data.cmd) {
    case &apos;start&apos;:
      postMessage(&apos;WORKER STARTED: &apos; + data.msg);
      break;
    case &apos;stop&apos;:
  ...
}, false);</code></pre><h1 id="四、加载外部脚本"><a href="#四、加载外部脚本" class="headerlink" title="四、加载外部脚本"></a>四、加载外部脚本</h1><p>可以通过 <code>importScripts()</code> 函数将外部脚本文件或库加载到 Worker 中。该方法采用零个或多个字符串表示要导入的资源的文件名。</p>
<p>此示例将 script1.js 和 script2.js 加载到了 Worker 中：</p>
<pre><code>importScripts(&apos;script1.js&apos;);
importScripts(&apos;script2.js&apos;);</code></pre><p>也可以写成单个导入语句：</p>
<pre><code>importScripts(&apos;script1.js&apos;, &apos;script2.js&apos;);</code></pre><h1 id="五、子-Worker"><a href="#五、子-Worker" class="headerlink" title="五、子 Worker"></a>五、子 Worker</h1><p>Worker 可以生成子 Worker。这对于在运行时进一步拆分大任务来说非常重要。但是，子 Worker 还有几点注意事项：</p>
<ul>
<li>子 Worker 必须托管在与父线程相同的origin中。</li>
<li>子 Worker 中的 URI 应相对于父 Worker 的位置进行解析（与主线程不同）。</li>
</ul>
<p>注意，大部分浏览器会为每个 Worker 生成单独的进程。在开始生成 Worker 场之前，请注意不要占用太多的用户系统资源。这样做的一个原因是，在主线程和 Worker 之间传递的消息是复制而不是共享的。</p>
<h1 id="六、处理错误"><a href="#六、处理错误" class="headerlink" title="六、处理错误"></a>六、处理错误</h1><p>与任何 JavaScript 逻辑一样，您需要处理 Web Worker 中出现的任何错误。如果在执行 Worker 时出现错误，就会触发 ErrorEvent。相关界面中包含用于找出错误内容的三个实用属性：filename - 导致错误的 Worker 脚本的名称；lineno - 出现错误的行号；以及 message - 有关错误的实用说明。以下示例设置了 onerror 事件处理程序以便打印错误内容：</p>
<pre><code>&lt;output id=&quot;error&quot; style=&quot;color: red;&quot;&gt;&lt;/output&gt;
&lt;output id=&quot;result&quot;&gt;&lt;/output&gt;

&lt;script&gt;
  function onError(e) {
    document.getElementById(&apos;error&apos;).textContent = [
      &apos;ERROR: Line &apos;, e.lineno, &apos; in &apos;, e.filename, &apos;: &apos;, e.message].join(&apos;&apos;);
  }

  function onMsg(e) {
    document.getElementById(&apos;result&apos;).textContent = e.data;
  }

  var worker = new Worker(&apos;workerWithError.js&apos;);
  worker.addEventListener(&apos;message&apos;, onMsg, false);
  worker.addEventListener(&apos;error&apos;, onError, false);
  worker.postMessage(); // Start worker without a message.
&lt;/script&gt;</code></pre><p><code>workerWithError.js</code>：</p>
<pre><code>self.addEventListener(&apos;message&apos;, function(e) {
  postMessage(1/x); // Intentional error.
};</code></pre><h1 id="七、适用和不适用-Worker-的功能"><a href="#七、适用和不适用-Worker-的功能" class="headerlink" title="七、适用和不适用 Worker 的功能"></a>七、适用和不适用 Worker 的功能</h1><p>由于 Web Worker 的多线程行为，所以它们只能使用 JavaScript 功能的子集：</p>
<ul>
<li><code>navigator</code> 对象</li>
<li><code>location</code> 对象（只读）</li>
<li><code>XMLHttpRequest</code></li>
<li><code>setTimeout()/clearTimeout()</code> 和 <code>setInterval()/clearInterval()</code></li>
<li>应用缓存</li>
<li>使用 <code>importScripts()</code> 方法导入外部脚本</li>
<li>生成其他 Web Worker</li>
</ul>
<p>Worker 无法使用：</p>
<ul>
<li>DOM（非线程安全）</li>
<li><code>window</code> 对象</li>
<li><code>document</code> 对象</li>
<li><code>parent</code> 对象</li>
<li><code>alert()</code></li>
<li><code>confirm()</code></li>
<li><code>document.getElementById()</code></li>
</ul>
<h1 id="八、更多使用方向"><a href="#八、更多使用方向" class="headerlink" title="八、更多使用方向"></a>八、更多使用方向</h1><ul>
<li>预先抓取或缓存数据以便稍后使用</li>
<li>突出显示代码语法或其他实时文本格式</li>
<li>拼写检查</li>
<li>分析视频或音频数据</li>
<li>背景 I/O 或网络服务轮询</li>
<li>处理较大数组或超大 JSON 响应</li>
<li><code>&lt;canvas&gt;</code> 中的图片过滤</li>
<li>更新本地网络数据库中的多行内容</li>
</ul>
<h1 id="九、一些示例"><a href="#九、一些示例" class="headerlink" title="九、一些示例"></a>九、一些示例</h1><ul>
<li><a href="http://slides.html5rocks.com/#web-workers" target="_blank" rel="noopener">Example from HTML5Rocks slides</a></li>
<li><a href="http://htmlfive.appspot.com/static/tracker1.html" target="_blank" rel="noopener">Motion tracker</a></li>
<li><a href="http://people.mozilla.com/~prouget/demos/worker_and_simulatedannealing/index.xhtml" target="_blank" rel="noopener">Simulated Annealing</a></li>
<li><a href="http://html5demos.com/worker" target="_blank" rel="noopener">HTML5demos sample</a></li>
</ul>
<h1 id="十、参考"><a href="#十、参考" class="headerlink" title="十、参考"></a>十、参考</h1><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/web-worker.html</a><br><a href="https://dev.opera.com/articles/web-workers-rise-up/" target="_blank" rel="noopener">https://dev.opera.com/articles/web-workers-rise-up/</a><br><a href="https://www.html5rocks.com/en/tutorials/workers/basics/" target="_blank" rel="noopener">https://www.html5rocks.com/en/tutorials/workers/basics/</a></p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Web Worker</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Javascript中的Prototype原型</title>
    <url>/2019/07/17/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Javascript%E4%B8%AD%E7%9A%84Prototype%E5%8E%9F%E5%9E%8B/</url>
    <content><![CDATA[<ul>
<li>刚开始学Javascript的时候觉得很简单，其中的东西也就是那是基本的，但是还是太年轻，最近因为面试中常被问到关于原型和原型链的问题，然后自己也是模棱两可的，含含糊糊说不清楚，所以痛下思定，决定好好下一番功夫来搞懂吃透原型与原型链究竟是什么。</li>
</ul>
<h1 id="关于new"><a href="#关于new" class="headerlink" title="关于new"></a>关于<code>new</code></h1><p><code>new</code>的过程</p>
<blockquote>
<ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象</li>
</ul>
</blockquote>
<p>知道了<code>new</code>的原理后，也可以自己实现一个<code>new</code>函数：</p>
<pre><code>function myNew() {
    // 创建一个空的对象
    let obj = new Object()
    // 获得构造函数
    let Con = [].shift.call(arguments)
    // 链接到原型
    obj.__proto__ = Con.prototype
    // 绑定 this，执行构造函数
    let result = Con.apply(obj, arguments)
    // 确保 new 出来的是个对象
    return typeof result === &apos;object&apos; ? result : obj
}</code></pre><a id="more"></a>

<p>先来看几个例子：</p>
<ul>
<li>普通函数</li>
</ul>
<pre><code>function test(name){
    console.log(name);  
}
typeof(test) // function</code></pre><ul>
<li>使用<em>new</em>新建对象</li>
</ul>
<pre><code>function test(name){
    console.log(name);  
}

var te = new test(&quot;Hal&quot;);
typeof(te) // object
console.log(JSON.stringify(test.prototype)) //{}，是个空对象
console.log(JSON.stringify(te.prototype)) //undefined</code></pre><ul>
<li>直接声明的函数拥有<code>prototype</code>这个属性，而<code>new</code>构造出来的函数不存在<code>prototype</code>。</li>
</ul>
<h1 id="关于prototype"><a href="#关于prototype" class="headerlink" title="关于prototype"></a>关于<code>prototype</code></h1><p>每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象  <code>prototype</code>，这个对象就是我们所说的<code>prototype</code>，每一个对象都会从<code>prototype</code>“继承”属性。除了<code>new</code>出来的函数，每个函数都有一个<code>prototype</code>属性，如下，在<code>prototype</code>上可以设置属性，然后打印出一些东西：</p>
<pre><code>function Employee() {}

// prototype是函数才会有的属性
Employee.prototype.name = &apos;Hal&apos;;
var employee1 = new Employee();
var employee2 = new Employee();
console.log(employee1.name) // Hal
console.log(employee2.name) // Hal
console.log(employee1.constructor) // Employee() {}
console.log(employee1.constructor.name) // Employee
console.log(employee1.prototype) // undefined
console.log(employee1.__proto__) // {name: &quot;Hal&quot;, constructor: ƒ}
console.log(Employee.prototype) // {name: &quot;Hal&quot;, constructor: ƒ}
console.log(Employee.prototype === employee1.__proto__) // true
console.log(Employee.prototype.constructor === Employee) // true</code></pre><h1 id="关于-proto"><a href="#关于-proto" class="headerlink" title="关于__proto__"></a>关于<code>__proto__</code></h1><p>从刚才的例子中已经可以很清楚地看出了，employee1的<code>__proto__</code>和Employee.prototype是相等的，也就是指向同一个对象，也就是说，实例中有一个<code>__proto__</code>指针指向构造函数的<code>prototype</code>。使用<code>Object.getPrototypeOf</code>与<code>__proto__</code>是同样的效果。</p>
<pre><code>Object.getPrototypeOf(employee1) === Employee.prototype //true</code></pre><h1 id="关于constructor"><a href="#关于constructor" class="headerlink" title="关于constructor"></a>关于<code>constructor</code></h1><p>从上面可以看到，原型<code>prototype</code>里面还有一个<code>constructor</code>的属性，然后这个<code>constructor</code>又指向了函数本身。<br>好像有一点绕，但是看一下下面的图就一目了然了：<br><img src="https://upload-images.jianshu.io/upload_images/1741029-f6343d487e11fe0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="原型链"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li><code>Object</code> 是所有对象的祖先，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的祖先，所有函数都可以通过 <code>__proto__</code>找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，由引擎创建，而且<code>Function.__proto__.__proto__</code>是指向<code>Object.prototype</code>的<br>即：<br><code>Function.__proto__.__proto__ === Object.prototype // true</code></li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 new 出来的<br>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="http://blog.ifyouseewendy.com/blog/2017/07/03/review-you-dont-know-js-this-and-object-prototypes/#what-is-the-prototype-" target="_blank" rel="noopener">http://blog.ifyouseewendy.com/blog/2017/07/03/review-you-dont-know-js-this-and-object-prototypes/#what-is-the-prototype-</a></li>
<li><a href="https://github.com/KieSun/Dream/issues/2" target="_blank" rel="noopener">https://github.com/KieSun/Dream/issues/2</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/2</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript Prototype</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现JQuery中的链式操作具体实现</title>
    <url>/2019/07/15/JS%E5%AE%9E%E7%8E%B0JQuery%E4%B8%AD%E7%9A%84%E9%93%BE%E5%BC%8F%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<ul>
<li><p>前不久面试某大厂被问到关于JQuery中的链式操作的问题，才疏学浅的我一脸懵逼，这东西只是用过，怎么还要求自己动手实现呢，究其原因还是自己修为不够，达不到大厂的水平，平时“拿来主义”习惯了，也不会去深究其底层原理，可见学习思维与方式还需改进，今天就来好好学习一番。</p>
</li>
<li><p>网上查了一下，其原理其实很简单，就是在每次方法执行完后返回this对象，然后后面的方法就可以继续在this环境下执行。</p>
</li>
<li><p>然后自己动手实现一下：</p>
<pre><code>function Employee(){};
// 在原型上定义对应的方法
Employee.prototype ={
  setName:function(name){
    this.name = name;
    return this;
  },
  setAge:function(age){
    this.age = age;
    return this;
  },
  setSex:function(sex){
    this.sex = sex;
    return this;
  }
}

var employee= new Employee();
employee.setName(&quot;Hal&quot;).setAge(24).setSex(&quot;male&quot;);
// Employee {name: &quot;Hal&quot;, age: 24, sex: &quot;male&quot;}</code></pre></li>
<li><p>因为每次返回的结果都是<em>this</em>，所以 ‘.’ 后面的方法就相当于每次都在调用<em>this</em>，如下：</p>
<pre><code>employee.setName(&quot;Hal&quot;) === employee.setName(&quot;Hal&quot;).setAge(24) // true
employee.setName(&quot;Hal&quot;) === employee.setName(&quot;Hal&quot;).setAge(24).setSex(&quot;male&quot;) // true</code></pre></li>
</ul>
<ul>
<li><p>优点<br>链式操作使得异步编程的流程更加清晰，不会像回调函数一样相互耦合，难以分辨函数的执行顺序且维护困难，实现了水平扩展。在ES6中，Promise也正是沿用了这一思想，每一个异步任务返回一个Promise对象，通过then方法指定回调函数。</p>
</li>
<li><p>缺点<br>只能应用在不需要返回值的情况下，或者说只能最后一步才能设置返回值，因为要支持链式调用返回的只能是<em>this</em>，但jQuery主要是对DOM元素进行操作，只需要改变DOM元素的表现而不需要返回值，所以适合链式操作。</p>
</li>
<li><p>参考<br><a href="https://www.cnblogs.com/youhong/p/6899466.html" target="_blank" rel="noopener">https://www.cnblogs.com/youhong/p/6899466.html</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript JQuery</category>
      </categories>
      <tags>
        <tag>JavaScript JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6 Proxy用法详解</title>
    <url>/2019/07/11/ES6Proxy%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/1741029-96fbd7ec39c2fcb4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Proxy"></p>
<p><strong>前不久换工作的时候面试某大厂被问到关于Proxy的问题，脑子里有点印象但是又说不出具体使用方法，主要还是自己平时积累不够，所以赶紧来恶补一下。</strong></p>
<h1 id="Metaprogramming"><a href="#Metaprogramming" class="headerlink" title="Metaprogramming"></a>Metaprogramming</h1><p>正式开始之前，先一起来理解下什么是Metaprogramming（元编程），因为Proxy就是一种基于Metaprogramming概念的对象 ，维基百科上这样解释：</p>
<blockquote>
<p>Metaprogramming is a programming technique in which computer programs have the ability to treat other programs as their data.</p>
</blockquote>
<p>翻译过来就是</p>
<blockquote>
<p>元编程就是可以使用其他程序来作为输入数据的一种编程技术</p>
</blockquote>
<h1 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h1><blockquote>
<p>Proxy wraps objects and intercepts their behavior through traps</p>
</blockquote>
<blockquote>
<p>The Proxy object is used to define custom behavior for fundamental operations (e.g. property lookup, assignment, enumeration, function invocation, etc).</p>
</blockquote>
<a id="more"></a>

<p>简单说来就是Proxy可以用来改变对象的默认操作，比如自行定义set和get等，常用的有以下这些：</p>
<ul>
<li>apply</li>
<li>construct</li>
<li>defineProperty</li>
<li>deleteProperty</li>
<li>get</li>
<li>getOwnPropertyDescriptor</li>
<li>getPrototypeOf</li>
<li>has</li>
<li>isExtensible</li>
<li>ownKeys</li>
<li>preventExtensions</li>
<li>set</li>
<li>setPrototypeOf</li>
</ul>
<p>Proxy中需要理解的三个属性：</p>
<ul>
<li>target: an Object which the proxy virtualizes.（目标对象）</li>
<li>handler: a Placeholder Object which contains traps.（包含重写方法的对象）</li>
<li>trap: the Methods that provide property access of the target object.（重写的方法，比如get和set）</li>
</ul>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>新建一个Proxy对象</p>
<pre><code>let p = new Proxy(target, handler);</code></pre><p>新建一个employee对象然后输出其中的一些属性</p>
<pre><code>const employee = {
    firstName: &apos;Tapas&apos;,
    lastName: &apos;Adhikary&apos;
};

console.group(&apos;employee&apos;);
console.log(employee.firstName);
console.log(employee.lastName);
console.log(employee.org);
console.log(employee.fullName);
console.groupEnd()</code></pre><p>上面的输出如下所示：</p>
<pre><code>employee
Tapas
Adhikary
undefined
undefined</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-14ae06c68fdb9b67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"></p>
<p>接下来使用Proxy来更改一些默认行为：</p>
<ul>
<li><p>第一步 新建一个使用trap的handler<br>以下是一个覆盖get方法的handler，当target中取不到相应的fieldName时，你可以自定义输出:</p>
<pre><code>let handler = {
    get: function(target, fieldName) {        

        if(fieldName === &apos;fullName&apos; ) {
            return `${target.firstName} ${target.lastName}`;
        }

        return fieldName in target ?
            target[fieldName] :
                `No such property as, &apos;${fieldName}&apos;!`

    }
};</code></pre></li>
<li><p>第二步 新建一个Proxy对象，并把之前定义的employee作为target传入</p>
<pre><code>let p = new Proxy(employee, handler);</code></pre></li>
<li><p>第三步 输出p的属性</p>
<pre><code>console.group(&apos;proxy&apos;);
console.log(p.firstName);
console.log(p.lastName);
console.log(p.org);
console.log(p.fullName);
console.groupEnd()</code></pre></li>
</ul>
<p>然后就可以看到输出结果和之前不一样了，期望结果与实际结果如下所示：</p>
<pre><code>proxy
  Tapas
  Adhikary
  No such property as, &apos;org&apos;!
  Tapas Adhikary</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/1741029-62701d1cce29ae4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="输出结果"><br>现在，清楚Proxy的作用了吧，其实就是用来更改对象默认方法的。</p>
<p>下面是改变set方法来实现一个验证的例子：<br>新建一个handler，重新命名为validator：</p>
<pre><code>const validator = {
    set: function(obj, prop, value) {
        if (prop === &apos;age&apos;) {
            if(!Number.isInteger(value)) {
                throw new TypeError(&apos;Age is always an Integer, Please Correct it!&apos;);
            }
            if(value &lt; 0) {
                throw new TypeError(&apos;This is insane, a negative age?&apos;);
            }
        }
    }
};</code></pre><p>然后再新建一个Proxy：</p>
<pre><code>let pr = new Proxy(employee, validator);</code></pre><p>然后可以尝试设置一个不合法的属性，比如：</p>
<pre><code>pr.age = &quot;test&quot;；</code></pre><p>你将会得到如下报错：</p>
<pre><code>Uncaught TypeError: Age is always an Integer, Please Correct it!
    at Object.set (&lt;anonymous&gt;:5:23)
    at &lt;anonymous&gt;:1:7
set @ VM2381:5
(anonymous) @ VM2434:1</code></pre><p>或者：</p>
<pre><code>pr.age = -1；</code></pre><p>结果：</p>
<pre><code>Uncaught TypeError: This is insane, a negative age?
    at Object.set (&lt;anonymous&gt;:8:23)
    at &lt;anonymous&gt;:1:7
set @ VM2381:8
(anonymous) @ VM2531:1</code></pre><p>由上可见，Proxy的功能还是很强大也非常实用，常用应用场景有：</p>
<ul>
<li>保护ID字段不受删除（重写deleteProperty）</li>
<li>取值和写值（数据绑定）（重写get，set）</li>
<li>改变 in 操作的默认行为等</li>
</ul>
<h1 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h1><p>需要注意的是，proxy会改变target中的this指向，一旦proxy代理了target，target内部的this则指向了proxy，而不是target。</p>
<pre><code>const target = {
  get: function () {
    console.log(this === proxy);
  }
};
const handler = {};
const proxy = new Proxy(target, handler);

target.get() // false
proxy.get()  // true</code></pre><p>而有些原生对象的内部属性，只有通过正确的this才能拿到，所以proxy也无法代理这些原生对象的属性。</p>
<pre><code>const target = new Date();
const handler = {};
const proxy = new Proxy(target, handler);

proxy.getDate();
// TypeError: this is not a Date object.</code></pre><p>对于以上的代码，getDate方法只能在Date对象的实例上面拿到，如果this不是Date就会报错。可以通过this绑定原始对象来解决这个问题。</p>
<pre><code>const target = new Date(&apos;2019-07-11&apos;);
const handler = {
  get(target, prop) {
    if (prop === &apos;getDate&apos;) {
      return target.getDate.bind(target);
    }
    return Reflect.get(target, prop);
  }
};
const proxy = new Proxy(target, handler);

proxy.getDate() // 11</code></pre><p>这里又引入了另一个ES6的新增的对象Reflect，Reflect对象就是用来获取对象中默认方法的，这个下篇文章再具体讨论。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Proxy可以用于更改方法的默认输出，比如get方法取不到值时不返回undefined，以及在set方法上加验证及数据绑定等等，很强大也有用，需熟练掌握。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://blog.greenroots.info/metaprogramming-an-introduction-to-javascriptes6-proxy-cjwkk64ly000gvds10db4l034" target="_blank" rel="noopener">Tapas Adhikary</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">Proxy - JavaScript | MDN</a><br><a href="http://es6.ruanyifeng.com/#docs/proxy" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/proxy</a></p>
]]></content>
      <categories>
        <category>JavaScript ES6</category>
      </categories>
      <tags>
        <tag>ES6 Proxy</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo搭建个人博客部署于Github与Coding</title>
    <url>/2016/08/14/Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E4%BA%8EGithub%E4%B8%8ECoding/</url>
    <content><![CDATA[<ul>
<li>早就听说可以自己弄一个博客然后免费部署到github上面，但是一直没机会着手去做，前几天，机缘巧合之下，发现了<a href="https://www.npmjs.com/package/hexo" target="_blank" rel="noopener">Hexo</a>这个好东西，这才发现原来它就是我苦苦找寻的的东西啊。真是“<strong>踏破铁鞋无觅处，得来全不费功夫。</strong>”啊。</li>
<li>那好，lz要开始搭建个人博客啦（入坑了）。期间各种坑只能自己体会，虽然外面已经很多搭建的教程了，但是我也来凑个热闹，其实也算是记录一下自己学习的过程，还有期间所遇的各种坑以至于不得不中断到改日再战的坑，在次记录一下让后面的小伙伴们更方便一些，不至于那么惨。</li>
<li>首先必须<strong>安装一下<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a> for windows</strong>,然后申请个<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号啊，建议日后想从事CS相关的童鞋多上上全球最大的同性交友网站（GitHub），里面的好东西真不少，受益匪浅啊。</li>
<li>Git不会的童鞋网上搜一下，很简单，在此附上一张命令速查表，方便快捷，虽然貌似后面都没用到git命令。<br><img src="http://upload-images.jianshu.io/upload_images/1741029-4f7a27cef1b46665.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-e5035d2c74ba60c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Git命令"></p>
<a id="more"></a>

<ul>
<li><p>然后是<strong><a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js</a>下载</strong>,稳定版和最新版都可以，个人喜好，Hexo是靠node驱动，所以以上除了github以外都是是必须的。</p>
</li>
<li><p>有不想用国外网站的童鞋也可以使用国内的<a href="https://coding.net" target="_blank" rel="noopener">Coding</a>，原理一样，反正都是仿Github的。虽说国外网站有可能被墙，而且比起国内的慢一点，但是我同时部署了Coding和Github，后者瞬间就能访问了，而前者，呵呵。</p>
</li>
<li><p>对了，第一个坑来了，安装完毕之后一定要重启，不然后面使用<em>npm</em>命令安装Hexo时会提示找不到命令，然后才能继续后面的步骤。重启完毕之后就可以愉快地开始安装了，在Git Bash端执行下面的命令就可以安装Hexo了。</p>
<pre><code>$ npm install hexo-cli -g</code></pre></li>
<li><p>然后初始化hexo，进入文件之后就可以执行后面的命令了。</p>
<pre><code>$ hexo init blog
$ cd blog</code></pre></li>
<li><p>介绍一下hexo下用到的命令：</p>
<pre><code>$ hexo g/generate #生成静态文件
$ hexo s/server #启动服务器，主要用来本地预览
$ hexo d/deploy #将本地文件发布到github或Coding上
$ hexo n/new &quot;postName&quot;#新建一篇文章
$ hexo n/new page &quot;pageName&quot; #新建页面
$ hexo h/help # 查看帮助
$ hexo v/version #查看Hexo的版本</code></pre></li>
<li><p>进入文件之后执行<strong>hexo g</strong>和<strong>hexo s</strong>之后然后用浏览器打开<em><a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></em>，不出意外的话，你就可以看到你的博客了，就像下面这个样子的，当然这个博客只是在本地的，hexo3.0使用的默认主题是landscape。</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-22f51ce15050f2af.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>然后你就可以进行愉快的个性化玩耍了，其中也是各种坑，首先是挑选自己喜欢的<a href="https://github.com/hexojs/hexo/wiki/Themes" target="_blank" rel="noopener">主题</a>，然后使用<strong>git clone</strong>下载到本地，就可以开心地设置了。</li>
<li>首先打开hexo文件的_condig.yml配置文件，还有一个是themes主题下你选择主题的配置文件_condig.yml，两个配置文件名一样，但是一个是主配置文件，一个是主题配置文件，不要搞混。</li>
<li>配置过程中也有不少坑，有遇到一个地方多了或者少了个空格什么的导致整个项目不能运行的，还有配置之后没有达到预期效果的，其实只要按照你选择的主题的文档来，仔细一点，基本上是没什么问题的。</li>
<li>当然，我就是按照文档来配置的，中间也是各种各样的问题，但是，基本上都是网上查查就能查到的普通问题。</li>
<li>我选的主题是<a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">Next.Picces</a>,配置好之后效果如下所示</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-80b1d4c4eb437f5d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li>有点小清新是不是，嗯，<a href="https://halshaw.github.io/" target="_blank" rel="noopener">地址</a>在此,欢迎来踩。</li>
<li>主题中所包含的功能就已经很多了，比如百度统计、打赏、搜索等功能，只要去找到文件中相对应的地方，然后设置就可以使用了。愚蠢的我一开始还想去自己实现一些功能，但是后来仔细阅读主题文档之后才发现，原来都有啊，其自带的功能已足够满足我等骚年。</li>
<li>所以我又去百度统计、多说、leancloud网站注册之后，然后拿到id之后放在配置文件中相应的地方就可以了，而且还实现了打赏功能，但是并没什么卵用。</li>
<li>使用文档很重要啊，这是我主题的<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">使用文档</a>。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-b94e68dd00f6f723.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<ul>
<li><p>好了，到此，你已经配置好本地，然后预览好之后就可以发布了，使用下面</p>
<pre><code>hexo g
hexo d</code></pre></li>
<li><p>命令就可以啦，但是天有不测风云，遇到错误，</p>
<pre><code>ERROR Deployer not found : github</code></pre></li>
<li><p>不用急，执行一下这条命令就可以，还有可能遇到说你的github地址不是仓库，那是因为你的地址没有设置正确，检查一下空格之类的。</p>
<pre><code>npm install hexo-deployer-git --save</code></pre></li>
<li><p>要想以上命令起作用，前提是你的配置文件已经配置如下，这个是同时发布到Github和Coding上面</p>
<pre><code>deploy:
  type: git
  repo: 
    coding: git@git.coding.net:HalShaw/halshaw.git,master
    github: https://github.com/HalShaw/halshaw.github.io.git,master</code></pre></li>
</ul>
<ul>
<li><p>如果只想发布到GIthub上，稍微改一下</p>
<pre><code>deploy:  
  type: git
  repository: https://github.com/HalShaw/halshaw.github.io.git 
  branch: master</code></pre></li>
<li><p>一切顺利的话，就可以啦。但是，慢着，又出现问题了。命令行返回</p>
<pre><code>Invalid argument        </code></pre></li>
<li><p>what?什么鬼？明明本地都可以成功预览了，但是为什么发布不了了呢，我就被这个<strong>hexo d</strong>搞了好久，查了好久才明白，原因是我在我的hexo目录下，我又执行了</p>
<pre><code>npm install</code></pre></li>
<li><p>又安装了一个hexo，所以不能发布了，所以删除之后就可以高兴滴执行<strong>hexo d</strong>啦。</p>
</li>
<li><p>谢天谢地，终于发布上去了，然而，不到一分钟，我就收到了Github发来的邮件</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/1741029-fbd6b116e700b063.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p>
<p>创建page失败，madan，招谁惹谁了我，怎么遇到这么多问题呢。又是一番搜索之后找到了一个我认为满意的答案</p>
<pre><code>- Make a backup of the content locally
- Delete the repository from GitHub
- Delete the repository locally
- Recreate the repository, ensuring that you don&apos;t include the repository within the repository locally, which is what you did previously
- Push it to GitHub</code></pre><ul>
<li>意思就是我git仓库里面又包括其他仓库啦，让我把他们搞好之后再上传，果然，我到主题文件下把.git文件删除之后，然后再次发布，终于，大功告成。就是刚才那个小清新的博客啦。</li>
<li>然后就开始写文章吧，该博客只支持<a href="http://www.jianshu.com/p/q81RER/" target="_blank" rel="noopener">markdown</a>语法，所以不会的小伙伴也不要怕，花个几分钟就可以上手啦。在Git终端输入上面的新建文章命令就可以新建一篇文章啦。然后会显示文章所在路径，找到并打开开始写文章吧。</li>
</ul>
<pre><code>$ hexo n my first
INFO  Created: D:\hexo1\hexo\source\_posts\first.md</code></pre><ul>
<li><p>打开之后是这样的，你可以自己设置标签和分类，然后就开始写你自己的故事吧。</p>
<pre><code>title: my first#标题和日期必须唯一，因为访问文章的url是根据二者生成的
date: 2016-08-25 15:33:58
tags: &apos;try&apos; #标签
categories: &quot;技术&quot; #分类</code></pre></li>
</ul>
<ul>
<li>然后之后写文章每次部署都需要执行如下的命令，需要先清理数据库，生成静态文件之后预览，然后发布。</li>
</ul>
<pre><code>hexo clean
hexo g
hexo s
hexo d</code></pre><ul>
<li>好啦，到这里，文章已经写好，然后发布之后就可以去找小伙伴炫耀啦。</li>
</ul>
<h3 id="本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。"><a href="#本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。" class="headerlink" title="本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。"></a>本文为作者原创，保留所有权，欢迎转载，转载请注明出处，标明作者。</h3>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo Blog</tag>
      </tags>
  </entry>
</search>
